#/ Controller version = 3.13.01
#/ Date = 10/2/2024 11:16 AM
#/ User remarks = 
#0
!PNAME=
!PDESC=
! X1_axis Gantry Standard Homing Process
! Version 1.5 Beta
!!****** Setting Parameter ******!!
LOCAL REAL X1_HmType,X1_multi_indHm,X1_multi_indVel
LOCAL REAL X1_HmVel,X1_IndVel,X1_HmOffset	
LOCAL INT X1_ErrCompensation,X1_ErrCompensationSpacing,X1_ErrCompIniPos
LOCAL INT X1_CurrentCompensation,X1_CurrentCompensationIndex,X1_CurrentCompensationSettleTime
GLOBAL REAL X1_CurrentTableTemp(2)(31)
LOCAL REAL X1_CurrentCompensationTravel,X1_CurrentCompensationSpacing,X1_CurrentCompensationSegment,X1_CurrentCompensationIniPos
LOCAL INT ZONE0,X1_ErrTableIndex
LOCAL REAL X1_GantryHmM_SLPKP,X1_GantryHmM_SLVKP,X1_GantryHmM_SLVKI,X1_GantryHmS_SLPKP,X1_GantryHmS_SLVKP,X1_GantryHmS_SLVKI
LOCAL REAL X1_GantryProdM_SLPKP,X1_GantryProdM_SLVKP,X1_GantryProdM_SLVKI,X1_GantryProdS_SLPKP,X1_GantryProdS_SLVKP,X1_GantryProdS_SLVKI
LOCAL REAL X1_M_XCURI,X1_M_XCURV,X1_S_XCURI,X1_S_XCURV
LOCAL INT X1_IsUsingGantryHmGain,X1_IsFlexibleGantry,X1_IsGantryComove,X1_EtherCATIndex,X1_GantryHomeStep
LOCAL REAL X1_Yawlock
LOCAL REAL X1_CommutCurrent,X1_Yaw_CommutCurrent
!!################ Basic Settings ######################################################################################################
X1_HmType = 3 								!the method of homing
           									!value 0 : Customized homing											
											!	   3 : this type is for gantry mode , and the motion for homing is same as X1_HmType=1.
											!	   4 : this type is for gantry mode , and the motion for homing is same as X1_HmType=2.
X1_HmOffset = 0 								! X1_HmOffset (unit)
X1_HmVel = 30000 !30000								! the velocity for homing 	
X1_IndVel = 1000 								! the velocity for finding index

X1_multi_indHm=0								! multi index structure
											! value 0 : nomal Homing
											!	    1 : find the left limit in negative direction,then slowing leave the limit in positive direction,
											!			then slowing find the left limit in negative direction,then slowing find index in positive direction
X1_multi_indVel = 0.1						! (Do not modify)homing velocity of multi index structure
X1_CommutCurrent = 80						! Commutation excitation current.
X1_Yaw_CommutCurrent = 80					! Yaw axis Commutation excitation current.
!!*********************************** X1_axis Gantry mod ***************************************************!!
X1_IsFlexibleGantry = 0 						! 0: Stiff Gantry ; 1: Flexible Gantry (X1_IsGantryComove automatically set to 1 )
X1_IsGantryComove = 0						! 0: Search limit and index by X1_axis
											! 1: Search limit and index by X1_axis and X1_Yaw_axis comove
X1_Yawlock = -263							! X1_Yaw_axis follow position
X1_M_XCURI = 45								! X1_axis XCURI
X1_M_XCURV = 90								! X1_axis XCURV
X1_S_XCURI = 10								! X1_Yaw_axis XCURI
X1_S_XCURV = 10								! X1_Yaw_axis XCURV

X1_IsUsingGantryHmGain = 1					! 0 : Homing and production using same gain 
											! 1 : Homing and production using different gain 
!------------------Homing and production gain set (Set by X1_IsUsingGantryHmGain = 1)-----------------!
X1_GantryHmM_SLPKP = 40						! X1_axis homing gain
X1_GantryHmM_SLVKP = 100	
X1_GantryHmM_SLVKI = 100
X1_GantryHmS_SLPKP = 0						! X1_Yaw_axis homing gain
X1_GantryHmS_SLVKP = 40
X1_GantryHmS_SLVKI = 40
X1_GantryProdM_SLPKP = 200						! X1_axis production gain
X1_GantryProdM_SLVKP = 400
X1_GantryProdM_SLVKI = 220
X1_GantryProdS_SLPKP = 40						! X1_Yaw_axis production gain
X1_GantryProdS_SLVKP = 40
X1_GantryProdS_SLVKI = 100
!!**************** Configuration of 1D Error Compensation*****************************************************!!
X1_ErrCompensation = 1						! 0 : without compensation  ; 1 : turn on the compensation after homing completed 
X1_ErrCompIniPos = 0							! the initial position of error compensation
X1_ErrCompensationSpacing = 90000				! setting the spacing for error compensation //mm
!!**************** Configuration of Current Compensation for gantry mode ***************************************!!
X1_CurrentCompensation = 1    				! Current Compensation
											! the value 0 : without current compensation.
											!           1 : Enable current compensation mode with exist current table. 
											!           2 : Execute the process of current table search after homing , and then 
											!               enable current compensation mode.
X1_CurrentCompensationIniPos = 0				! compensation start postion
X1_CurrentCompensationTravel = 2700000			! the stroke (unit) of CurrentCompensation
X1_CurrentCompensationSegment = 30			! the segment for current compensation.
X1_CurrentCompensationSettleTime = 5000		! time requiered for Yaw axis to take satisfactory position
X1_CurrentCompensationSpacing = X1_CurrentCompensationTravel / X1_CurrentCompensationSegment	 ! the spacing for current compensation (unit)
!!**********************************************************************************************************!!
!!######################################################################################################################################## 

!!**************************************************************************************************************************************!!
!!************************************************************ Main program ************************************************************!!

IF X1_HmType=0		
	MFLAGS(X1_axis).#HOME=0;	MFLAGS(X1_Yaw_axis).#HOME=0											! Customized homing
	CALL X1_HmType0
ELSEIF X1_HmType>=3 & X1_HmType<=4 			! Gantry Homing	
	MFLAGS(X1_axis).#HOME=0;	MFLAGS(X1_Yaw_axis).#HOME=0
	IF X1_HmType=3
		CALL X1_HmType3
	ELSEIF X1_HmType=4
		CALL X1_HmType4
	END
ELSE
	DISP"ERROR:The value of X1_HmType or X1_HiwinDriveHome is invalid!!"
	STOP
END

IF (X1_CurrentCompensation=1 & X1_HmType>=3)
	DISP"Turn on the Current Compensation..."	
	CALL X1_TurnOnCurrentCompensation	
ELSEIF (X1_CurrentCompensation=2 &  X1_HmType>=3)
	CALL X1_CurrentCompensation	
ELSEIF (X1_CurrentCompensation=0 &  X1_HmType>=3)	
	ERRORUNMAP X1_Yaw_axis, ZONE0
END

IF X1_ErrCompensation = 1
	DISP "Enable the compensation mode."
	DISP "Execute the compensation prcoess......"
	CALL X1_ErrorCompensation	
ELSE
	DISP "Disable error compensation."
	ERRORUNMAP X1_axis, ZONE0
END 

IF (X1_HmType>=3&X1_HmType<=4)
	ENABLE (X1_axis)	
	TILL MST(X1_axis).#ENABLED & MST(X1_Yaw_axis).#ENABLED
	WAIT 1000
	DISP"Go home......"	
	PTP/EV X1_axis,0,X1_HmVel		
	PTP/EV X1_Yaw_axis,0,X1_HmVel !Yaw lock s
	MFLAGS(X1_axis).#HOME=1;	MFLAGS(X1_Yaw_axis).#HOME=1	
END	
FDEF(X1_axis).#LL = 	1	;	FDEF(X1_Yaw_axis).#LL =  1			! turn on the response of reaching left limit
FDEF(X1_axis).#SRL = 1	;	FDEF(X1_Yaw_axis).#SRL = 1	 		! enable software right limit response
FDEF(X1_axis).#SLL = 1	;	FDEF(X1_Yaw_axis).#SLL = 1	 		! enable software left limit response
IF X1_IsUsingGantryHmGain=1
	CALL ProdGain
END
WAIT 500
SET FPOS(16) =0	
DISP"RESET PEG ENCODER "
DISP"Homing successful!!"


STOP	

!!*************************************************************************************************************************************!!
!!************************************************************ Homing process	*******************************************************!!
X1_HmType0:
!Customized
RET
STOP
!------------------------------------------------------------------X1_HmType3--------------------------------------------------------------------------------------
X1_HmType3:
X1_GantryHomeStep = 0
IF X1_IsFlexibleGantry = 1 
	X1_IsGantryComove = 1										!Flexible gantry should comove
END

DISABLE (X1_axis,X1_Yaw_axis)	
TILL ^MST(X1_axis).#ENABLED & ^MST(X1_Yaw_axis).#ENABLED	
WAIT 500	
ERRORMAPOFF X1_axis, -1	;	ERRORMAPOFF X1_Yaw_axis, -1			! Close all X1_axis & X1_yaw_axis error compensation
MFLAGS(X1_axis).#GANTRY = 0	;	MFLAGS(X1_Yaw_axis).#GANTRY = 0	! turn off gantry mode (MFLAGS.25)
FDEF(X1_axis).#SRL = 0	;	FDEF(X1_Yaw_axis).#SRL = 0	 		! disable software right limit response
FDEF(X1_axis).#SLL = 0	;	FDEF(X1_Yaw_axis).#SLL = 0	 		! disable software left limit response

IF (^MFLAGS(X1_axis).#BRUSHOK & MFLAGS(X1_axis).#BRUSHL) 			! Confirm BRUSHOK
	ENABLE X1_axis		
	TILL MST(X1_axis).#ENABLED	
	COMMUT X1_axis,X1_CommutCurrent								! do commutation
	TILL MFLAGS(X1_axis).#BRUSHOK								! Wait for the commutation to complete, BRUSHOK is 1
	DISABLE X1_axis		
	TILL ^MST(X1_axis).#ENABLED	
END	
IF (^MFLAGS(X1_Yaw_axis).#BRUSHOK & MFLAGS(X1_Yaw_axis).#BRUSHL)	! Confirm BRUSHOK
	ENABLE X1_Yaw_axis		
	TILL MST(X1_Yaw_axis).#ENABLED
	COMMUT X1_Yaw_axis,X1_Yaw_CommutCurrent							! do commutation
	TILL MFLAGS(X1_Yaw_axis).#BRUSHOK							! Wait for the commutation to complete, BRUSHOK is 1
	DISABLE X1_Yaw_axis		
	TILL ^MST(X1_Yaw_axis).#ENABLED	
END	
DISABLE (X1_axis,X1_Yaw_axis)	
TILL ^MST(X1_axis).#ENABLED & ^MST(X1_Yaw_axis).#ENABLED	
WAIT 500	
MFLAGS(X1_axis).#OPEN =0 ;	MFLAGS(X1_Yaw_axis).#OPEN =0	 		! close loop control
FDEF(X1_axis).#LL = 	0	;	FDEF(X1_Yaw_axis).#LL =  0			! motor is not disable when left limit signal rising.

IF X1_IsUsingGantryHmGain=1
	CALL HmGain
END

IF X1_IsGantryComove = 1											! Comove
	ACC(X1_Yaw_axis)=ACC(X1_axis)									! X1_axis & X1_Yaw_axis should same motion profile
	DEC(X1_Yaw_axis)=DEC(X1_axis)	
	JERK(X1_Yaw_axis)=JERK(X1_axis)
	XCURI(X1_Yaw_axis)=XCURI(X1_axis)	
	XCURV(X1_Yaw_axis)=XCURV(X1_axis)	
	SLPKP(X1_Yaw_axis)=SLPKP(X1_axis)
	SLVKP(X1_Yaw_axis)=SLVKP(X1_axis)
	SLVKI(X1_Yaw_axis)=SLVKI(X1_axis)
	ENABLE (X1_axis,X1_Yaw_axis)
	TILL MST(X1_axis).#ENABLED & MST(X1_Yaw_axis).#ENABLED	
	JOG/WV (X1_axis),-X1_HmVel ; JOG/WV (X1_Yaw_axis),-X1_HmVel	
	GO (X1_axis,X1_Yaw_axis)										! X1_axis & X1_Yaw_axis move same time
	X1_GantryHomeStep = 1										! Start find left limit *(should after GO to avoid unable to stop at left limit)
	IF X1_IsFlexibleGantry = 1
		TILL FAULT(X1_axis).#LL & FAULT(X1_Yaw_axis).#LL
	ELSE
		TILL FAULT(X1_axis).#LL
	END	
	HALT (X1_axis,X1_Yaw_axis)									! found left limit
	TILL ^MST(X1_axis).#MOVE & ^MST(X1_Yaw_axis).#MOVE	
   ELSE															! drag one side
		ENABLE (X1_axis)	
		TILL MST(X1_axis).#ENABLED	
	
		IF FAULT(X1_axis).#LL = 0               !2023.11.02
			JOG/V (X1_axis),-X1_HmVel
			TILL IN0.0  | FAULT(X1_axis).#LL     !2023.11.02
			HALT X1_axis	                     !2023.11.02
			IF FAULT(X1_axis).#LL = 0 
				JOG/V (X1_axis),-X1_HmVel/4		 !2023.11.02						
				TILL FAULT(X1_axis).#LL
				HALT X1_axis	
			END												! found left limit	
		END	
    END
	TILL ^MST(X1_axis).#MOVE


IF X1_multi_indHm = 1											! multiple index
	IF X1_IsGantryComove = 1										! Comove
		X1_GantryHomeStep = 2									! Start leave left limit
		JOG/WV (X1_axis),X1_multi_indVel ; JOG/WV (X1_Yaw_axis),X1_multi_indVel
		GO (X1_axis,X1_Yaw_axis)
		IF X1_IsFlexibleGantry = 1
			TILL ^FAULT(X1_axis).#LL & ^FAULT(X1_Yaw_axis).#LL
		ELSE
			TILL ^FAULT(X1_axis).#LL
		END 
		HALT (X1_axis,X1_Yaw_axis)								! leave left limit
		TILL ^MST(X1_axis).#MOVE & ^MST(X1_Yaw_axis).#MOVE	
	ELSE														! drag one side
		JOG/V (X1_axis),X1_multi_indVel
		TILL ^FAULT(X1_axis).#LL
		HALT X1_axis
		TILL ^MST(X1_axis).#MOVE	
	END
	X1_IndVel = X1_multi_indVel
END
X1_GantryHomeStep = 3
IST(X1_axis).#IND = 1	;	IST(X1_axis).#IND = 0				! reset the index signal
IST(X1_Yaw_axis).#IND = 1	;	IST(X1_Yaw_axis).#IND = 0	

IF X1_IsGantryComove = 1
	JOG/WV (X1_axis),X1_IndVel ; JOG/WV (X1_Yaw_axis),X1_IndVel
	GO (X1_axis,X1_Yaw_axis)
ELSE
	JOG/V (X1_axis),X1_IndVel
END

TILL IST(X1_axis).#IND & IST(X1_Yaw_axis).#IND	
HALT (X1_axis,X1_Yaw_axis)
TILL ^MST(X1_axis).#MOVE & ^MST(X1_Yaw_axis).#MOVE	
DISP"Already found the index!!"	
DISABLE (X1_axis,X1_Yaw_axis)
TILL ^MST(X1_axis).#ENABLED & ^MST(X1_Yaw_axis).#ENABLED
wait 3000
SET FPOS(X1_axis)=FPOS(X1_axis)-IND(X1_axis)-X1_HmOffset	
SET FPOS(X1_Yaw_axis)=FPOS(X1_Yaw_axis)-IND(X1_Yaw_axis) - X1_HmOffset	+ X1_Yawlock
DISABLE (X1_axis,X1_Yaw_axis)	
TILL ^MST(X1_axis).#ENABLED & ^MST(X1_Yaw_axis).#ENABLED
MFLAGS(X1_axis).#GANTRY = 1	;	MFLAGS(X1_Yaw_axis).#GANTRY = 1	! turn on gantry mode
XCURI(X1_axis) = X1_M_XCURI	;	XCURI(X1_Yaw_axis) = X1_S_XCURI
XCURV(X1_axis) = X1_M_XCURV	;	XCURV(X1_Yaw_axis) = X1_S_XCURV
IF X1_IsUsingGantryHmGain=1
	CALL ProdGain
END

RET	
STOP
!------------------------------------------------------------------X1_HmType4--------------------------------------------------------------------------------------
X1_HmType4:

RET	
STOP
!!****************************************************** Error Compensation Process ***************************************************!!
X1_ErrorCompensation:
!---------- X1_axis Error Compensation Table ------------!
X1_ErrTable(0)=	0	;
X1_ErrTable(1)=	3	;
X1_ErrTable(2)=	8.9	;
X1_ErrTable(3)=	13.9	;
X1_ErrTable(4)=	14.7	;
X1_ErrTable(5)=	17.1	;
X1_ErrTable(6)=	21.5	;
X1_ErrTable(7)=	26.4	;
X1_ErrTable(8)=	29.1	;
X1_ErrTable(9)=	31.3	;
X1_ErrTable(10)=	30	;
X1_ErrTable(11)=	27.9	;
X1_ErrTable(12)=	29.6	;
X1_ErrTable(13)=	31.7	;
X1_ErrTable(14)=	31.7	;
X1_ErrTable(15)=	34.6	;
X1_ErrTable(16)=	36.8	;
X1_ErrTable(17)=	39.9	;
X1_ErrTable(18)=	40.9	;
X1_ErrTable(19)=	44.3	;
X1_ErrTable(20)=	44.8	;
X1_ErrTable(21)=	47.3	;
X1_ErrTable(22)=	49.7	;
X1_ErrTable(23)=	52	;
X1_ErrTable(24)=	53.5	;
X1_ErrTable(25)=	56.2	;
X1_ErrTable(26)=	58	;
X1_ErrTable(27)=	62	;
X1_ErrTable(28)=	66.1	;
X1_ErrTable(29)=	70.1	;
X1_ErrTable(30)=	74.4	;
!X1_ErrTable(0)=	0	;
!X1_ErrTable(1)=	5.9	;
!X1_ErrTable(2)=	7.6	;
!X1_ErrTable(3)=	12.8	;
!X1_ErrTable(4)=	14.2	;
!X1_ErrTable(5)=	19	;
!X1_ErrTable(6)=	23.8	;
!X1_ErrTable(7)=	31.5	;
!X1_ErrTable(8)=	35.7	;
!X1_ErrTable(9)=	38.5	;
!X1_ErrTable(10)=	37.3	;
!X1_ErrTable(11)=	38.8	;
!X1_ErrTable(12)=	40.2	;
!X1_ErrTable(13)=	45.5	;
!X1_ErrTable(14)=	46.7	;
!X1_ErrTable(15)=	50.9	;
!X1_ErrTable(16)=	54.7	;
!X1_ErrTable(17)=	60.7	;
!X1_ErrTable(18)=	63.3	;
!X1_ErrTable(19)=	68.5	;
!X1_ErrTable(20)=	70.7	;
!X1_ErrTable(21)=	75.3	;
!X1_ErrTable(22)=	78.3	;
!X1_ErrTable(23)=	83.1	;
!X1_ErrTable(24)=	85.9	;
!X1_ErrTable(25)=	89.9	;
!X1_ErrTable(26)=	92.9	;
!X1_ErrTable(27)=	98.4	;
!X1_ErrTable(28)=	102.2	;
!X1_ErrTable(29)=	108.7	;
!X1_ErrTable(30)=	113.4	;


!-------------------------------------------------------!
X1_ErrTableIndex = 0
WHILE X1_ErrTableIndex < SIZEOF(X1_ErrTable)
	X1_ErrTable(X1_ErrTableIndex) = -X1_ErrTable(X1_ErrTableIndex)
	X1_ErrTableIndex = X1_ErrTableIndex + 1
END
ERRORUNMAP X1_axis, ZONE0
!ERRORMAP1D X1_axis, ZONE0, X1_ErrCompIniPos, X1_ErrCompensationSpacing, X1_ErrTable !2023.12.25 mark
ERRORMAP1D/p X1_axis, ZONE0, X1_ErrCompIniPos, X1_ErrCompensationSpacing, X1_ErrTable  !2023.12.25 becasue PEG1 lose pluse ,and PEG16 sysnc
ERRORMAPON X1_axis, ZONE0

WAIT 500	
DISP "Cmpensation Procces's completed!"

RET 
STOP

!!*************************************************************************************************************************************!!
!!********************************************************* Current Compensation ******************************************************!!
X1_CurrentCompensation:
ENABLE X1_axis
TILL MST(X1_axis).#ENABLED & MST(X1_Yaw_axis).#ENABLED 
PTP/EV X1_axis,X1_CurrentCompensationIniPos,X1_HmVel
DISABLE X1_axis
TILL ^MST(X1_axis).#ENABLED & ^MST(X1_Yaw_axis).#ENABLED 
MFLAGS(X1_Yaw_axis).#OPEN = 1		
ENABLE X1_axis
TILL MST(X1_axis).#ENABLED & MST(X1_Yaw_axis).#ENABLED 

PTP/EV X1_axis,X1_CurrentCompensationIniPos,X1_HmVel
WAIT X1_CurrentCompensationSettleTime
X1_CurrentCompensationIndex = 0
!Move positive
DISP"Y error table search sequence in positive direction......"
WHILE X1_CurrentCompensationIndex <= X1_CurrentCompensationSegment
	DISP"Y FPOS=%f , Y Yaw Offset = %f ",FPOS(X1_axis),FPOS(X1_Yaw_axis)
	X1_CurrentTableTemp(0)(X1_CurrentCompensationIndex) = FPOS(X1_Yaw_axis)
	IF X1_CurrentCompensationIndex < X1_CurrentCompensationSegment
		PTP/ERV X1_axis,X1_CurrentCompensationSpacing,X1_HmVel		
		WAIT X1_CurrentCompensationSettleTime
	END
	X1_CurrentCompensationIndex = X1_CurrentCompensationIndex + 1	
END

PTP/EV X1_axis,X1_CurrentCompensationIniPos + X1_CurrentCompensationTravel,X1_HmVel
WAIT X1_CurrentCompensationSettleTime
X1_CurrentCompensationIndex = X1_CurrentCompensationSegment
!Move negative unfinished
DISP"Y error table search sequence in negative direction......"
WHILE X1_CurrentCompensationIndex >= 0
	DISP"Y FPOS=%f , Y Yaw Offset = %f ",FPOS(X1_axis),FPOS(X1_Yaw_axis)
	X1_CurrentTableTemp(1)(X1_CurrentCompensationIndex) = FPOS(X1_Yaw_axis)
	IF X1_CurrentCompensationIndex > 0
		PTP/ERV X1_axis,-X1_CurrentCompensationSpacing,X1_HmVel		
		WAIT X1_CurrentCompensationSettleTime
	END
	X1_CurrentCompensationIndex = X1_CurrentCompensationIndex - 1	
END

X1_CurrentCompensationIndex = 0
WHILE X1_CurrentCompensationIndex <= X1_CurrentCompensationSegment
	X1_CurrentTable(X1_CurrentCompensationIndex)	=	(X1_CurrentTableTemp(0)(X1_CurrentCompensationIndex) + X1_CurrentTableTemp(1)(X1_CurrentCompensationIndex))/2
	X1_CurrentCompensationIndex = X1_CurrentCompensationIndex + 1
END

WRITE X1_CurrentTable,X1_CurrentTable
WAIT 1500	
PTP/EV X1_axis,X1_CurrentCompensationIniPos,X1_HmVel
WAIT 500	

X1_TurnOnCurrentCompensation:
DISABLE X1_axis
TILL ^MST(X1_axis).#ENABLED & ^MST(X1_Yaw_axis).#ENABLED
MFLAGS(X1_Yaw_axis).#OPEN = 0
ENABLE (X1_axis,X1_Yaw_axis)
TILL MST(X1_axis).#ENABLED & MST(X1_Yaw_axis).#ENABLED
READ X1_CurrentTable,X1_CurrentTable
ERRORUNMAP X1_Yaw_axis, ZONE0
!ERRORMAP1D X1_Yaw_axis, ZONE0, X1_CurrentCompensationIniPos, X1_CurrentCompensationSpacing, X1_CurrentTable !2023.12.25 mark
ERRORMAP1D/p X1_Yaw_axis, ZONE0, X1_CurrentCompensationIniPos, X1_CurrentCompensationSpacing, X1_CurrentTable !2023.12.25 becasue PEG1 lose pluse ,and PEG16 sysnc
ERRORMAPON X1_Yaw_axis, ZONE0
DISP"Current compensaton completed!"
RET 
STOP
!!*************************************************************************************************************************************!!
!**************************************Gains for homing********************************************!
HmGain:

SLPKP(X1_axis)= X1_GantryHmM_SLPKP	
SLVKP(X1_axis)= X1_GantryHmM_SLVKP	
SLVKI(X1_axis)= X1_GantryHmM_SLVKI	

SLPKP(X1_Yaw_axis)= X1_GantryHmS_SLPKP	
SLVKP(X1_Yaw_axis)= X1_GantryHmS_SLVKP	
SLVKI(X1_Yaw_axis)= X1_GantryHmS_SLVKI	


RET	
STOP
!**************************************Gains for production*****************************************!
ProdGain:

SLPKP(X1_axis)= X1_GantryProdM_SLPKP	
SLVKP(X1_axis)= X1_GantryProdM_SLVKP	
SLVKI(X1_axis)= X1_GantryProdM_SLVKI	

SLPKP(X1_Yaw_axis)= X1_GantryProdS_SLPKP	
SLVKP(X1_Yaw_axis)= X1_GantryProdS_SLVKP	
SLVKI(X1_Yaw_axis)= X1_GantryProdS_SLVKI	

RET
STOP
!!*************************************************************************************************************************************!!


!!#############################################################################################################################

ON X1_GantryHomeStep = 1 & X1_IsFlexibleGantry = 1 & FAULT(X1_axis).#LL
	HALT X1_axis
RET

ON X1_GantryHomeStep = 1 & X1_IsFlexibleGantry = 1 & FAULT(X1_Yaw_axis).#LL
	HALT X1_Yaw_axis
RET

ON X1_GantryHomeStep = 2 & X1_IsFlexibleGantry = 1 & ^FAULT(X1_axis).#LL
	HALT X1_axis
RET

ON X1_GantryHomeStep = 2 & X1_IsFlexibleGantry = 1 & ^FAULT(X1_Yaw_axis).#LL
	HALT X1_Yaw_axis
RET


ON (MFLAGS(X1_axis).#HOME=1)& (MFLAGS(X1_Yaw_axis).#HOME=1)& (TPOS(X1_axis) < SLLIMIT(X1_axis)) 
	IF( FDEF(X1_axis).#SLL=1 & FMASK(X1_axis).#SLL=1 & ^(GMTYPE(X1_axis)=5))
		KILL X1_axis,5016	!Software Left Limit
		TPOS(X1_axis)=FPOS(X1_axis)
		DISP "TPOS(X1_axis) < SLLIMIT(X1_axis)"
	END
RET

ON (MFLAGS(X1_axis).#HOME=1)& (MFLAGS(X1_Yaw_axis).#HOME=1)& (TPOS(X1_axis) > SRLIMIT(X1_axis)) 
	IF(FDEF(X1_axis).#SRL=1 & FMASK(X1_axis).#SRL=1 & ^(GMTYPE(X1_axis)=5))
		KILL X1_axis,5015	!Software Right Limit
		TPOS(X1_axis)=FPOS(X1_axis)
		DISP "TPOS(X1_axis) > SRLIMIT(X1_axis)"
	END
RET

ON (MFLAGS(X1_axis).#HOME=1)& (MFLAGS(X1_Yaw_axis).#HOME=1)& (TPOS(X1_Yaw_axis) < SLLIMIT(X1_Yaw_axis)) 
	IF( FDEF(X1_Yaw_axis).#SLL=1 & FMASK(X1_Yaw_axis).#SLL=1 & ^(GMTYPE(X1_Yaw_axis)=5))
		KILL X1_Yaw_axis,5016	!Software Left Limit
		TPOS(X1_Yaw_axis)=FPOS(X1_Yaw_axis)
		DISP "TPOS(X1_Yaw_axis) < SLLIMIT(X1_Yaw_axis)"
	END
RET

ON (MFLAGS(X1_axis).#HOME=1)& (MFLAGS(X1_Yaw_axis).#HOME=1) & (TPOS(X1_Yaw_axis) > SRLIMIT(X1_Yaw_axis)) 
	IF(FDEF(X1_Yaw_axis).#SRL=1 & FMASK(X1_Yaw_axis).#SRL=1 & ^(GMTYPE(X1_Yaw_axis)=5))
		KILL X1_Yaw_axis,5015	!Software Right Limit
		TPOS(X1_Yaw_axis)=FPOS(X1_Yaw_axis)
		DISP "TPOS(X1_Yaw_axis) > SRLIMIT(X1_Yaw_axis)"
	END
RET



ON MFLAGS(X1_axis).#HOME=0 & RVEL(X1_axis) > XVEL(X1_axis)*0.5 & ^MST(X1_axis).#INPOS
	IMM VEL(X1_axis) = XVEL(X1_axis)*0.45 !?30
RET

ON MFLAGS(X1_axis).#HOME=0 & RVEL(X1_axis) < -XVEL(X1_axis)*0.5 & ^MST(X1_axis).#INPOS
	IMM VEL(X1_axis) = -XVEL(X1_axis)*0.45 !?30
RET

AUTOEXEC:
	MFLAGS(X1_axis).#HOME=0;	MFLAGS(X1_Yaw_axis).#HOME=0
STOP

#1
!PNAME=
!PDESC=
! Y1_axis Single-axis_ACS_Drive_Homing_Process_VER1.5
!!****** Setting Parameter ******!!
LOCAL REAL Y1_HmType,Y1_multi_indHm,Y1_multi_indVel
LOCAL REAL Y1_HmVel,Y1_IndVel,Y1_HmOffset	
LOCAL INT Y1_ErrCompensation,Y1_ErrCompensationSpacing,Y1_ErrCompIniPos
LOCAL INT ZONE0,Y1_ErrTableIndex
LOCAL REAL Y1_HiwinDriveHmVel,Y1_HiwinDriveIndVel,Y1_HiwinDriveHmOffset,Y1_HiwinDriveHmAcc
LOCAL REAL Y1_CommutCurrent
!!################ Basic Settings ######################################################################################################
Y1_HmType = 1 								!the method of homing
           									!value 0 : Customized homing
           									!	   1 : find the left limit in negative direction,then find index in positive direction 
           									!      2 : find index in positive direction directly 
Y1_HmOffset = 10000 								! Y1_HmOffset (unit)
Y1_HmVel =  5000! 30000								! the velocity for homing 	
Y1_IndVel = 10000 								! the velocity for finding index

Y1_multi_indHm=0								! multi index structure
											! value 0 : nomal Homing
											!	    1 : find the left limit in negative direction,then slowing leave the limit in positive direction,
											!			then slowing find the left limit in negative direction,then slowing find index in positive direction
Y1_multi_indVel = 100						! (Do not modify)homing velocity of multi index structure
Y1_CommutCurrent = 80						! Commutation excitation current.
!!**************** Configuration of 1D Error Compensation*****************************************************!!
Y1_ErrCompensation = 1						! 0 : without compensation  ; 1 : turn on the compensation after homing completed 
Y1_ErrCompIniPos = 0							! the initial position of error compensation
Y1_ErrCompensationSpacing = 2000				! setting the spacing for error compensation 

!!######################################################################################################################################## 

!!**************************************************************************************************************************************!!
!!************************************************************ Main program ************************************************************!!

IF Y1_HmType=0													! Customized homing
	MFLAGS(Y1_axis).#HOME=0
	CALL Y1_HmType0
ELSEIF Y1_HmType=1				 					 			! Single axis homing	
	MFLAGS(Y1_axis).#HOME=0
	CALL Y1_HmType1	
ELSEIF Y1_HmType=2
	MFLAGS(Y1_axis).#HOME=0
	CALL Y1_HmType2
ELSE
	DISP"ERROR:The value of Y1_HmType or Y1_HiwinDriveHome is invalid!!"
	STOP
END

IF Y1_ErrCompensation = 1
	DISP "Enable the compensation mode."
	DISP "Execute the compensation prcoess......"
	CALL Y1_ErrorCompensation	
ELSE
	DISP "Disable error compensation."
	ERRORUNMAP Y1_axis, ZONE0
END 

ENABLE Y1_axis
TILL MST(Y1_axis).#ENABLED
WAIT 500
DISP"Go home......"	
PTP/EV Y1_axis,0,Y1_HmVel	
MFLAGS(Y1_axis).#HOME=1
	
FDEF(Y1_axis).#LL = 1	 		
FDEF(Y1_axis).#SRL = 1	 		
FDEF(Y1_axis).#SLL = 1	 
DISP"Homing successful!!"	

STOP	

!!*************************************************************************************************************************************!!
!!************************************************************ Homing process	*******************************************************!!
Y1_HmType0:
!Customized
RET
STOP
!------------------------------------------------------------------Y1_HmType1--------------------------------------------------------------------------------------
Y1_HmType1:

IF (^MFLAGS(Y1_axis).#BRUSHOK & MFLAGS(Y1_axis).#BRUSHL) 			! Confirm BRUSHOK
	DISP "Do commutation"
	ENABLE Y1_axis		
	TILL MST(Y1_axis).#ENABLED	
	COMMUT Y1_axis,Y1_CommutCurrent		  						! do commutation
	TILL MFLAGS(Y1_axis).#BRUSHOK								! Wait for the commutation to complete, BRUSHOK is 1
END	
DISABLE Y1_axis		
TILL ^MST(Y1_axis).#ENABLED	
WAIT 500	
MFLAGS(Y1_axis).#OPEN = 0										! Close loop control
ERRORMAPOFF Y1_axis, -1											! Close all Y1_axis error compensation
MFLAGS(Y1_axis).#GANTRY = 0	 									! turn off gantry mode (MFLAGS.25)	
FDEF(Y1_axis).#LL = 0	 										! motor is not disable when left limit signal rising.
FDEF(Y1_axis).#SRL = 0	 										! disable software right limit response
FDEF(Y1_axis).#SLL = 0	 										! disable software left limit response

ENABLE	Y1_axis	 
TILL MST(Y1_axis).#ENABLED	 
WAIT 500	
DISP"Start to find the left limit......"

IF FAULT(Y1_axis).#LL = 0           !2023.11.02
	JOG/V (Y1_axis),-Y1_HmVel       !2023.11.02
	TILL IN0.1 | FAULT(Y1_axis).#LL     !2023.11.02
	HALT Y1_axis	
	IF FAULT(Y1_axis).#LL = 0           !2023.11.02
		JOG/V Y1_axis,-Y1_HmVel/4		!2023.11.02									! find the left limit in negative direction
		TILL FAULT(Y1_axis).#LL 
		HALT Y1_axis 
	END
 
END
TILL ^MST(Y1_axis).#MOVE											! if reach left limit , stop motion
DISP"Already found the left limit!!"

!!!!!!!!!!!!!!!!!!!!multi index Structure Homing Way!!!!!!!!!!!!!!!
IF(Y1_multi_indHm = 1)	
	JOG/V Y1_axis,Y1_multi_indVel									! slowing to leave the limit in negative direction
	TILL ^FAULT(Y1_axis).#LL										! waiting to leave the limit
	HALT Y1_axis
	TILL ^MST(Y1_axis).#MOVE 
	Y1_IndVel = Y1_multi_indVel									! define slowing velocity to find index velocity
END
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
IST(Y1_axis).#IND = 1	; IST(Y1_axis).#IND = 0					! reset the switch of index signal
WAIT 100	
IF (MST(Y1_axis).#ENABLED = 0) !2023.11.02
	ENABLE	Y1_axis	  !2023.11.02
	TILL MST(Y1_axis).#ENABLED	 !2023.11.02
END

DISP"Start to find the index in positive direction......"
JOG/V Y1_axis,Y1_IndVel											!find the index in positive direction
TILL IST(Y1_axis).#IND											!if reach index	, stop motion
HALT Y1_axis		
TILL ^MST(Y1_axis).#MOVE 
DISP"Already found the index!!"
SET FPOS(Y1_axis) = FPOS(Y1_axis) - IND(Y1_axis)-Y1_HmOffset		!set index position as zero.		
RET	
STOP
!------------------------------------------------------------------Y1_HmType2--------------------------------------------------------------------------------------
Y1_HmType2:

RET	
STOP
!!****************************************************** Error Compensation Process ***************************************************!!
Y1_ErrorCompensation:
!---------- Y1_axis Error Compensation Table ------------!
Y1_ErrTable(0)=	0	;
Y1_ErrTable(1)=	0	;
Y1_ErrTable(2)=	-0.2	;
Y1_ErrTable(3)=	-0.3	;
Y1_ErrTable(4)=	-0.6	;
Y1_ErrTable(5)=	-0.9	;
Y1_ErrTable(6)=	-0.9	;
Y1_ErrTable(7)=	-1.1	;
Y1_ErrTable(8)=	-1.1	;
Y1_ErrTable(9)=	-1.3	;


!-------------------------------------------------------!
Y1_ErrTableIndex = 0
WHILE Y1_ErrTableIndex < SIZEOF(Y1_ErrTable)
	Y1_ErrTable(Y1_ErrTableIndex) = -Y1_ErrTable(Y1_ErrTableIndex)
	Y1_ErrTableIndex = Y1_ErrTableIndex + 1
END
ERRORUNMAP Y1_axis, ZONE0
ERRORMAP1D Y1_axis, ZONE0, Y1_ErrCompIniPos, Y1_ErrCompensationSpacing, Y1_ErrTable
ERRORMAPON Y1_axis, ZONE0

WAIT 500	
DISP "Cmpensation Procces's completed!"

RET 
STOP
!!#############################################################################################################################

ON MFLAGS(Y1_axis).#HOME=1 & TPOS(Y1_axis) < SLLIMIT(Y1_axis) 
	IF( FDEF(Y1_axis).#SLL=1 & FMASK(Y1_axis).#SLL=1 & ^(GMTYPE(Y1_axis)=5))
		KILL Y1_axis,5016	!Software Left Limit
		TPOS(Y1_axis)=FPOS(Y1_axis)
		DISP "TPOS(Y1_axis) < SLLIMIT(Y1_axis)"
	END
RET

ON MFLAGS(Y1_axis).#HOME=1 & TPOS(Y1_axis) > SRLIMIT(Y1_axis) 
	IF(FDEF(Y1_axis).#SRL=1 & FMASK(Y1_axis).#SRL=1 & ^(GMTYPE(Y1_axis)=5))
		KILL Y1_axis,5015	!Software Right Limit
		TPOS(Y1_axis)=FPOS(Y1_axis)
		DISP "TPOS(Y1_axis) > SRLIMIT(Y1_axis)"
	END
RET


ON MFLAGS(Y1_axis).#HOME=0 & RVEL(Y1_axis) > XVEL(Y1_axis)*0.5 & ^MST(Y1_axis).#INPOS
	IMM VEL(Y1_axis) = XVEL(Y1_axis)*0.45
RET

ON MFLAGS(Y1_axis).#HOME=0 & RVEL(Y1_axis) < -XVEL(Y1_axis)*0.5 & ^MST(Y1_axis).#INPOS
	IMM VEL(Y1_axis) = -XVEL(Y1_axis)*0.45
RET

AUTOEXEC:
	MFLAGS(Y1_axis).#HOME=0
STOP

#2
!PNAME=
!PDESC=
! Y2_1_axis Gantry Standard Homing Process
! Version 1.5 Beta
!!****** Setting Parameter ******!!
LOCAL REAL Y2_1_HmType,Y2_1_multi_indHm,Y2_1_multi_indVel
LOCAL REAL Y2_1_HmVel,Y2_1_IndVel,Y2_1_HmOffset	
LOCAL INT Y2_1_ErrCompensation,Y2_1_ErrCompensationSpacing,Y2_1_ErrCompIniPos
LOCAL INT Y2_1_CurrentCompensation,Y2_1_CurrentCompensationIndex,Y2_1_CurrentCompensationSettleTime
GLOBAL REAL Y2_1_CurrentTableTemp(2)(21)
LOCAL REAL Y2_1_CurrentCompensationTravel,Y2_1_CurrentCompensationSpacing,Y2_1_CurrentCompensationSegment,Y2_1_CurrentCompensationIniPos
LOCAL INT ZONE0,Y2_1_ErrTableIndex
LOCAL REAL Y2_1_GantryHmM_SLPKP,Y2_1_GantryHmM_SLVKP,Y2_1_GantryHmM_SLVKI,Y2_1_GantryHmS_SLPKP,Y2_1_GantryHmS_SLVKP,Y2_1_GantryHmS_SLVKI
LOCAL REAL Y2_1_GantryProdM_SLPKP,Y2_1_GantryProdM_SLVKP,Y2_1_GantryProdM_SLVKI,Y2_1_GantryProdS_SLPKP,Y2_1_GantryProdS_SLVKP,Y2_1_GantryProdS_SLVKI
LOCAL REAL Y2_1_M_XCURI,Y2_1_M_XCURV,Y2_1_S_XCURI,Y2_1_S_XCURV
LOCAL INT Y2_1_IsUsingGantryHmGain,Y2_1_IsFlexibleGantry,Y2_1_IsGantryComove,Y2_1_EtherCATIndex,Y2_1_GantryHomeStep
LOCAL REAL Y2_1_Yawlock
LOCAL REAL Y2_1_CommutCurrent,Y2_1_Yaw_CommutCurrent
!!################ Basic Settings ######################################################################################################
Y2_1_HmType = 0 								!the method of homing
           									!value 0 : Customized homing											
											!	   3 : this type is for gantry mode , and the motion for homing is same as Y2_1_HmType=1.
											!	   4 : this type is for gantry mode , and the motion for homing is same as Y2_1_HmType=2.
Y2_1_HmOffset = 0 								! Y2_1_HmOffset (unit)
Y2_1_HmVel = 20000								! the velocity for homing 	
Y2_1_IndVel = 10000 								! the velocity for finding index

Y2_1_multi_indHm=0								! multi index structure
											! value 0 : nomal Homing
											!	    1 : find the left limit in negative direction,then slowing leave the limit in positive direction,
											!			then slowing find the left limit in negative direction,then slowing find index in positive direction
Y2_1_multi_indVel = 100						! (Do not modify)homing velocity of multi index structure
Y2_1_CommutCurrent = 80						! Commutation excitation current.
Y2_1_Yaw_CommutCurrent = 80					! Yaw axis Commutation excitation current.
!!*********************************** Y2_1_axis Gantry mod ***************************************************!!
Y2_1_IsFlexibleGantry = 0 						! 0: Stiff Gantry ; 1: Flexible Gantry (Y2_1_IsGantryComove automatically set to 1 )
Y2_1_IsGantryComove = 0						! 0: Search limit and index by Y2_1_axis
											! 1: Search limit and index by Y2_1_axis and Y2_1_Yaw_axis comove
Y2_1_Yawlock = 615							! Y2_1_Yaw_axis follow position
Y2_1_M_XCURI = 40								! Y2_1_axis XCURI
Y2_1_M_XCURV = 90								! Y2_1_axis XCURV
Y2_1_S_XCURI = 10								! Y2_1_Yaw_axis XCURI
Y2_1_S_XCURV = 10								! Y2_1_Yaw_axis XCURV

Y2_1_IsUsingGantryHmGain = 1					! 0 : Homing and production using same gain 
											    ! 1 : Homing and production using different gain 
!------------------Homing and production gain set (Set by Y2_1_IsUsingGantryHmGain = 1)-----------------!
Y2_1_GantryHmM_SLPKP = 20						! Y2_1_axis homing gain
Y2_1_GantryHmM_SLVKP = 50		
Y2_1_GantryHmM_SLVKI = 50
Y2_1_GantryHmS_SLPKP = 0						! Y2_1_Yaw_axis homing gain
Y2_1_GantryHmS_SLVKP = 20
Y2_1_GantryHmS_SLVKI = 40
Y2_1_GantryProdM_SLPKP = 140					! Y2_1_axis production gain
Y2_1_GantryProdM_SLVKP = 80
Y2_1_GantryProdM_SLVKI = 150
Y2_1_GantryProdS_SLPKP = 40						! Y2_1_Yaw_axis production gain
Y2_1_GantryProdS_SLVKP = 40
Y2_1_GantryProdS_SLVKI = 120
!!**************** Configuration of 1D Error Compensation*****************************************************!!
Y2_1_ErrCompensation = 1						! 0 : without compensation  ; 1 : turn on the compensation after homing completed 
Y2_1_ErrCompIniPos = -1900000							! the initial position of error compensation
Y2_1_ErrCompensationSpacing = 95000				! setting the spacing for error compensation 
!!**************** Configuration of Current Compensation for gantry mode ***************************************!!
Y2_1_CurrentCompensation = 1   				! Current Compensation
											! the value 0 : without current compensation.
											!           1 : Enable current compensation mode with exist current table. 
											!           2 : Execute the process of current table search after homing , and then 
											!               enable current compensation mode.
Y2_1_CurrentCompensationIniPos = -1900000				! compensation start postion
Y2_1_CurrentCompensationTravel = 1900000		! the stroke (unit) of CurrentCompensation
Y2_1_CurrentCompensationSegment = 10			! the segment for current compensation.
Y2_1_CurrentCompensationSettleTime = 5000		! time requiered for Yaw axis to take satisfactory position
Y2_1_CurrentCompensationSpacing = Y2_1_CurrentCompensationTravel / Y2_1_CurrentCompensationSegment	 ! the spacing for current compensation (unit)
!!**********************************************************************************************************!!
!!######################################################################################################################################## 

!!**************************************************************************************************************************************!!
!!************************************************************ Main program ************************************************************!!
IF Y2_1_HmType=0		
	MFLAGS(Y2_1_axis).#HOME=0;	MFLAGS(Y2_1_Yaw_axis).#HOME=0											! Customized homing
	CALL Y2_1_HmType0
ELSEIF Y2_1_HmType>=3 & Y2_1_HmType<=4 			! Gantry Homing	
	MFLAGS(Y2_1_axis).#HOME=0;	MFLAGS(Y2_1_Yaw_axis).#HOME=0 
	IF Y2_1_HmType=3
		CALL Y2_1_HmType3
	ELSEIF Y2_1_HmType=4
		CALL Y2_1_HmType4
	END
ELSE
	DISP"ERROR:The value of Y2_1_HmType or Y2_1_HiwinDriveHome is invalid!!"
	STOP
END

IF (Y2_1_CurrentCompensation=1 & (Y2_1_HmType>=3| Y2_1_HmType=0))
	DISP"Turn on the Current Compensation..."	
	CALL Y2_1_TurnOnCurrentCompensation	
ELSEIF (Y2_1_CurrentCompensation=2 &  (Y2_1_HmType>=3| Y2_1_HmType=0))
	CALL Y2_1_CurrentCompensation	
ELSEIF (Y2_1_CurrentCompensation=0 &  (Y2_1_HmType>=3| Y2_1_HmType=0))	
	ERRORUNMAP Y2_1_Yaw_axis, ZONE0
END

IF Y2_1_ErrCompensation = 1
	DISP "Enable the compensation mode."
	DISP "Execute the compensation prcoess......"
	CALL Y2_1_ErrorCompensation	
ELSE
	DISP "Disable error compensation."
	ERRORUNMAP Y2_1_axis, ZONE0
END 

IF (Y2_1_HmType>=3&Y2_1_HmType<=4) | Y2_1_HmType=0
	ENABLE (Y2_1_axis)	
	TILL MST(Y2_1_axis).#ENABLED & MST(Y2_1_Yaw_axis).#ENABLED
	WAIT 500
	DISP"Go home......"	
	PTP/EV Y2_1_axis,0,Y2_1_HmVel		
	PTP/EV Y2_1_Yaw_axis,0,Y2_1_HmVel !Yaw lock s
	MFLAGS(Y2_1_axis).#HOME=1;	MFLAGS(Y2_1_Yaw_axis).#HOME=1	
END	
FDEF(Y2_1_axis).#RL = 	1	;	FDEF(Y2_1_Yaw_axis).#RL =  1			! turn on the response of reaching Right limit
FDEF(Y2_1_axis).#SRL = 1	;	FDEF(Y2_1_Yaw_axis).#SRL = 1	 		! enable software right limit response
FDEF(Y2_1_axis).#SLL = 1	;	FDEF(Y2_1_Yaw_axis).#SLL = 1	 		! enable software left limit response
IF Y2_1_IsUsingGantryHmGain=1
	CALL ProdGain
END
DISP"Homing successful!!"	



STOP	

!!*************************************************************************************************************************************!!
!!************************************************************ Homing process	*******************************************************!!
Y2_1_HmType0:
Y2_1_GantryHomeStep = 0
IF Y2_1_IsFlexibleGantry = 1 
	Y2_1_IsGantryComove = 1										!Flexible gantry should comove
END

DISABLE (Y2_1_axis,Y2_1_Yaw_axis)	
TILL ^MST(Y2_1_axis).#ENABLED & ^MST(Y2_1_Yaw_axis).#ENABLED	
WAIT 500 !500	
ERRORMAPOFF Y2_1_axis, -1	;	ERRORMAPOFF Y2_1_Yaw_axis, -1			! Close all Y2_1_axis & Y2_1_yaw_axis error compensation
MFLAGS(Y2_1_axis).#GANTRY = 0	;	MFLAGS(Y2_1_Yaw_axis).#GANTRY = 0	! turn off gantry mode (MFLAGS.25)
FDEF(Y2_1_axis).#SRL = 0	;	FDEF(Y2_1_Yaw_axis).#SRL = 0	 		! disable software right limit response
FDEF(Y2_1_axis).#SLL = 0	;	FDEF(Y2_1_Yaw_axis).#SLL = 0	 		! disable software left limit response

IF Y2_1_IsUsingGantryHmGain=1
	CALL HmGain
END
!-----------------------Enable_Master-----------------------------------!
ENABLE (Y2_1_axis)
TILL MST(Y2_1_axis).#ENABLED
WAIT 500 !500
DISABLE (Y2_1_axis)	
TILL ^MST(Y2_1_axis).#ENABLED 
WAIT 200 !500	

!-----------------------Enable_Slave-----------------------------------!
ENABLE (Y2_1_Yaw_axis)
TILL MST(Y2_1_Yaw_axis).#ENABLED
WAIT 500 !500
DISABLE (Y2_1_Yaw_axis)	
TILL ^MST(Y2_1_Yaw_axis).#ENABLED	
WAIT 200 !500	

MFLAGS(Y2_1_axis).#OPEN =0 ;	MFLAGS(Y2_1_Yaw_axis).#OPEN =0	 		! close loop control
FDEF(Y2_1_axis).#RL = 	0	;	FDEF(Y2_1_Yaw_axis).#RL =  0			! motor is not disable when left limit signal rising.

IF Y2_1_IsGantryComove = 1											! Comove
	ACC(Y2_1_Yaw_axis)=ACC(Y2_1_axis)									! Y2_1_axis & Y2_1_Yaw_axis should same motion profile
	DEC(Y2_1_Yaw_axis)=DEC(Y2_1_axis)	
	JERK(Y2_1_Yaw_axis)=JERK(Y2_1_axis)
	XCURI(Y2_1_Yaw_axis)=XCURI(Y2_1_axis)	
	XCURV(Y2_1_Yaw_axis)=XCURV(Y2_1_axis)	
	SLPKP(Y2_1_Yaw_axis)=SLPKP(Y2_1_axis)
	SLVKP(Y2_1_Yaw_axis)=SLVKP(Y2_1_axis)
	SLVKI(Y2_1_Yaw_axis)=SLVKI(Y2_1_axis)
	ENABLE (Y2_1_axis,Y2_1_Yaw_axis)
	TILL MST(Y2_1_axis).#ENABLED & MST(Y2_1_Yaw_axis).#ENABLED	
	JOG/WV (Y2_1_axis),Y2_1_HmVel ; JOG/WV (Y2_1_Yaw_axis),Y2_1_HmVel	
	GO (Y2_1_axis,Y2_1_Yaw_axis)										! Y2_1_axis & Y2_1_Yaw_axis move same time
	Y2_1_GantryHomeStep = 1										! Start find left limit *(should after GO to avoid unable to stop at left limit)
	IF Y2_1_IsFlexibleGantry = 1
		TILL FAULT(Y2_1_axis).#RL & FAULT(Y2_1_Yaw_axis).#RL
	ELSE
		TILL FAULT(Y2_1_axis).#RL
	END	
	HALT (Y2_1_axis,Y2_1_Yaw_axis)									! found left limit
	TILL ^MST(Y2_1_axis).#MOVE & ^MST(Y2_1_Yaw_axis).#MOVE	
ELSE															! drag one side
	ENABLE (Y2_1_axis)	
	TILL MST(Y2_1_axis).#ENABLED	
	JOG/V (Y2_1_axis),Y2_1_HmVel									
	TILL FAULT(Y2_1_axis).#RL
	HALT Y2_1_axis													! found left limit
	TILL ^MST(Y2_1_axis).#MOVE	
END

Y2_1_GantryHomeStep = 3
IST(Y2_1_axis).#IND = 1	;	IST(Y2_1_axis).#IND = 0				! reset the index signal
IST(Y2_1_Yaw_axis).#IND = 1	;	IST(Y2_1_Yaw_axis).#IND = 0	

IF Y2_1_IsGantryComove = 1
	JOG/WV (Y2_1_axis),-Y2_1_IndVel ; JOG/WV (Y2_1_Yaw_axis),-Y2_1_IndVel
	GO (Y2_1_axis,Y2_1_Yaw_axis)
ELSE
     TILL ^MST(Y2_1_axis).#MOVE
	JOG/V (Y2_1_axis),-Y2_1_IndVel
END

TILL IST(Y2_1_axis).#IND & IST(Y2_1_Yaw_axis).#IND	
HALT (Y2_1_axis,Y2_1_Yaw_axis)
TILL ^MST(Y2_1_axis).#MOVE & ^MST(Y2_1_Yaw_axis).#MOVE	
DISP"Already found the index!!"	
DISABLE (Y2_1_axis,Y2_1_Yaw_axis)
TILL ^MST(Y2_1_axis).#ENABLED & ^MST(Y2_1_Yaw_axis).#ENABLED
wait 3000
SET FPOS(Y2_1_axis)=FPOS(Y2_1_axis)-IND(Y2_1_axis)-Y2_1_HmOffset	
SET FPOS(Y2_1_Yaw_axis)=FPOS(Y2_1_Yaw_axis)-IND(Y2_1_Yaw_axis) - Y2_1_HmOffset	+ Y2_1_Yawlock
DISABLE (Y2_1_axis,Y2_1_Yaw_axis)	
TILL ^MST(Y2_1_axis).#ENABLED & ^MST(Y2_1_Yaw_axis).#ENABLED
MFLAGS(Y2_1_axis).#GANTRY = 1	;	MFLAGS(Y2_1_Yaw_axis).#GANTRY = 1	! turn on gantry mode
XCURI(Y2_1_axis) = Y2_1_M_XCURI	;	XCURI(Y2_1_Yaw_axis) = Y2_1_S_XCURI
XCURV(Y2_1_axis) = Y2_1_M_XCURV	;	XCURV(Y2_1_Yaw_axis) = Y2_1_S_XCURV

RET
STOP
!------------------------------------------------------------------Y2_1_HmType3--------------------------------------------------------------------------------------
Y2_1_HmType3:

RET	
STOP
!------------------------------------------------------------------Y2_1_HmType4--------------------------------------------------------------------------------------
Y2_1_HmType4:

RET	
STOP
!!****************************************************** Error Compensation Process ***************************************************!!
Y2_1_ErrorCompensation:
!---------- Y2_1_axis Error Compensation Table ------------!
Y2_1_ErrTable(0)=	0	;
Y2_1_ErrTable(1)=	-1.2	;
Y2_1_ErrTable(2)=	-10.2	;
Y2_1_ErrTable(3)=	-10.2	;
Y2_1_ErrTable(4)=	-9.1	;
Y2_1_ErrTable(5)=	-11.1	;
Y2_1_ErrTable(6)=	-1.7	;
Y2_1_ErrTable(7)=	-12.6	;
Y2_1_ErrTable(8)=	-6.1	;
Y2_1_ErrTable(9)=	11.1	;
Y2_1_ErrTable(10)=	16.7	;
Y2_1_ErrTable(11)=	18.3	;
Y2_1_ErrTable(12)=	-1.8	;
Y2_1_ErrTable(13)=	-0.1	;
Y2_1_ErrTable(14)=	2.4	;
Y2_1_ErrTable(15)=	-4.9	;
Y2_1_ErrTable(16)=	-4.3	;
Y2_1_ErrTable(17)=	0.5	;
Y2_1_ErrTable(18)=	14.3	;
Y2_1_ErrTable(19)=	4.9	;
Y2_1_ErrTable(20)=	-2.8	;




!-------------------------------------------------------!
Y2_1_ErrTableIndex = 0
WHILE Y2_1_ErrTableIndex < SIZEOF(Y2_1_ErrTable)
	Y2_1_ErrTable(Y2_1_ErrTableIndex) = -Y2_1_ErrTable(Y2_1_ErrTableIndex)
	Y2_1_ErrTableIndex = Y2_1_ErrTableIndex + 1
END
ERRORUNMAP Y2_1_axis, ZONE0
ERRORMAP1D Y2_1_axis, ZONE0, Y2_1_ErrCompIniPos, Y2_1_ErrCompensationSpacing, Y2_1_ErrTable
ERRORMAPON Y2_1_axis, ZONE0

WAIT 500	
DISP "Cmpensation Procces's completed!"

RET 
STOP

!!*************************************************************************************************************************************!!
!!********************************************************* Current Compensation ******************************************************!!
Y2_1_CurrentCompensation:
ENABLE Y2_1_axis
TILL MST(Y2_1_axis).#ENABLED & MST(Y2_1_Yaw_axis).#ENABLED 
PTP/EV Y2_1_axis,Y2_1_CurrentCompensationIniPos,Y2_1_HmVel
DISABLE Y2_1_axis
TILL ^MST(Y2_1_axis).#ENABLED & ^MST(Y2_1_Yaw_axis).#ENABLED 
MFLAGS(Y2_1_Yaw_axis).#OPEN = 1		
ENABLE Y2_1_axis
TILL MST(Y2_1_axis).#ENABLED & MST(Y2_1_Yaw_axis).#ENABLED 

PTP/EV Y2_1_axis,Y2_1_CurrentCompensationIniPos,Y2_1_HmVel
WAIT Y2_1_CurrentCompensationSettleTime
Y2_1_CurrentCompensationIndex = 0
!Move negative unfinished
DISP"Y error table search sequence in negative direction......"
WHILE Y2_1_CurrentCompensationIndex <= Y2_1_CurrentCompensationSegment
	DISP"Y FPOS=%f , Y Yaw Offset = %f ",FPOS(Y2_1_axis),FPOS(Y2_1_Yaw_axis)
	Y2_1_CurrentTableTemp(0)(Y2_1_CurrentCompensationIndex) = FPOS(Y2_1_Yaw_axis)
	IF Y2_1_CurrentCompensationIndex < Y2_1_CurrentCompensationSegment
		PTP/ERV Y2_1_axis,Y2_1_CurrentCompensationSpacing,Y2_1_HmVel		
		WAIT Y2_1_CurrentCompensationSettleTime
	END
	Y2_1_CurrentCompensationIndex = Y2_1_CurrentCompensationIndex + 1	
END

PTP/EV Y2_1_axis,Y2_1_CurrentCompensationIniPos + Y2_1_CurrentCompensationTravel,Y2_1_HmVel
WAIT Y2_1_CurrentCompensationSettleTime
Y2_1_CurrentCompensationIndex = Y2_1_CurrentCompensationSegment
!Move positive
DISP"Y error table search sequence in positive direction......"
WHILE Y2_1_CurrentCompensationIndex >= 0
	DISP"Y FPOS=%f , Y Yaw Offset = %f ",FPOS(Y2_1_axis),FPOS(Y2_1_Yaw_axis)
	Y2_1_CurrentTableTemp(1)(Y2_1_CurrentCompensationIndex) = FPOS(Y2_1_Yaw_axis)
	IF Y2_1_CurrentCompensationIndex > 0
		PTP/ERV Y2_1_axis,-Y2_1_CurrentCompensationSpacing,Y2_1_HmVel		
		WAIT Y2_1_CurrentCompensationSettleTime
	END
	Y2_1_CurrentCompensationIndex = Y2_1_CurrentCompensationIndex - 1	
END

Y2_1_CurrentCompensationIndex = 0
WHILE Y2_1_CurrentCompensationIndex <= Y2_1_CurrentCompensationSegment
	Y2_1_CurrentTable(Y2_1_CurrentCompensationIndex)	=	(Y2_1_CurrentTableTemp(0)(Y2_1_CurrentCompensationIndex) + Y2_1_CurrentTableTemp(1)(Y2_1_CurrentCompensationIndex))/2
	Y2_1_CurrentCompensationIndex = Y2_1_CurrentCompensationIndex + 1
END

WRITE Y2_1_CurrentTable,Y2_1_CurrentTable
WAIT 1500	
PTP/EV Y2_1_axis,Y2_1_CurrentCompensationIniPos,Y2_1_HmVel
WAIT 500	

Y2_1_TurnOnCurrentCompensation:
DISABLE Y2_1_axis
TILL ^MST(Y2_1_axis).#ENABLED & ^MST(Y2_1_Yaw_axis).#ENABLED
MFLAGS(Y2_1_Yaw_axis).#OPEN = 0
ENABLE (Y2_1_axis,Y2_1_Yaw_axis)
TILL MST(Y2_1_axis).#ENABLED & MST(Y2_1_Yaw_axis).#ENABLED
READ Y2_1_CurrentTable,Y2_1_CurrentTable
ERRORUNMAP Y2_1_Yaw_axis, ZONE0
ERRORMAP1D Y2_1_Yaw_axis, ZONE0, Y2_1_CurrentCompensationIniPos, Y2_1_CurrentCompensationSpacing, Y2_1_CurrentTable
ERRORMAPON Y2_1_Yaw_axis, ZONE0
DISP"Current compensaton completed!"
RET 
STOP
!!*************************************************************************************************************************************!!
!**************************************Gains for homing********************************************!
HmGain:

SLPKP(Y2_1_axis)= Y2_1_GantryHmM_SLPKP	
SLVKP(Y2_1_axis)= Y2_1_GantryHmM_SLVKP	
SLVKI(Y2_1_axis)= Y2_1_GantryHmM_SLVKI	

SLPKP(Y2_1_Yaw_axis)= Y2_1_GantryHmS_SLPKP	
SLVKP(Y2_1_Yaw_axis)= Y2_1_GantryHmS_SLVKP	
SLVKI(Y2_1_Yaw_axis)= Y2_1_GantryHmS_SLVKI	


RET	
STOP
!**************************************Gains for production*****************************************!
ProdGain:

SLPKP(Y2_1_axis)= Y2_1_GantryProdM_SLPKP	
SLVKP(Y2_1_axis)= Y2_1_GantryProdM_SLVKP	
SLVKI(Y2_1_axis)= Y2_1_GantryProdM_SLVKI	

SLPKP(Y2_1_Yaw_axis)= Y2_1_GantryProdS_SLPKP	
SLVKP(Y2_1_Yaw_axis)= Y2_1_GantryProdS_SLVKP	
SLVKI(Y2_1_Yaw_axis)= Y2_1_GantryProdS_SLVKI	

RET
STOP
!!*************************************************************************************************************************************!!


!!#############################################################################################################################

ON Y2_1_GantryHomeStep = 1 & Y2_1_IsFlexibleGantry = 1 & FAULT(Y2_1_axis).#LL
	HALT Y2_1_axis
RET

ON Y2_1_GantryHomeStep = 1 & Y2_1_IsFlexibleGantry = 1 & FAULT(Y2_1_Yaw_axis).#LL
	HALT Y2_1_Yaw_axis
RET

ON Y2_1_GantryHomeStep = 2 & Y2_1_IsFlexibleGantry = 1 & ^FAULT(Y2_1_axis).#LL
	HALT Y2_1_axis
RET

ON Y2_1_GantryHomeStep = 2 & Y2_1_IsFlexibleGantry = 1 & ^FAULT(Y2_1_Yaw_axis).#LL
	HALT Y2_1_Yaw_axis
RET


ON MFLAGS(Y2_1_axis).#HOME=1 & MFLAGS(Y2_1_Yaw_axis).#HOME=1 & TPOS(Y2_1_axis) < SLLIMIT(Y2_1_axis) 
	IF( FDEF(Y2_1_axis).#SLL=1 & FMASK(Y2_1_axis).#SLL=1 & ^(GMTYPE(Y2_1_axis)=5))
		KILL Y2_1_axis,5016	!Software Left Limit
		TPOS(Y2_1_axis)=FPOS(Y2_1_axis)
		DISP "TPOS(Y2_1_axis) < SLLIMIT(Y2_1_axis)"
	END
RET

ON MFLAGS(Y2_1_axis).#HOME=1 & MFLAGS(Y2_1_Yaw_axis).#HOME=1 & TPOS(Y2_1_axis) > SRLIMIT(Y2_1_axis) 
	IF(FDEF(Y2_1_axis).#SRL=1 & FMASK(Y2_1_axis).#SRL=1 & ^(GMTYPE(Y2_1_axis)=5))
		KILL Y2_1_axis,5015	!Software Right Limit
		TPOS(Y2_1_axis)=FPOS(Y2_1_axis)
		DISP "TPOS(Y2_1_axis) > SRLIMIT(Y2_1_axis)"
	END
RET

ON MFLAGS(Y2_1_axis).#HOME=1 & MFLAGS(Y2_1_Yaw_axis).#HOME=1 & TPOS(Y2_1_Yaw_axis) < SLLIMIT(Y2_1_Yaw_axis) 
	IF( FDEF(Y2_1_Yaw_axis).#SLL=1 & FMASK(Y2_1_Yaw_axis).#SLL=1 & ^(GMTYPE(Y2_1_Yaw_axis)=5))
		KILL Y2_1_Yaw_axis,5016	!Software Left Limit
		TPOS(Y2_1_Yaw_axis)=FPOS(Y2_1_Yaw_axis)
		DISP "TPOS(Y2_1_Yaw_axis) < SLLIMIT(Y2_1_Yaw_axis)"
	END
RET

ON MFLAGS(Y2_1_axis).#HOME=1 & MFLAGS(Y2_1_Yaw_axis).#HOME=1 & TPOS(Y2_1_Yaw_axis) > SRLIMIT(Y2_1_Yaw_axis) 
	IF(FDEF(Y2_1_Yaw_axis).#SRL=1 & FMASK(Y2_1_Yaw_axis).#SRL=1 & ^(GMTYPE(Y2_1_Yaw_axis)=5))
		KILL Y2_1_Yaw_axis,5015	!Software Right Limit
		TPOS(Y2_1_Yaw_axis)=FPOS(Y2_1_Yaw_axis)
		DISP "TPOS(Y2_1_Yaw_axis) > SRLIMIT(Y2_1_Yaw_axis)"
	END
RET



ON MFLAGS(Y2_1_axis).#HOME=0 & RVEL(Y2_1_axis) > XVEL(Y2_1_axis)*0.5 & ^MST(Y2_1_axis).#INPOS
	IMM VEL(Y2_1_axis) = XVEL(Y2_1_axis)*0.45 !?30
RET

ON MFLAGS(Y2_1_axis).#HOME=0 & RVEL(Y2_1_axis) < -XVEL(Y2_1_axis)*0.5 & ^MST(Y2_1_axis).#INPOS
	IMM VEL(Y2_1_axis) = -XVEL(Y2_1_axis)*0.45 !?30
RET

AUTOEXEC:
	MFLAGS(Y2_1_axis).#HOME=0;	MFLAGS(Y2_1_Yaw_axis).#HOME=0
STOP

#3
!PNAME=
!PDESC=
! Y2_2_axis Gantry Standard Homing Process
! Version 1.5 Beta
!!****** Setting Parameter ******!!
LOCAL REAL Y2_2_HmType,Y2_2_multi_indHm,Y2_2_multi_indVel
LOCAL REAL Y2_2_HmVel,Y2_2_IndVel,Y2_2_HmOffset	
LOCAL INT Y2_2_ErrCompensation,Y2_2_ErrCompensationSpacing,Y2_2_ErrCompIniPos
LOCAL INT Y2_2_CurrentCompensation,Y2_2_CurrentCompensationIndex,Y2_2_CurrentCompensationSettleTime
GLOBAL REAL Y2_2_CurrentTableTemp(2)(21)
LOCAL REAL Y2_2_CurrentCompensationTravel,Y2_2_CurrentCompensationSpacing,Y2_2_CurrentCompensationSegment,Y2_2_CurrentCompensationIniPos
LOCAL INT ZONE0,Y2_2_ErrTableIndex
LOCAL REAL Y2_2_GantryHmM_SLPKP,Y2_2_GantryHmM_SLVKP,Y2_2_GantryHmM_SLVKI,Y2_2_GantryHmS_SLPKP,Y2_2_GantryHmS_SLVKP,Y2_2_GantryHmS_SLVKI
LOCAL REAL Y2_2_GantryProdM_SLPKP,Y2_2_GantryProdM_SLVKP,Y2_2_GantryProdM_SLVKI,Y2_2_GantryProdS_SLPKP,Y2_2_GantryProdS_SLVKP,Y2_2_GantryProdS_SLVKI
LOCAL REAL Y2_2_M_XCURI,Y2_2_M_XCURV,Y2_2_S_XCURI,Y2_2_S_XCURV
LOCAL INT Y2_2_IsUsingGantryHmGain,Y2_2_IsFlexibleGantry,Y2_2_IsGantryComove,Y2_2_EtherCATIndex,Y2_2_GantryHomeStep
LOCAL REAL Y2_2_Yawlock
LOCAL REAL Y2_2_CommutCurrent,Y2_2_Yaw_CommutCurrent
!!################ Basic Settings ######################################################################################################
Y2_2_HmType = 0 								!the method of homing
           									!value 0 : Customized homing											
											!	   3 : this type is for gantry mode , and the motion for homing is same as Y2_2_HmType=1.
											!	   4 : this type is for gantry mode , and the motion for homing is same as Y2_2_HmType=2.
Y2_2_HmOffset = 0 								! Y2_2_HmOffset (unit)
Y2_2_HmVel = 20000								! the velocity for homing 	
Y2_2_IndVel = 10000 								! the velocity for finding index

Y2_2_multi_indHm=0								! multi index structure
											! value 0 : nomal Homing
											!	    1 : find the left limit in negative direction,then slowing leave the limit in positive direction,
											!			then slowing find the left limit in negative direction,then slowing find index in positive direction
Y2_2_multi_indVel = 100						! (Do not modify)homing velocity of multi index structure
Y2_2_CommutCurrent = 80						! Commutation excitation current.
Y2_2_Yaw_CommutCurrent = 80					! Yaw axis Commutation excitation current.
!!*********************************** Y2_2_axis Gantry mod ***************************************************!!
Y2_2_IsFlexibleGantry = 0 						! 0: Stiff Gantry ; 1: Flexible Gantry (Y2_2_IsGantryComove automatically set to 1 )
Y2_2_IsGantryComove = 0						! 0: Search limit and index by Y2_2_axis
											! 1: Search limit and index by Y2_2_axis and Y2_2_Yaw_axis comove
Y2_2_Yawlock = -457							! Y2_2_Yaw_axis follow position
Y2_2_M_XCURI = 40								! Y2_2_axis XCURI
Y2_2_M_XCURV = 95								! Y2_2_axis XCURV
Y2_2_S_XCURI = 10								! Y2_2_Yaw_axis XCURI
Y2_2_S_XCURV = 10								! Y2_2_Yaw_axis XCURV

Y2_2_IsUsingGantryHmGain = 1					! 0 : Homing and production using same gain 
											    ! 1 : Homing and production using different gain 
!------------------Homing and production gain set (Set by Y2_2_IsUsingGantryHmGain = 1)-----------------!
Y2_2_GantryHmM_SLPKP = 10						! Y2_2_axis homing gain
Y2_2_GantryHmM_SLVKP = 70		
Y2_2_GantryHmM_SLVKI = 50
Y2_2_GantryHmS_SLPKP = 0						! Y2_2_Yaw_axis homing gain
Y2_2_GantryHmS_SLVKP = 40
Y2_2_GantryHmS_SLVKI = 40
Y2_2_GantryProdM_SLPKP = 100					! Y2_2_axis production gain
Y2_2_GantryProdM_SLVKP = 150
Y2_2_GantryProdM_SLVKI = 150
Y2_2_GantryProdS_SLPKP = 60						! Y2_2_Yaw_axis production gain
Y2_2_GantryProdS_SLVKP = 60
Y2_2_GantryProdS_SLVKI = 120
!!**************** Configuration of 1D Error Compensation*****************************************************!!
Y2_2_ErrCompensation = 1						! 0 : without compensation  ; 1 : turn on the compensation after homing completed 
Y2_2_ErrCompIniPos = -1900000							! the initial position of error compensation
Y2_2_ErrCompensationSpacing = 95000				! setting the spacing for error compensation 
!!**************** Configuration of Current Compensation for gantry mode ***************************************!!
Y2_2_CurrentCompensation = 1  				! Current Compensation
											! the value 0 : without current compensation.
											!           1 : Enable current compensation mode with exist current table. 
											!           2 : Execute the process of current table search after homing , and then 
											!               enable current compensation mode.
Y2_2_CurrentCompensationIniPos = -1900000				! compensation start postion
Y2_2_CurrentCompensationTravel = 1900000		! the stroke (unit) of CurrentCompensation
Y2_2_CurrentCompensationSegment = 10			! the segment for current compensation.
Y2_2_CurrentCompensationSettleTime = 5000		! time requiered for Yaw axis to take satisfactory position
Y2_2_CurrentCompensationSpacing = Y2_2_CurrentCompensationTravel / Y2_2_CurrentCompensationSegment	 ! the spacing for current compensation (unit)
!!**********************************************************************************************************!!
!!######################################################################################################################################## 

!!**************************************************************************************************************************************!!
!!************************************************************ Main program ************************************************************!!

IF Y2_2_HmType=0	
	MFLAGS(Y2_2_axis).#HOME=0;	MFLAGS(Y2_2_Yaw_axis).#HOME=0 												! Customized homing
	CALL Y2_2_HmType0
ELSEIF Y2_2_HmType>=3 & Y2_2_HmType<=4 			! Gantry Homing	
	MFLAGS(Y2_2_axis).#HOME=0;	MFLAGS(Y2_2_Yaw_axis).#HOME=0  !2023.10.24 mark
	IF Y2_2_HmType=3
		CALL Y2_2_HmType3
	ELSEIF Y2_2_HmType=4
		CALL Y2_2_HmType4
	END
ELSE
	DISP"ERROR:The value of Y2_2_HmType or Y2_2_HiwinDriveHome is invalid!!"
	STOP
END

IF (Y2_2_CurrentCompensation=1 & (Y2_2_HmType>=3|Y2_2_HmType=0))
	DISP"Turn on the Current Compensation..."	
	CALL Y2_2_TurnOnCurrentCompensation	
ELSEIF (Y2_2_CurrentCompensation=2 &  (Y2_2_HmType>=3|Y2_2_HmType=0))
	CALL Y2_2_CurrentCompensation	
ELSEIF (Y2_2_CurrentCompensation=0 &  (Y2_2_HmType>=3|Y2_2_HmType=0))	
	ERRORUNMAP Y2_2_Yaw_axis, ZONE0
END

IF Y2_2_ErrCompensation = 1
	DISP "Enable the compensation mode."
	DISP "Execute the compensation prcoess......"
	CALL Y2_2_ErrorCompensation	
ELSE
	DISP "Disable error compensation."
	ERRORUNMAP Y2_2_axis, ZONE0
END 

IF (Y2_2_HmType>=3&Y2_2_HmType<=4)|Y2_2_HmType=0
	ENABLE (Y2_2_axis)	
	TILL MST(Y2_2_axis).#ENABLED & MST(Y2_2_Yaw_axis).#ENABLED
	WAIT 500
	DISP"Go home......"	
	PTP/EV Y2_2_axis,0,Y2_2_HmVel		
	PTP/EV Y2_2_Yaw_axis,0,Y2_2_HmVel !Yaw lock s
	MFLAGS(Y2_2_axis).#HOME=1;	MFLAGS(Y2_2_Yaw_axis).#HOME=1	
END	
FDEF(Y2_2_axis).#RL = 	1	;	FDEF(Y2_2_Yaw_axis).#RL =  1			! turn on the response of reaching right limit
FDEF(Y2_2_axis).#SRL = 1	;	FDEF(Y2_2_Yaw_axis).#SRL = 1	 		! enable software right limit response
FDEF(Y2_2_axis).#SLL = 1	;	FDEF(Y2_2_Yaw_axis).#SLL = 1	 		! enable software left limit response
FDEF(Y2_1_axis).#LL = 	1	;	FDEF(Y2_1_Yaw_axis).#LL =  1
IF Y2_2_IsUsingGantryHmGain=1
	CALL ProdGain
END
DISP"Homing successful!!"	


STOP	

!!*************************************************************************************************************************************!!
!!************************************************************ Homing process	*******************************************************!!
Y2_2_HmType0:
!Customized
Y2_2_GantryHomeStep = 0
IF Y2_2_IsFlexibleGantry = 1 
	Y2_2_IsGantryComove = 1										!Flexible gantry should comove
END

DISABLE (Y2_2_axis,Y2_2_Yaw_axis)	
TILL ^MST(Y2_2_axis).#ENABLED & ^MST(Y2_2_Yaw_axis).#ENABLED	
WAIT 500	
ERRORMAPOFF Y2_2_axis, -1	;	ERRORMAPOFF Y2_2_Yaw_axis, -1			! Close all Y2_2_axis & Y2_2_yaw_axis error compensation
MFLAGS(Y2_2_axis).#GANTRY = 0	;	MFLAGS(Y2_2_Yaw_axis).#GANTRY = 0	! turn off gantry mode (MFLAGS.25)
FDEF(Y2_2_axis).#SRL = 0	;	FDEF(Y2_2_Yaw_axis).#SRL = 0	 		! disable software right limit response
FDEF(Y2_2_axis).#SLL = 0	;	FDEF(Y2_2_Yaw_axis).#SLL = 0	 		! disable software left limit response


IF Y2_2_IsUsingGantryHmGain=1
	CALL HmGain
END
!-----------------------Enable_Master-----------------------------------!
ENABLE (Y2_2_axis)
TILL MST(Y2_2_axis).#ENABLED
WAIT 500
DISABLE (Y2_2_axis)	
TILL ^MST(Y2_2_axis).#ENABLED 
WAIT 200	!500

!-----------------------Enable_Slave-----------------------------------!
ENABLE (Y2_2_Yaw_axis)
TILL MST(Y2_2_Yaw_axis).#ENABLED
WAIT 500
DISABLE (Y2_2_Yaw_axis)	
TILL ^MST(Y2_2_Yaw_axis).#ENABLED	
WAIT 200	!500

MFLAGS(Y2_2_axis).#OPEN =0 ;	MFLAGS(Y2_2_Yaw_axis).#OPEN =0	 		! close loop control
FDEF(Y2_2_axis).#RL = 	0	;	FDEF(Y2_2_Yaw_axis).#RL =  0			! motor is not disable when right limit signal rising.
FDEF(Y2_1_axis).#LL = 	0	;	FDEF(Y2_1_Yaw_axis).#LL =  0			! motor is not disable when right limit signal rising.


IF Y2_2_IsGantryComove = 1											! Comove
	ACC(Y2_2_Yaw_axis)=ACC(Y2_2_axis)									! Y2_2_axis & Y2_2_Yaw_axis should same motion profile
	DEC(Y2_2_Yaw_axis)=DEC(Y2_2_axis)	
	JERK(Y2_2_Yaw_axis)=JERK(Y2_2_axis)
	XCURI(Y2_2_Yaw_axis)=XCURI(Y2_2_axis)	
	XCURV(Y2_2_Yaw_axis)=XCURV(Y2_2_axis)	
	SLPKP(Y2_2_Yaw_axis)=SLPKP(Y2_2_axis)
	SLVKP(Y2_2_Yaw_axis)=SLVKP(Y2_2_axis)
	SLVKI(Y2_2_Yaw_axis)=SLVKI(Y2_2_axis)
	ENABLE (Y2_2_axis,Y2_2_Yaw_axis)
	TILL MST(Y2_2_axis).#ENABLED & MST(Y2_2_Yaw_axis).#ENABLED	
	JOG/WV (Y2_2_axis),Y2_2_HmVel ; JOG/WV (Y2_2_Yaw_axis),Y2_2_HmVel	
	GO (Y2_2_axis,Y2_2_Yaw_axis)										! Y2_2_axis & Y2_2_Yaw_axis move same time
	Y2_2_GantryHomeStep = 1												! Start find Right limit *(should after GO to avoid unable to stop at right limit)
	IF Y2_2_IsFlexibleGantry = 1
		TILL FAULT(Y2_2_axis).#RL & FAULT(Y2_2_Yaw_axis).#RL
	ELSE
		TILL FAULT(Y2_2_axis).#RL
	END	
	HALT (Y2_2_axis,Y2_2_Yaw_axis)									! found right limit
	TILL ^MST(Y2_2_axis).#MOVE & ^MST(Y2_2_Yaw_axis).#MOVE	
ELSE															! drag one side
	ENABLE (Y2_2_axis)	
	TILL MST(Y2_2_axis).#ENABLED	
	JOG/V (Y2_2_axis),Y2_2_HmVel									
	TILL FAULT(Y2_2_axis).#RL
	HALT Y2_2_axis													! found right limit
	TILL ^MST(Y2_2_axis).#MOVE	
END

Y2_2_GantryHomeStep = 3
IST(Y2_2_axis).#IND = 1	;	IST(Y2_2_axis).#IND = 0				! reset the index signal
IST(Y2_2_Yaw_axis).#IND = 1	;	IST(Y2_2_Yaw_axis).#IND = 0	

IF Y2_2_IsGantryComove = 1
	JOG/WV (Y2_2_axis),-Y2_2_IndVel ; JOG/WV (Y2_2_Yaw_axis),-Y2_2_IndVel
	GO (Y2_2_axis,Y2_2_Yaw_axis)
ELSE
	JOG/V (Y2_2_axis),-Y2_2_IndVel
END

TILL IST(Y2_2_axis).#IND & IST(Y2_2_Yaw_axis).#IND	
HALT (Y2_2_axis,Y2_2_Yaw_axis)
TILL ^MST(Y2_2_axis).#MOVE & ^MST(Y2_2_Yaw_axis).#MOVE	
DISP"Already found the index!!"	
DISABLE (Y2_2_axis,Y2_2_Yaw_axis)
TILL ^MST(Y2_2_axis).#ENABLED & ^MST(Y2_2_Yaw_axis).#ENABLED
wait 3000
SET FPOS(Y2_2_axis)=FPOS(Y2_2_axis)-IND(Y2_2_axis)-Y2_2_HmOffset	
SET FPOS(Y2_2_Yaw_axis)=FPOS(Y2_2_Yaw_axis)-IND(Y2_2_Yaw_axis) - Y2_2_HmOffset	+ Y2_2_Yawlock
DISABLE (Y2_2_axis,Y2_2_Yaw_axis)	
TILL ^MST(Y2_2_axis).#ENABLED & ^MST(Y2_2_Yaw_axis).#ENABLED
MFLAGS(Y2_2_axis).#GANTRY = 1	;	MFLAGS(Y2_2_Yaw_axis).#GANTRY = 1	! turn on gantry mode
XCURI(Y2_2_axis) = Y2_2_M_XCURI	;	XCURI(Y2_2_Yaw_axis) = Y2_2_S_XCURI
XCURV(Y2_2_axis) = Y2_2_M_XCURV	;	XCURV(Y2_2_Yaw_axis) = Y2_2_S_XCURV
RET
STOP
!------------------------------------------------------------------Y2_2_HmType3--------------------------------------------------------------------------------------
Y2_2_HmType3:

RET	
STOP
!------------------------------------------------------------------Y2_2_HmType4--------------------------------------------------------------------------------------
Y2_2_HmType4:

RET	
STOP
!!****************************************************** Error Compensation Process ***************************************************!!
Y2_2_ErrorCompensation:
!---------- Y2_2_axis Error Compensation Table ------------!
Y2_2_ErrTable(0)=	0	;
Y2_2_ErrTable(1)=	15	;
Y2_2_ErrTable(2)=	34.8	;
Y2_2_ErrTable(3)=	32.5	;
Y2_2_ErrTable(4)=	23.3	;
Y2_2_ErrTable(5)=	18.9	;
Y2_2_ErrTable(6)=	18.2	;
Y2_2_ErrTable(7)=	18.8	;
Y2_2_ErrTable(8)=	26	;
Y2_2_ErrTable(9)=	21.6	;
Y2_2_ErrTable(10)=	21.9	;
Y2_2_ErrTable(11)=	38.9	;
Y2_2_ErrTable(12)=	38.8	;
Y2_2_ErrTable(13)=	32.8	;
Y2_2_ErrTable(14)=	25.8	;
Y2_2_ErrTable(15)=	28.9	;
Y2_2_ErrTable(16)=	37.7	;
Y2_2_ErrTable(17)=	27.1	;
Y2_2_ErrTable(18)=	28.3	;
Y2_2_ErrTable(19)=	48.5	;
Y2_2_ErrTable(20)=	63.3	;



!-------------------------------------------------------!
Y2_2_ErrTableIndex = 0
WHILE Y2_2_ErrTableIndex < SIZEOF(Y2_2_ErrTable)
	Y2_2_ErrTable(Y2_2_ErrTableIndex) = -Y2_2_ErrTable(Y2_2_ErrTableIndex)
	Y2_2_ErrTableIndex = Y2_2_ErrTableIndex + 1
END
ERRORUNMAP Y2_2_axis, ZONE0
ERRORMAP1D Y2_2_axis, ZONE0, Y2_2_ErrCompIniPos, Y2_2_ErrCompensationSpacing, Y2_2_ErrTable
ERRORMAPON Y2_2_axis, ZONE0

WAIT 500	
DISP "Cmpensation Procces's completed!"

RET 
STOP

!!*************************************************************************************************************************************!!
!!********************************************************* Current Compensation ******************************************************!!
Y2_2_CurrentCompensation:
ENABLE Y2_2_axis
TILL MST(Y2_2_axis).#ENABLED & MST(Y2_2_Yaw_axis).#ENABLED 
PTP/EV Y2_2_axis,Y2_2_CurrentCompensationIniPos,Y2_2_HmVel
DISABLE Y2_2_axis
TILL ^MST(Y2_2_axis).#ENABLED & ^MST(Y2_2_Yaw_axis).#ENABLED 
MFLAGS(Y2_2_Yaw_axis).#OPEN = 1		
ENABLE Y2_2_axis
TILL MST(Y2_2_axis).#ENABLED & MST(Y2_2_Yaw_axis).#ENABLED 

PTP/EV Y2_2_axis,Y2_2_CurrentCompensationIniPos,Y2_2_HmVel
WAIT Y2_2_CurrentCompensationSettleTime
Y2_2_CurrentCompensationIndex = 0
!Move positive
DISP"Y error table search sequence in positive direction......"
WHILE Y2_2_CurrentCompensationIndex <= Y2_2_CurrentCompensationSegment
	DISP"Y FPOS=%f , Y Yaw Offset = %f ",FPOS(Y2_2_axis),FPOS(Y2_2_Yaw_axis)
	Y2_2_CurrentTableTemp(0)(Y2_2_CurrentCompensationIndex) = FPOS(Y2_2_Yaw_axis)
	IF Y2_2_CurrentCompensationIndex < Y2_2_CurrentCompensationSegment
		PTP/ERV Y2_2_axis,Y2_2_CurrentCompensationSpacing,Y2_2_HmVel		
		WAIT Y2_2_CurrentCompensationSettleTime
	END
	Y2_2_CurrentCompensationIndex = Y2_2_CurrentCompensationIndex + 1	
END

PTP/EV Y2_2_axis,Y2_2_CurrentCompensationIniPos + Y2_2_CurrentCompensationTravel,Y2_2_HmVel
WAIT Y2_2_CurrentCompensationSettleTime
Y2_2_CurrentCompensationIndex = Y2_2_CurrentCompensationSegment
!Move negative unfinished
DISP"Y error table search sequence in negative direction......"
WHILE Y2_2_CurrentCompensationIndex >= 0
	DISP"Y FPOS=%f , Y Yaw Offset = %f ",FPOS(Y2_2_axis),FPOS(Y2_2_Yaw_axis)
	Y2_2_CurrentTableTemp(1)(Y2_2_CurrentCompensationIndex) = FPOS(Y2_2_Yaw_axis)
	IF Y2_2_CurrentCompensationIndex > 0
		PTP/ERV Y2_2_axis,-Y2_2_CurrentCompensationSpacing,Y2_2_HmVel		
		WAIT Y2_2_CurrentCompensationSettleTime
	END
	Y2_2_CurrentCompensationIndex = Y2_2_CurrentCompensationIndex - 1	
END

Y2_2_CurrentCompensationIndex = 0
WHILE Y2_2_CurrentCompensationIndex <= Y2_2_CurrentCompensationSegment
	Y2_2_CurrentTable(Y2_2_CurrentCompensationIndex)	=	(Y2_2_CurrentTableTemp(0)(Y2_2_CurrentCompensationIndex) + Y2_2_CurrentTableTemp(1)(Y2_2_CurrentCompensationIndex))/2
	Y2_2_CurrentCompensationIndex = Y2_2_CurrentCompensationIndex + 1
END

WRITE Y2_2_CurrentTable,Y2_2_CurrentTable
WAIT 1500	
PTP/EV Y2_2_axis,Y2_2_CurrentCompensationIniPos,Y2_2_HmVel
WAIT 500	

Y2_2_TurnOnCurrentCompensation:
DISABLE Y2_2_axis
TILL ^MST(Y2_2_axis).#ENABLED & ^MST(Y2_2_Yaw_axis).#ENABLED
MFLAGS(Y2_2_Yaw_axis).#OPEN = 0
ENABLE (Y2_2_axis,Y2_2_Yaw_axis)
TILL MST(Y2_2_axis).#ENABLED & MST(Y2_2_Yaw_axis).#ENABLED
READ Y2_2_CurrentTable,Y2_2_CurrentTable
ERRORUNMAP Y2_2_Yaw_axis, ZONE0
ERRORMAP1D Y2_2_Yaw_axis, ZONE0, Y2_2_CurrentCompensationIniPos, Y2_2_CurrentCompensationSpacing, Y2_2_CurrentTable
ERRORMAPON Y2_2_Yaw_axis, ZONE0
DISP"Current compensaton completed!"
RET 
STOP
!!*************************************************************************************************************************************!!
!**************************************Gains for homing********************************************!
HmGain:

SLPKP(Y2_2_axis)= Y2_2_GantryHmM_SLPKP	
SLVKP(Y2_2_axis)= Y2_2_GantryHmM_SLVKP	
SLVKI(Y2_2_axis)= Y2_2_GantryHmM_SLVKI	

SLPKP(Y2_2_Yaw_axis)= Y2_2_GantryHmS_SLPKP	
SLVKP(Y2_2_Yaw_axis)= Y2_2_GantryHmS_SLVKP	
SLVKI(Y2_2_Yaw_axis)= Y2_2_GantryHmS_SLVKI	


RET	
STOP
!**************************************Gains for production*****************************************!
ProdGain:

SLPKP(Y2_2_axis)= Y2_2_GantryProdM_SLPKP	
SLVKP(Y2_2_axis)= Y2_2_GantryProdM_SLVKP	
SLVKI(Y2_2_axis)= Y2_2_GantryProdM_SLVKI	

SLPKP(Y2_2_Yaw_axis)= Y2_2_GantryProdS_SLPKP	
SLVKP(Y2_2_Yaw_axis)= Y2_2_GantryProdS_SLVKP	
SLVKI(Y2_2_Yaw_axis)= Y2_2_GantryProdS_SLVKI	

RET
STOP
!!*************************************************************************************************************************************!!


!!#############################################################################################################################

ON Y2_2_GantryHomeStep = 1 & Y2_2_IsFlexibleGantry = 1 & FAULT(Y2_2_axis).#LL
	HALT Y2_2_axis
RET

ON Y2_2_GantryHomeStep = 1 & Y2_2_IsFlexibleGantry = 1 & FAULT(Y2_2_Yaw_axis).#LL
	HALT Y2_2_Yaw_axis
RET

ON Y2_2_GantryHomeStep = 2 & Y2_2_IsFlexibleGantry = 1 & ^FAULT(Y2_2_axis).#LL
	HALT Y2_2_axis
RET

ON Y2_2_GantryHomeStep = 2 & Y2_2_IsFlexibleGantry = 1 & ^FAULT(Y2_2_Yaw_axis).#LL
	HALT Y2_2_Yaw_axis
RET


ON MFLAGS(Y2_2_axis).#HOME=1 & MFLAGS(Y2_2_Yaw_axis).#HOME=1 &TPOS(Y2_2_axis) < SLLIMIT(Y2_2_axis) 
	IF( FDEF(Y2_2_axis).#SLL=1 & FMASK(Y2_2_axis).#SLL=1 & ^(GMTYPE(Y2_2_axis)=5))
		KILL Y2_2_axis,5016	!Software Left Limit
		TPOS(Y2_2_axis)=FPOS(Y2_2_axis)
		DISP "TPOS(Y2_2_axis) < SLLIMIT(Y2_2_axis)"
	END
RET

ON MFLAGS(Y2_2_axis).#HOME=1 & MFLAGS(Y2_2_Yaw_axis).#HOME=1 &TPOS(Y2_2_axis) > SRLIMIT(Y2_2_axis) 
	IF(FDEF(Y2_2_axis).#SRL=1 & FMASK(Y2_2_axis).#SRL=1 & ^(GMTYPE(Y2_2_axis)=5))
		KILL Y2_2_axis,5015	!Software Right Limit
		TPOS(Y2_2_axis)=FPOS(Y2_2_axis)
		DISP "TPOS(Y2_2_axis) > SRLIMIT(Y2_2_axis)"
	END
RET

ON MFLAGS(Y2_2_axis).#HOME=1 & MFLAGS(Y2_2_Yaw_axis).#HOME=1 &TPOS(Y2_2_Yaw_axis) < SLLIMIT(Y2_2_Yaw_axis) 
	IF( FDEF(Y2_2_Yaw_axis).#SLL=1 & FMASK(Y2_2_Yaw_axis).#SLL=1 & ^(GMTYPE(Y2_2_Yaw_axis)=5))
		KILL Y2_2_Yaw_axis,5016	!Software Left Limit
		TPOS(Y2_2_Yaw_axis)=FPOS(Y2_2_Yaw_axis)
		DISP "TPOS(Y2_2_Yaw_axis) < SLLIMIT(Y2_2_Yaw_axis)"
	END
RET

ON MFLAGS(Y2_2_axis).#HOME=1 & MFLAGS(Y2_2_Yaw_axis).#HOME=1 & TPOS(Y2_2_Yaw_axis) > SRLIMIT(Y2_2_Yaw_axis) 
	IF(FDEF(Y2_2_Yaw_axis).#SRL=1 & FMASK(Y2_2_Yaw_axis).#SRL=1 & ^(GMTYPE(Y2_2_Yaw_axis)=5))
		KILL Y2_2_Yaw_axis,5015	!Software Right Limit
		TPOS(Y2_2_Yaw_axis)=FPOS(Y2_2_Yaw_axis)
		DISP "TPOS(Y2_2_Yaw_axis) > SRLIMIT(Y2_2_Yaw_axis)"
	END
RET



ON MFLAGS(Y2_2_axis).#HOME=0 & RVEL(Y2_2_axis) > XVEL(Y2_2_axis)*0.5 & ^MST(Y2_2_axis).#INPOS
	IMM VEL(Y2_2_axis) = XVEL(Y2_2_axis)*0.45 !?30
RET

ON MFLAGS(Y2_2_axis).#HOME=0 & RVEL(Y2_2_axis) < -XVEL(Y2_2_axis)*0.5 & ^MST(Y2_2_axis).#INPOS
	IMM VEL(Y2_2_axis) = -XVEL(Y2_2_axis)*0.45 !?30
RET

AUTOEXEC:
	MFLAGS(Y2_2_axis).#HOME=0;	MFLAGS(Y2_2_Yaw_axis).#HOME=0
STOP

#4
!PNAME=
!PDESC=
! Y2_3_axis Gantry Standard Homing Process
! Version 1.5 Beta
!!****** Setting Parameter ******!!
LOCAL REAL Y2_3_HmType,Y2_3_multi_indHm,Y2_3_multi_indVel
LOCAL REAL Y2_3_HmVel,Y2_3_IndVel,Y2_3_HmOffset	
LOCAL INT Y2_3_ErrCompensation,Y2_3_ErrCompensationSpacing,Y2_3_ErrCompIniPos
LOCAL INT Y2_3_CurrentCompensation,Y2_3_CurrentCompensationIndex,Y2_3_CurrentCompensationSettleTime
GLOBAL REAL Y2_3_CurrentTableTemp(2)(21)
LOCAL REAL Y2_3_CurrentCompensationTravel,Y2_3_CurrentCompensationSpacing,Y2_3_CurrentCompensationSegment,Y2_3_CurrentCompensationIniPos
LOCAL INT ZONE0,Y2_3_ErrTableIndex
LOCAL REAL Y2_3_GantryHmM_SLPKP,Y2_3_GantryHmM_SLVKP,Y2_3_GantryHmM_SLVKI,Y2_3_GantryHmS_SLPKP,Y2_3_GantryHmS_SLVKP,Y2_3_GantryHmS_SLVKI
LOCAL REAL Y2_3_GantryProdM_SLPKP,Y2_3_GantryProdM_SLVKP,Y2_3_GantryProdM_SLVKI,Y2_3_GantryProdS_SLPKP,Y2_3_GantryProdS_SLVKP,Y2_3_GantryProdS_SLVKI
LOCAL REAL Y2_3_M_XCURI,Y2_3_M_XCURV,Y2_3_S_XCURI,Y2_3_S_XCURV
LOCAL INT Y2_3_IsUsingGantryHmGain,Y2_3_IsFlexibleGantry,Y2_3_IsGantryComove,Y2_3_EtherCATIndex,Y2_3_GantryHomeStep
LOCAL REAL Y2_3_Yawlock
LOCAL REAL Y2_3_CommutCurrent,Y2_3_Yaw_CommutCurrent
!!################ Basic Settings ######################################################################################################
Y2_3_HmType = 3 								!the method of homing
           									!value 0 : Customized homing											
											!	   3 : this type is for gantry mode , and the motion for homing is same as Y2_3_HmType=1.
											!	   4 : this type is for gantry mode , and the motion for homing is same as Y2_3_HmType=2.
Y2_3_HmOffset = 0 								! Y2_3_HmOffset (unit)
Y2_3_HmVel = 20000								! the velocity for homing 	
Y2_3_IndVel = 10000 								! the velocity for finding index

Y2_3_multi_indHm=0								! multi index structure
											! value 0 : nomal Homing
											!	    1 : find the left limit in negative direction,then slowing leave the limit in positive direction,
											!			then slowing find the left limit in negative direction,then slowing find index in positive direction
Y2_3_multi_indVel = 100						! (Do not modify)homing velocity of multi index structure
Y2_3_CommutCurrent = 80						! Commutation excitation current.
Y2_3_Yaw_CommutCurrent = 80					! Yaw axis Commutation excitation current.
!!*********************************** Y2_3_axis Gantry mod ***************************************************!!
Y2_3_IsFlexibleGantry = 0 						! 0: Stiff Gantry ; 1: Flexible Gantry (Y2_3_IsGantryComove automatically set to 1 )
Y2_3_IsGantryComove = 0						! 0: Search limit and index by Y2_3_axis
											! 1: Search limit and index by Y2_3_axis and Y2_3_Yaw_axis comove
Y2_3_Yawlock = 34							! Y2_3_Yaw_axis follow position
Y2_3_M_XCURI = 40								! Y2_3_axis XCURI
Y2_3_M_XCURV = 90								! Y2_3_axis XCURV
Y2_3_S_XCURI = 10								! Y2_3_Yaw_axis XCURI
Y2_3_S_XCURV = 10								! Y2_3_Yaw_axis XCURV

Y2_3_IsUsingGantryHmGain = 1					! 0 : Homing and production using same gain 
											    ! 1 : Homing and production using different gain 
!------------------Homing and production gain set (Set by Y2_3_IsUsingGantryHmGain = 1)-----------------!
Y2_3_GantryHmM_SLPKP = 10						! Y2_3_axis homing gain
Y2_3_GantryHmM_SLVKP = 50		
Y2_3_GantryHmM_SLVKI = 50
Y2_3_GantryHmS_SLPKP = 0						! Y2_3_Yaw_axis homing gain
Y2_3_GantryHmS_SLVKP = 40
Y2_3_GantryHmS_SLVKI = 40
Y2_3_GantryProdM_SLPKP = 140					! Y2_3_axis production gain
Y2_3_GantryProdM_SLVKP = 80
Y2_3_GantryProdM_SLVKI = 150
Y2_3_GantryProdS_SLPKP = 40						! Y2_3_Yaw_axis production gain
Y2_3_GantryProdS_SLVKP = 30
Y2_3_GantryProdS_SLVKI = 120
!!**************** Configuration of 1D Error Compensation*****************************************************!!
Y2_3_ErrCompensation = 1						! 0 : without compensation  ; 1 : turn on the compensation after homing completed 
Y2_3_ErrCompIniPos = 0							! the initial position of error compensation
Y2_3_ErrCompensationSpacing = 95000				! setting the spacing for error compensation 
!!**************** Configuration of Current Compensation for gantry mode ***************************************!!
Y2_3_CurrentCompensation = 1    				! Current Compensation
											! the value 0 : without current compensation.
											!           1 : Enable current compensation mode with exist current table. 
											!           2 : Execute the process of current table search after homing , and then 
											!               enable current compensation mode.
Y2_3_CurrentCompensationIniPos = 0				! compensation start postion
Y2_3_CurrentCompensationTravel = 1900000			! the stroke (unit) of CurrentCompensation
Y2_3_CurrentCompensationSegment = 10			! the segment for current compensation.
Y2_3_CurrentCompensationSettleTime = 5000		! time requiered for Yaw axis to take satisfactory position
Y2_3_CurrentCompensationSpacing = Y2_3_CurrentCompensationTravel / Y2_3_CurrentCompensationSegment	 ! the spacing for current compensation (unit)
!!**********************************************************************************************************!!
!!######################################################################################################################################## 

!!**************************************************************************************************************************************!!
!!************************************************************ Main program ************************************************************!!
IF Y2_3_HmType=0													! Customized homing
	MFLAGS(Y2_3_axis).#HOME=0;	MFLAGS(Y2_3_Yaw_axis).#HOME=0
	CALL Y2_3_HmType0
ELSEIF Y2_3_HmType>=3 & Y2_3_HmType<=4 			! Gantry Homing	
	MFLAGS(Y2_3_axis).#HOME=0;	MFLAGS(Y2_3_Yaw_axis).#HOME=0
	IF Y2_3_HmType=3
		CALL Y2_3_HmType3
	ELSEIF Y2_3_HmType=4
		CALL Y2_3_HmType4
	END
ELSE
	DISP"ERROR:The value of Y2_3_HmType or Y2_3_HiwinDriveHome is invalid!!"
	STOP
END

IF (Y2_3_CurrentCompensation=1 & Y2_3_HmType>=3)
	DISP"Turn on the Current Compensation..."	
	CALL Y2_3_TurnOnCurrentCompensation	
ELSEIF (Y2_3_CurrentCompensation=2 &  Y2_3_HmType>=3)
	CALL Y2_3_CurrentCompensation	
ELSEIF (Y2_3_CurrentCompensation=0 &  Y2_3_HmType>=3)	
	ERRORUNMAP Y2_3_Yaw_axis, ZONE0
END

IF Y2_3_ErrCompensation = 1
	DISP "Enable the compensation mode."
	DISP "Execute the compensation prcoess......"
	CALL Y2_3_ErrorCompensation	
ELSE
	DISP "Disable error compensation."
	ERRORUNMAP Y2_3_axis, ZONE0
END 

IF (Y2_3_HmType>=3&Y2_3_HmType<=4)
	ENABLE (Y2_3_axis)	
	TILL MST(Y2_3_axis).#ENABLED & MST(Y2_3_Yaw_axis).#ENABLED
	WAIT 500
	DISP"Go home......"	
	PTP/EV Y2_3_axis,0,Y2_3_HmVel		
	PTP/EV Y2_3_Yaw_axis,0,Y2_3_HmVel !Yaw lock s
	MFLAGS(Y2_3_axis).#HOME=1;	MFLAGS(Y2_3_Yaw_axis).#HOME=1	
END	
FDEF(Y2_3_axis).#LL = 	1	;	FDEF(Y2_3_Yaw_axis).#LL =  1			! turn on the response of reaching left limit
FDEF(Y2_3_axis).#SRL = 1	;	FDEF(Y2_3_Yaw_axis).#SRL = 1	 		! enable software right limit response
FDEF(Y2_3_axis).#SLL = 1	;	FDEF(Y2_3_Yaw_axis).#SLL = 1	 		! enable software left limit response
IF Y2_3_IsUsingGantryHmGain=1
	CALL ProdGain
END
DISP"Homing successful!!"	


STOP	

!!*************************************************************************************************************************************!!
!!************************************************************ Homing process	*******************************************************!!
Y2_3_HmType0:
!Customized
RET
STOP
!------------------------------------------------------------------Y2_3_HmType3--------------------------------------------------------------------------------------
Y2_3_HmType3:
Y2_3_GantryHomeStep = 0
IF Y2_3_IsFlexibleGantry = 1 
	Y2_3_IsGantryComove = 1										!Flexible gantry should comove
END

DISABLE (Y2_3_axis,Y2_3_Yaw_axis)	
TILL ^MST(Y2_3_axis).#ENABLED & ^MST(Y2_3_Yaw_axis).#ENABLED	
WAIT 500	
ERRORMAPOFF Y2_3_axis, -1	;	ERRORMAPOFF Y2_3_Yaw_axis, -1			! Close all Y2_3_axis & Y2_3_yaw_axis error compensation
MFLAGS(Y2_3_axis).#GANTRY = 0	;	MFLAGS(Y2_3_Yaw_axis).#GANTRY = 0	! turn off gantry mode (MFLAGS.25)
FDEF(Y2_3_axis).#SRL = 0	;	FDEF(Y2_3_Yaw_axis).#SRL = 0	 		! disable software right limit response
FDEF(Y2_3_axis).#SLL = 0	;	FDEF(Y2_3_Yaw_axis).#SLL = 0	 		! disable software left limit response

IF Y2_3_IsUsingGantryHmGain=1
	CALL HmGain
END

!-----------------------Enable_Master-----------------------------------!
ENABLE (Y2_3_axis)
TILL MST(Y2_3_axis).#ENABLED
WAIT 500
DISABLE (Y2_3_axis)	
TILL ^MST(Y2_3_axis).#ENABLED 
WAIT 500	

!-----------------------Enable_Slave-----------------------------------!
ENABLE (Y2_3_Yaw_axis)
TILL MST(Y2_3_Yaw_axis).#ENABLED
WAIT 500
DISABLE (Y2_3_Yaw_axis)	
TILL ^MST(Y2_3_Yaw_axis).#ENABLED		
WAIT 500	

MFLAGS(Y2_3_axis).#OPEN =0 ;	MFLAGS(Y2_3_Yaw_axis).#OPEN =0	 		! close loop control
FDEF(Y2_3_axis).#LL = 	0	;	FDEF(Y2_3_Yaw_axis).#LL =  0			! motor is not disable when left limit signal rising.

IF Y2_3_IsGantryComove = 1											! Comove
	ACC(Y2_3_Yaw_axis)=ACC(Y2_3_axis)									! Y2_3_axis & Y2_3_Yaw_axis should same motion profile
	DEC(Y2_3_Yaw_axis)=DEC(Y2_3_axis)	
	JERK(Y2_3_Yaw_axis)=JERK(Y2_3_axis)
	XCURI(Y2_3_Yaw_axis)=XCURI(Y2_3_axis)	
	XCURV(Y2_3_Yaw_axis)=XCURV(Y2_3_axis)	
	SLPKP(Y2_3_Yaw_axis)=SLPKP(Y2_3_axis)
	SLVKP(Y2_3_Yaw_axis)=SLVKP(Y2_3_axis)
	SLVKI(Y2_3_Yaw_axis)=SLVKI(Y2_3_axis)
	ENABLE (Y2_3_axis,Y2_3_Yaw_axis)
	TILL MST(Y2_3_axis).#ENABLED & MST(Y2_3_Yaw_axis).#ENABLED	
	JOG/WV (Y2_3_axis),-Y2_3_HmVel ; JOG/WV (Y2_3_Yaw_axis),-Y2_3_HmVel	
	GO (Y2_3_axis,Y2_3_Yaw_axis)										! Y2_3_axis & Y2_3_Yaw_axis move same time
	Y2_3_GantryHomeStep = 1										! Start find left limit *(should after GO to avoid unable to stop at left limit)
	IF Y2_3_IsFlexibleGantry = 1
		TILL FAULT(Y2_3_axis).#LL & FAULT(Y2_3_Yaw_axis).#LL
	ELSE
		TILL FAULT(Y2_3_axis).#LL
	END	
	HALT (Y2_3_axis,Y2_3_Yaw_axis)									! found left limit
	TILL ^MST(Y2_3_axis).#MOVE & ^MST(Y2_3_Yaw_axis).#MOVE	
ELSE															! drag one side
	ENABLE (Y2_3_axis)	
	TILL MST(Y2_3_axis).#ENABLED	
	JOG/V (Y2_3_axis),-Y2_3_HmVel									
	TILL FAULT(Y2_3_axis).#LL
	HALT Y2_3_axis													! found left limit
	TILL ^MST(Y2_3_axis).#MOVE	
END

IF Y2_3_multi_indHm = 1											! multiple index
	IF Y2_3_IsGantryComove = 1										! Comove
		Y2_3_GantryHomeStep = 2									! Start leave left limit
		JOG/WV (Y2_3_axis),Y2_3_multi_indVel ; JOG/WV (Y2_3_Yaw_axis),Y2_3_multi_indVel
		GO (Y2_3_axis,Y2_3_Yaw_axis)
		IF Y2_3_IsFlexibleGantry = 1
			TILL ^FAULT(Y2_3_axis).#LL & ^FAULT(Y2_3_Yaw_axis).#LL
		ELSE
			TILL ^FAULT(Y2_3_axis).#LL
		END 
		HALT (Y2_3_axis,Y2_3_Yaw_axis)								! leave left limit
		TILL ^MST(Y2_3_axis).#MOVE & ^MST(Y2_3_Yaw_axis).#MOVE	
	ELSE														! drag one side
		JOG/V (Y2_3_axis),Y2_3_multi_indVel
		TILL ^FAULT(Y2_3_axis).#LL
		HALT Y2_3_axis
		TILL ^MST(Y2_3_axis).#MOVE	
	END
	Y2_3_IndVel = Y2_3_multi_indVel
END
Y2_3_GantryHomeStep = 3
IST(Y2_3_axis).#IND = 1	;	IST(Y2_3_axis).#IND = 0				! reset the index signal
IST(Y2_3_Yaw_axis).#IND = 1	;	IST(Y2_3_Yaw_axis).#IND = 0	

IF Y2_3_IsGantryComove = 1
	JOG/WV (Y2_3_axis),Y2_3_IndVel ; JOG/WV (Y2_3_Yaw_axis),Y2_3_IndVel
	GO (Y2_3_axis,Y2_3_Yaw_axis)
ELSE
	JOG/V (Y2_3_axis),Y2_3_IndVel
END

TILL IST(Y2_3_axis).#IND & IST(Y2_3_Yaw_axis).#IND	
HALT (Y2_3_axis,Y2_3_Yaw_axis)
TILL ^MST(Y2_3_axis).#MOVE & ^MST(Y2_3_Yaw_axis).#MOVE	
DISP"Already found the index!!"	
DISABLE (Y2_3_axis,Y2_3_Yaw_axis)
TILL ^MST(Y2_3_axis).#ENABLED & ^MST(Y2_3_Yaw_axis).#ENABLED
wait 3000
SET FPOS(Y2_3_axis)=FPOS(Y2_3_axis)-IND(Y2_3_axis)-Y2_3_HmOffset	
SET FPOS(Y2_3_Yaw_axis)=FPOS(Y2_3_Yaw_axis)-IND(Y2_3_Yaw_axis) - Y2_3_HmOffset	+ Y2_3_Yawlock
DISABLE (Y2_3_axis,Y2_3_Yaw_axis)	
TILL ^MST(Y2_3_axis).#ENABLED & ^MST(Y2_3_Yaw_axis).#ENABLED
MFLAGS(Y2_3_axis).#GANTRY = 1	;	MFLAGS(Y2_3_Yaw_axis).#GANTRY = 1	! turn on gantry mode
XCURI(Y2_3_axis) = Y2_3_M_XCURI	;	XCURI(Y2_3_Yaw_axis) = Y2_3_S_XCURI
XCURV(Y2_3_axis) = Y2_3_M_XCURV	;	XCURV(Y2_3_Yaw_axis) = Y2_3_S_XCURV

RET	
STOP
!------------------------------------------------------------------Y2_3_HmType4--------------------------------------------------------------------------------------
Y2_3_HmType4:

RET	
STOP
!!****************************************************** Error Compensation Process ***************************************************!!
Y2_3_ErrorCompensation:
!---------- Y2_3_axis Error Compensation Table ------------!
Y2_3_ErrTable(0)=	0	;
Y2_3_ErrTable(1)=	-6.1	;
Y2_3_ErrTable(2)=	0.3	;
Y2_3_ErrTable(3)=	7.1	;
Y2_3_ErrTable(4)=	-0.9	;
Y2_3_ErrTable(5)=	8.6	;
Y2_3_ErrTable(6)=	11.1	;
Y2_3_ErrTable(7)=	13.8	;
Y2_3_ErrTable(8)=	17.2	;
Y2_3_ErrTable(9)=	17.5	;
Y2_3_ErrTable(10)=	17.6	;
Y2_3_ErrTable(11)=	22.1	;
Y2_3_ErrTable(12)=	17.8	;
Y2_3_ErrTable(13)=	28.2	;
Y2_3_ErrTable(14)=	31.2	;
Y2_3_ErrTable(15)=	24.6	;
Y2_3_ErrTable(16)=	37.5	;
Y2_3_ErrTable(17)=	32.4	;
Y2_3_ErrTable(18)=	30.3	;
Y2_3_ErrTable(19)=	35	;
Y2_3_ErrTable(20)=	39.1	;


!-------------------------------------------------------!
Y2_3_ErrTableIndex = 0
WHILE Y2_3_ErrTableIndex < SIZEOF(Y2_3_ErrTable)
	Y2_3_ErrTable(Y2_3_ErrTableIndex) = -Y2_3_ErrTable(Y2_3_ErrTableIndex)
	Y2_3_ErrTableIndex = Y2_3_ErrTableIndex + 1
END
ERRORUNMAP Y2_3_axis, ZONE0
ERRORMAP1D Y2_3_axis, ZONE0, Y2_3_ErrCompIniPos, Y2_3_ErrCompensationSpacing, Y2_3_ErrTable
ERRORMAPON Y2_3_axis, ZONE0

WAIT 500	
DISP "Cmpensation Procces's completed!"

RET 
STOP

!!*************************************************************************************************************************************!!
!!********************************************************* Current Compensation ******************************************************!!
Y2_3_CurrentCompensation:
ENABLE Y2_3_axis
TILL MST(Y2_3_axis).#ENABLED & MST(Y2_3_Yaw_axis).#ENABLED 
PTP/EV Y2_3_axis,Y2_3_CurrentCompensationIniPos,Y2_3_HmVel
DISABLE Y2_3_axis
TILL ^MST(Y2_3_axis).#ENABLED & ^MST(Y2_3_Yaw_axis).#ENABLED 
MFLAGS(Y2_3_Yaw_axis).#OPEN = 1		
ENABLE Y2_3_axis
TILL MST(Y2_3_axis).#ENABLED & MST(Y2_3_Yaw_axis).#ENABLED 

PTP/EV Y2_3_axis,Y2_3_CurrentCompensationIniPos,Y2_3_HmVel
WAIT Y2_3_CurrentCompensationSettleTime
Y2_3_CurrentCompensationIndex = 0
!Move positive
DISP"Y error table search sequence in positive direction......"
WHILE Y2_3_CurrentCompensationIndex <= Y2_3_CurrentCompensationSegment
	DISP"Y FPOS=%f , Y Yaw Offset = %f ",FPOS(Y2_3_axis),FPOS(Y2_3_Yaw_axis)
	Y2_3_CurrentTableTemp(0)(Y2_3_CurrentCompensationIndex) = FPOS(Y2_3_Yaw_axis)
	IF Y2_3_CurrentCompensationIndex < Y2_3_CurrentCompensationSegment
		PTP/ERV Y2_3_axis,Y2_3_CurrentCompensationSpacing,Y2_3_HmVel		
		WAIT Y2_3_CurrentCompensationSettleTime
	END
	Y2_3_CurrentCompensationIndex = Y2_3_CurrentCompensationIndex + 1	
END

PTP/EV Y2_3_axis,Y2_3_CurrentCompensationIniPos + Y2_3_CurrentCompensationTravel,Y2_3_HmVel
WAIT Y2_3_CurrentCompensationSettleTime
Y2_3_CurrentCompensationIndex = Y2_3_CurrentCompensationSegment
!Move negative unfinished
DISP"Y error table search sequence in negative direction......"
WHILE Y2_3_CurrentCompensationIndex >= 0
	DISP"Y FPOS=%f , Y Yaw Offset = %f ",FPOS(Y2_3_axis),FPOS(Y2_3_Yaw_axis)
	Y2_3_CurrentTableTemp(1)(Y2_3_CurrentCompensationIndex) = FPOS(Y2_3_Yaw_axis)
	IF Y2_3_CurrentCompensationIndex > 0
		PTP/ERV Y2_3_axis,-Y2_3_CurrentCompensationSpacing,Y2_3_HmVel		
		WAIT Y2_3_CurrentCompensationSettleTime
	END
	Y2_3_CurrentCompensationIndex = Y2_3_CurrentCompensationIndex - 1	
END

Y2_3_CurrentCompensationIndex = 0
WHILE Y2_3_CurrentCompensationIndex <= Y2_3_CurrentCompensationSegment
	Y2_3_CurrentTable(Y2_3_CurrentCompensationIndex)	=	(Y2_3_CurrentTableTemp(0)(Y2_3_CurrentCompensationIndex) + Y2_3_CurrentTableTemp(1)(Y2_3_CurrentCompensationIndex))/2
	Y2_3_CurrentCompensationIndex = Y2_3_CurrentCompensationIndex + 1
END

WRITE Y2_3_CurrentTable,Y2_3_CurrentTable
WAIT 1500	
PTP/EV Y2_3_axis,Y2_3_CurrentCompensationIniPos,Y2_3_HmVel
WAIT 500	

Y2_3_TurnOnCurrentCompensation:
DISABLE Y2_3_axis
TILL ^MST(Y2_3_axis).#ENABLED & ^MST(Y2_3_Yaw_axis).#ENABLED
MFLAGS(Y2_3_Yaw_axis).#OPEN = 0
ENABLE (Y2_3_axis,Y2_3_Yaw_axis)
TILL MST(Y2_3_axis).#ENABLED & MST(Y2_3_Yaw_axis).#ENABLED
READ Y2_3_CurrentTable,Y2_3_CurrentTable
ERRORUNMAP Y2_3_Yaw_axis, ZONE0
ERRORMAP1D Y2_3_Yaw_axis, ZONE0, Y2_3_CurrentCompensationIniPos, Y2_3_CurrentCompensationSpacing, Y2_3_CurrentTable
ERRORMAPON Y2_3_Yaw_axis, ZONE0
DISP"Current compensaton completed!"
RET 
STOP
!!*************************************************************************************************************************************!!
!**************************************Gains for homing********************************************!
HmGain:

SLPKP(Y2_3_axis)= Y2_3_GantryHmM_SLPKP	
SLVKP(Y2_3_axis)= Y2_3_GantryHmM_SLVKP	
SLVKI(Y2_3_axis)= Y2_3_GantryHmM_SLVKI	

SLPKP(Y2_3_Yaw_axis)= Y2_3_GantryHmS_SLPKP	
SLVKP(Y2_3_Yaw_axis)= Y2_3_GantryHmS_SLVKP	
SLVKI(Y2_3_Yaw_axis)= Y2_3_GantryHmS_SLVKI	


RET	
STOP
!**************************************Gains for production*****************************************!
ProdGain:

SLPKP(Y2_3_axis)= Y2_3_GantryProdM_SLPKP	
SLVKP(Y2_3_axis)= Y2_3_GantryProdM_SLVKP	
SLVKI(Y2_3_axis)= Y2_3_GantryProdM_SLVKI	

SLPKP(Y2_3_Yaw_axis)= Y2_3_GantryProdS_SLPKP	
SLVKP(Y2_3_Yaw_axis)= Y2_3_GantryProdS_SLVKP	
SLVKI(Y2_3_Yaw_axis)= Y2_3_GantryProdS_SLVKI	

RET
STOP
!!*************************************************************************************************************************************!!


!!#############################################################################################################################

ON Y2_3_GantryHomeStep = 1 & Y2_3_IsFlexibleGantry = 1 & FAULT(Y2_3_axis).#LL
	HALT Y2_3_axis
RET

ON Y2_3_GantryHomeStep = 1 & Y2_3_IsFlexibleGantry = 1 & FAULT(Y2_3_Yaw_axis).#LL
	HALT Y2_3_Yaw_axis
RET

ON Y2_3_GantryHomeStep = 2 & Y2_3_IsFlexibleGantry = 1 & ^FAULT(Y2_3_axis).#LL
	HALT Y2_3_axis
RET

ON Y2_3_GantryHomeStep = 2 & Y2_3_IsFlexibleGantry = 1 & ^FAULT(Y2_3_Yaw_axis).#LL
	HALT Y2_3_Yaw_axis
RET


ON MFLAGS(Y2_3_axis).#HOME=1 & MFLAGS(Y2_3_axis).#HOME=1 & TPOS(Y2_3_axis) < SLLIMIT(Y2_3_axis) 
	IF( FDEF(Y2_3_axis).#SLL=1 & FMASK(Y2_3_axis).#SLL=1 & ^(GMTYPE(Y2_3_axis)=5))
		KILL Y2_3_axis,5016	!Software Left Limit
		TPOS(Y2_3_axis)=FPOS(Y2_3_axis)
		DISP "TPOS(Y2_3_axis) < SLLIMIT(Y2_3_axis)"
	END
RET

ON MFLAGS(Y2_3_axis).#HOME=1 & MFLAGS(Y2_3_axis).#HOME=1 & TPOS(Y2_3_axis) > SRLIMIT(Y2_3_axis) 
	IF(FDEF(Y2_3_axis).#SRL=1 & FMASK(Y2_3_axis).#SRL=1 & ^(GMTYPE(Y2_3_axis)=5))
		KILL Y2_3_axis,5015	!Software Right Limit
		TPOS(Y2_3_axis)=FPOS(Y2_3_axis)
		DISP "TPOS(Y2_3_axis) > SRLIMIT(Y2_3_axis)"
	END
RET

ON MFLAGS(Y2_3_axis).#HOME=1 & MFLAGS(Y2_3_axis).#HOME=1 & TPOS(Y2_3_Yaw_axis) < SLLIMIT(Y2_3_Yaw_axis) 
	IF( FDEF(Y2_3_Yaw_axis).#SLL=1 & FMASK(Y2_3_Yaw_axis).#SLL=1 & ^(GMTYPE(Y2_3_Yaw_axis)=5))
		KILL Y2_3_Yaw_axis,5016	!Software Left Limit
		TPOS(Y2_3_Yaw_axis)=FPOS(Y2_3_Yaw_axis)
		DISP "TPOS(Y2_3_Yaw_axis) < SLLIMIT(Y2_3_Yaw_axis)"
	END
RET

ON MFLAGS(Y2_3_axis).#HOME=1 & MFLAGS(Y2_3_axis).#HOME=1 & TPOS(Y2_3_Yaw_axis) > SRLIMIT(Y2_3_Yaw_axis) 
	IF(FDEF(Y2_3_Yaw_axis).#SRL=1 & FMASK(Y2_3_Yaw_axis).#SRL=1 & ^(GMTYPE(Y2_3_Yaw_axis)=5))
		KILL Y2_3_Yaw_axis,5015	!Software Right Limit
		TPOS(Y2_3_Yaw_axis)=FPOS(Y2_3_Yaw_axis)
		DISP "TPOS(Y2_3_Yaw_axis) > SRLIMIT(Y2_3_Yaw_axis)"
	END
RET



ON MFLAGS(Y2_3_axis).#HOME=0 & RVEL(Y2_3_axis) > XVEL(Y2_3_axis)*0.5 & ^MST(Y2_3_axis).#INPOS
	IMM VEL(Y2_3_axis) = XVEL(Y2_3_axis)*0.45 !?30
RET

ON MFLAGS(Y2_3_axis).#HOME=0 & RVEL(Y2_3_axis) < -XVEL(Y2_3_axis)*0.5 & ^MST(Y2_3_axis).#INPOS
	IMM VEL(Y2_3_axis) = -XVEL(Y2_3_axis)*0.45 !?30
RET

AUTOEXEC:
	MFLAGS(Y2_3_axis).#HOME=0;	MFLAGS(Y2_3_Yaw_axis).#HOME=0
STOP

#5
!PNAME=
!PDESC=
! Y2_4_axis Gantry Standard Homing Process
! Version 1.5 Beta
!!****** Setting Parameter ******!!
LOCAL REAL Y2_4_HmType,Y2_4_multi_indHm,Y2_4_multi_indVel
LOCAL REAL Y2_4_HmVel,Y2_4_IndVel,Y2_4_HmOffset	
LOCAL INT Y2_4_ErrCompensation,Y2_4_ErrCompensationSpacing,Y2_4_ErrCompIniPos
LOCAL INT Y2_4_CurrentCompensation,Y2_4_CurrentCompensationIndex,Y2_4_CurrentCompensationSettleTime
GLOBAL REAL Y2_4_CurrentTableTemp(2)(21)
LOCAL REAL Y2_4_CurrentCompensationTravel,Y2_4_CurrentCompensationSpacing,Y2_4_CurrentCompensationSegment,Y2_4_CurrentCompensationIniPos
LOCAL INT ZONE0,Y2_4_ErrTableIndex
LOCAL REAL Y2_4_GantryHmM_SLPKP,Y2_4_GantryHmM_SLVKP,Y2_4_GantryHmM_SLVKI,Y2_4_GantryHmS_SLPKP,Y2_4_GantryHmS_SLVKP,Y2_4_GantryHmS_SLVKI
LOCAL REAL Y2_4_GantryProdM_SLPKP,Y2_4_GantryProdM_SLVKP,Y2_4_GantryProdM_SLVKI,Y2_4_GantryProdS_SLPKP,Y2_4_GantryProdS_SLVKP,Y2_4_GantryProdS_SLVKI
LOCAL REAL Y2_4_M_XCURI,Y2_4_M_XCURV,Y2_4_S_XCURI,Y2_4_S_XCURV
LOCAL INT Y2_4_IsUsingGantryHmGain,Y2_4_IsFlexibleGantry,Y2_4_IsGantryComove,Y2_4_EtherCATIndex,Y2_4_GantryHomeStep
LOCAL REAL Y2_4_Yawlock
LOCAL REAL Y2_4_CommutCurrent,Y2_4_Yaw_CommutCurrent
!!################ Basic Settings ######################################################################################################
Y2_4_HmType = 3 								!the method of homing
           									!value 0 : Customized homing											
											!	   3 : this type is for gantry mode , and the motion for homing is same as Y2_4_HmType=1.
											!	   4 : this type is for gantry mode , and the motion for homing is same as Y2_4_HmType=2.
Y2_4_HmOffset = 0 								! Y2_4_HmOffset (unit)
Y2_4_HmVel = 20000								! the velocity for homing 	
Y2_4_IndVel = 10000 								! the velocity for finding index

Y2_4_multi_indHm=0								! multi index structure
											! value 0 : nomal Homing
											!	    1 : find the left limit in negative direction,then slowing leave the limit in positive direction,
											!			then slowing find the left limit in negative direction,then slowing find index in positive direction
Y2_4_multi_indVel = 100						! (Do not modify)homing velocity of multi index structure
Y2_4_CommutCurrent = 80						! Commutation excitation current.
Y2_4_Yaw_CommutCurrent = 80					! Yaw axis Commutation excitation current.
!!*********************************** Y2_4_axis Gantry mod ***************************************************!!
Y2_4_IsFlexibleGantry = 0 						! 0: Stiff Gantry ; 1: Flexible Gantry (Y2_4_IsGantryComove automatically set to 1 )
Y2_4_IsGantryComove = 0						! 0: Search limit and index by Y2_4_axis
											! 1: Search limit and index by Y2_4_axis and Y2_4_Yaw_axis comove
Y2_4_Yawlock = -71							! Y2_4_Yaw_axis follow position
Y2_4_M_XCURI = 40								! Y2_4_axis XCURI
Y2_4_M_XCURV = 90								! Y2_4_axis XCURV
Y2_4_S_XCURI = 10								! Y2_4_Yaw_axis XCURI
Y2_4_S_XCURV = 10								! Y2_4_Yaw_axis XCURV

Y2_4_IsUsingGantryHmGain = 1					! 0 : Homing and production using same gain 
											    ! 1 : Homing and production using different gain 
!------------------Homing and production gain set (Set by Y2_4_IsUsingGantryHmGain = 1)-----------------!
Y2_4_GantryHmM_SLPKP = 10						! Y2_4_axis homing gain
Y2_4_GantryHmM_SLVKP = 50		
Y2_4_GantryHmM_SLVKI = 50
Y2_4_GantryHmS_SLPKP = 0						! Y2_4_Yaw_axis homing gain
Y2_4_GantryHmS_SLVKP = 20
Y2_4_GantryHmS_SLVKI = 40
Y2_4_GantryProdM_SLPKP = 140					! Y2_4_axis production gain
Y2_4_GantryProdM_SLVKP = 80
Y2_4_GantryProdM_SLVKI = 150
Y2_4_GantryProdS_SLPKP = 40					! Y2_4_Yaw_axis production gain
Y2_4_GantryProdS_SLVKP = 30
Y2_4_GantryProdS_SLVKI = 120
!!**************** Configuration of 1D Error Compensation*****************************************************!!
Y2_4_ErrCompensation = 1						! 0 : without compensation  ; 1 : turn on the compensation after homing completed 
Y2_4_ErrCompIniPos = 0							! the initial position of error compensation
Y2_4_ErrCompensationSpacing = 95000				! setting the spacing for error compensation 
!!**************** Configuration of Current Compensation for gantry mode ***************************************!!
Y2_4_CurrentCompensation = 1    				! Current Compensation
											! the value 0 : without current compensation.
											!           1 : Enable current compensation mode with exist current table. 
											!           2 : Execute the process of current table search after homing , and then 
											!               enable current compensation mode.
Y2_4_CurrentCompensationIniPos = 0				! compensation start postion
Y2_4_CurrentCompensationTravel = 1900000			! the stroke (unit) of CurrentCompensation
Y2_4_CurrentCompensationSegment = 10			! the segment for current compensation.
Y2_4_CurrentCompensationSettleTime = 5000		! time requiered for Yaw axis to take satisfactory position
Y2_4_CurrentCompensationSpacing = Y2_4_CurrentCompensationTravel / Y2_4_CurrentCompensationSegment	 ! the spacing for current compensation (unit)
!!**********************************************************************************************************!!
!!######################################################################################################################################## 

!!**************************************************************************************************************************************!!
!!************************************************************ Main program ************************************************************!!

IF Y2_4_HmType=0													! Customized homing
	MFLAGS(Y2_4_axis).#HOME=0;	MFLAGS(Y2_4_Yaw_axis).#HOME=0
	CALL Y2_4_HmType0
ELSEIF Y2_4_HmType>=3 & Y2_4_HmType<=4 			! Gantry Homing	
	MFLAGS(Y2_4_axis).#HOME=0;	MFLAGS(Y2_4_Yaw_axis).#HOME=0
	IF Y2_4_HmType=3
		CALL Y2_4_HmType3
	ELSEIF Y2_4_HmType=4
		CALL Y2_4_HmType4
	END
ELSE
	DISP"ERROR:The value of Y2_4_HmType or Y2_4_HiwinDriveHome is invalid!!"
	STOP
END

IF (Y2_4_CurrentCompensation=1 & Y2_4_HmType>=3)
	DISP"Turn on the Current Compensation..."	
	CALL Y2_4_TurnOnCurrentCompensation	
ELSEIF (Y2_4_CurrentCompensation=2 &  Y2_4_HmType>=3)
	CALL Y2_4_CurrentCompensation	
ELSEIF (Y2_4_CurrentCompensation=0 &  Y2_4_HmType>=3)	
	ERRORUNMAP Y2_4_Yaw_axis, ZONE0
END

IF Y2_4_ErrCompensation = 1
	DISP "Enable the compensation mode."
	DISP "Execute the compensation prcoess......"
	CALL Y2_4_ErrorCompensation	
ELSE
	DISP "Disable error compensation."
	ERRORUNMAP Y2_4_axis, ZONE0
END 

IF (Y2_4_HmType>=3&Y2_4_HmType<=4)
	ENABLE (Y2_4_axis)	
	TILL MST(Y2_4_axis).#ENABLED & MST(Y2_4_Yaw_axis).#ENABLED
	WAIT 500
	DISP"Go home......"	
	PTP/EV Y2_4_axis,0,Y2_4_HmVel		
	PTP/EV Y2_4_Yaw_axis,0,Y2_4_HmVel !Yaw lock s
	MFLAGS(Y2_4_axis).#HOME=1;	MFLAGS(Y2_4_Yaw_axis).#HOME=1	
END	
FDEF(Y2_4_axis).#LL = 	1	;	FDEF(Y2_4_Yaw_axis).#LL =  1			! turn on the response of reaching left limit
FDEF(Y2_4_axis).#SRL = 1	;	FDEF(Y2_4_Yaw_axis).#SRL = 1	 		! enable software right limit response
FDEF(Y2_4_axis).#SLL = 1	;	FDEF(Y2_4_Yaw_axis).#SLL = 1	 		! enable software left limit response
IF Y2_4_IsUsingGantryHmGain=1
	CALL ProdGain
END
DISP"Homing successful!!"	


STOP	

!!*************************************************************************************************************************************!!
!!************************************************************ Homing process	*******************************************************!!
Y2_4_HmType0:
!Customized
RET
STOP
!------------------------------------------------------------------Y2_4_HmType3--------------------------------------------------------------------------------------
Y2_4_HmType3:
Y2_4_GantryHomeStep = 0
IF Y2_4_IsFlexibleGantry = 1 
	Y2_4_IsGantryComove = 1										!Flexible gantry should comove
END

DISABLE (Y2_4_axis,Y2_4_Yaw_axis)	
TILL ^MST(Y2_4_axis).#ENABLED & ^MST(Y2_4_Yaw_axis).#ENABLED	
WAIT 500	
ERRORMAPOFF Y2_4_axis, -1	;	ERRORMAPOFF Y2_4_Yaw_axis, -1			! Close all Y2_4_axis & Y2_4_yaw_axis error compensation
MFLAGS(Y2_4_axis).#GANTRY = 0	;	MFLAGS(Y2_4_Yaw_axis).#GANTRY = 0	! turn off gantry mode (MFLAGS.25)
FDEF(Y2_4_axis).#SRL = 0	;	FDEF(Y2_4_Yaw_axis).#SRL = 0	 		! disable software right limit response
FDEF(Y2_4_axis).#SLL = 0	;	FDEF(Y2_4_Yaw_axis).#SLL = 0	 		! disable software left limit response

IF Y2_4_IsUsingGantryHmGain=1
	CALL HmGain
END

!-----------------------Enable_Master-----------------------------------!
ENABLE (Y2_4_axis)
TILL MST(Y2_4_axis).#ENABLED
WAIT 500
DISABLE (Y2_4_axis)	
TILL ^MST(Y2_4_axis).#ENABLED 
WAIT 500	

!-----------------------Enable_Slave-----------------------------------!
ENABLE (Y2_4_Yaw_axis)
TILL MST(Y2_4_Yaw_axis).#ENABLED
WAIT 500
DISABLE (Y2_4_Yaw_axis)	
TILL ^MST(Y2_4_Yaw_axis).#ENABLED			
WAIT 500
	
MFLAGS(Y2_4_axis).#OPEN =0 ;	MFLAGS(Y2_4_Yaw_axis).#OPEN =0	 		! close loop control
FDEF(Y2_4_axis).#LL = 	0	;	FDEF(Y2_4_Yaw_axis).#LL =  0			! motor is not disable when left limit signal rising.

IF Y2_4_IsGantryComove = 1											! Comove
	ACC(Y2_4_Yaw_axis)=ACC(Y2_4_axis)									! Y2_4_axis & Y2_4_Yaw_axis should same motion profile
	DEC(Y2_4_Yaw_axis)=DEC(Y2_4_axis)	
	JERK(Y2_4_Yaw_axis)=JERK(Y2_4_axis)
	XCURI(Y2_4_Yaw_axis)=XCURI(Y2_4_axis)	
	XCURV(Y2_4_Yaw_axis)=XCURV(Y2_4_axis)	
	SLPKP(Y2_4_Yaw_axis)=SLPKP(Y2_4_axis)
	SLVKP(Y2_4_Yaw_axis)=SLVKP(Y2_4_axis)
	SLVKI(Y2_4_Yaw_axis)=SLVKI(Y2_4_axis)
	ENABLE (Y2_4_axis,Y2_4_Yaw_axis)
	TILL MST(Y2_4_axis).#ENABLED & MST(Y2_4_Yaw_axis).#ENABLED	
	JOG/WV (Y2_4_axis),-Y2_4_HmVel ; JOG/WV (Y2_4_Yaw_axis),-Y2_4_HmVel	
	GO (Y2_4_axis,Y2_4_Yaw_axis)										! Y2_4_axis & Y2_4_Yaw_axis move same time
	Y2_4_GantryHomeStep = 1										! Start find left limit *(should after GO to avoid unable to stop at left limit)
	IF Y2_4_IsFlexibleGantry = 1
		TILL FAULT(Y2_4_axis).#LL & FAULT(Y2_4_Yaw_axis).#LL
	ELSE
		TILL FAULT(Y2_4_axis).#LL
	END	
	HALT (Y2_4_axis,Y2_4_Yaw_axis)									! found left limit
	TILL ^MST(Y2_4_axis).#MOVE & ^MST(Y2_4_Yaw_axis).#MOVE	
ELSE															! drag one side
	ENABLE (Y2_4_axis)	
	TILL MST(Y2_4_axis).#ENABLED	
	JOG/V (Y2_4_axis),-Y2_4_HmVel									
	TILL FAULT(Y2_4_axis).#LL
	HALT Y2_4_axis													! found left limit
	TILL ^MST(Y2_4_axis).#MOVE	
END

IF Y2_4_multi_indHm = 1											! multiple index
	IF Y2_4_IsGantryComove = 1										! Comove
		Y2_4_GantryHomeStep = 2									! Start leave left limit
		JOG/WV (Y2_4_axis),Y2_4_multi_indVel ; JOG/WV (Y2_4_Yaw_axis),Y2_4_multi_indVel
		GO (Y2_4_axis,Y2_4_Yaw_axis)
		IF Y2_4_IsFlexibleGantry = 1
			TILL ^FAULT(Y2_4_axis).#LL & ^FAULT(Y2_4_Yaw_axis).#LL
		ELSE
			TILL ^FAULT(Y2_4_axis).#LL
		END 
		HALT (Y2_4_axis,Y2_4_Yaw_axis)								! leave left limit
		TILL ^MST(Y2_4_axis).#MOVE & ^MST(Y2_4_Yaw_axis).#MOVE	
	ELSE														! drag one side
		JOG/V (Y2_4_axis),Y2_4_multi_indVel
		TILL ^FAULT(Y2_4_axis).#LL
		HALT Y2_4_axis
		TILL ^MST(Y2_4_axis).#MOVE	
	END
	Y2_4_IndVel = Y2_4_multi_indVel
END
Y2_4_GantryHomeStep = 3
IST(Y2_4_axis).#IND = 1	;	IST(Y2_4_axis).#IND = 0				! reset the index signal
IST(Y2_4_Yaw_axis).#IND = 1	;	IST(Y2_4_Yaw_axis).#IND = 0	

IF Y2_4_IsGantryComove = 1
	JOG/WV (Y2_4_axis),Y2_4_IndVel ; JOG/WV (Y2_4_Yaw_axis),Y2_4_IndVel
	GO (Y2_4_axis,Y2_4_Yaw_axis)
ELSE
	JOG/V (Y2_4_axis),Y2_4_IndVel
END

TILL IST(Y2_4_axis).#IND & IST(Y2_4_Yaw_axis).#IND	
HALT (Y2_4_axis,Y2_4_Yaw_axis)
TILL ^MST(Y2_4_axis).#MOVE & ^MST(Y2_4_Yaw_axis).#MOVE	
DISP"Already found the index!!"	
DISABLE (Y2_4_axis,Y2_4_Yaw_axis)
TILL ^MST(Y2_4_axis).#ENABLED & ^MST(Y2_4_Yaw_axis).#ENABLED
wait 3000
SET FPOS(Y2_4_axis)=FPOS(Y2_4_axis)-IND(Y2_4_axis)-Y2_4_HmOffset	
SET FPOS(Y2_4_Yaw_axis)=FPOS(Y2_4_Yaw_axis)-IND(Y2_4_Yaw_axis) - Y2_4_HmOffset	+ Y2_4_Yawlock
DISABLE (Y2_4_axis,Y2_4_Yaw_axis)	
TILL ^MST(Y2_4_axis).#ENABLED & ^MST(Y2_4_Yaw_axis).#ENABLED
MFLAGS(Y2_4_axis).#GANTRY = 1	;	MFLAGS(Y2_4_Yaw_axis).#GANTRY = 1	! turn on gantry mode
XCURI(Y2_4_axis) = Y2_4_M_XCURI	;	XCURI(Y2_4_Yaw_axis) = Y2_4_S_XCURI
XCURV(Y2_4_axis) = Y2_4_M_XCURV	;	XCURV(Y2_4_Yaw_axis) = Y2_4_S_XCURV

RET	
STOP
!------------------------------------------------------------------Y2_4_HmType4--------------------------------------------------------------------------------------
Y2_4_HmType4:

RET	
STOP
!!****************************************************** Error Compensation Process ***************************************************!!
Y2_4_ErrorCompensation:
!---------- Y2_4_axis Error Compensation Table ------------!
Y2_4_ErrTable(0)=	0	;
Y2_4_ErrTable(1)=	11.8	;
Y2_4_ErrTable(2)=	18.5	;
Y2_4_ErrTable(3)=	22.5	;
Y2_4_ErrTable(4)=	20.7	;
Y2_4_ErrTable(5)=	31	;
Y2_4_ErrTable(6)=	18.9	;
Y2_4_ErrTable(7)=	10.1	;
Y2_4_ErrTable(8)=	13.1	;
Y2_4_ErrTable(9)=	15.5	;
Y2_4_ErrTable(10)=	19.4	;
Y2_4_ErrTable(11)=	28	;
Y2_4_ErrTable(12)=	28.9	;
Y2_4_ErrTable(13)=	34.2	;
Y2_4_ErrTable(14)=	25.6	;
Y2_4_ErrTable(15)=	20.4	;
Y2_4_ErrTable(16)=	14.7	;
Y2_4_ErrTable(17)=	13.1	;
Y2_4_ErrTable(18)=	27.4	;
Y2_4_ErrTable(19)=	42.2	;
Y2_4_ErrTable(20)=	57.2	;


!-------------------------------------------------------!
Y2_4_ErrTableIndex = 0
WHILE Y2_4_ErrTableIndex < SIZEOF(Y2_4_ErrTable)
	Y2_4_ErrTable(Y2_4_ErrTableIndex) = -Y2_4_ErrTable(Y2_4_ErrTableIndex)
	Y2_4_ErrTableIndex = Y2_4_ErrTableIndex + 1
END
ERRORUNMAP Y2_4_axis, ZONE0
ERRORMAP1D Y2_4_axis, ZONE0, Y2_4_ErrCompIniPos, Y2_4_ErrCompensationSpacing, Y2_4_ErrTable
ERRORMAPON Y2_4_axis, ZONE0

WAIT 500	
DISP "Cmpensation Procces's completed!"

RET 
STOP

!!*************************************************************************************************************************************!!
!!********************************************************* Current Compensation ******************************************************!!
Y2_4_CurrentCompensation:
ENABLE Y2_4_axis
TILL MST(Y2_4_axis).#ENABLED & MST(Y2_4_Yaw_axis).#ENABLED 
PTP/EV Y2_4_axis,Y2_4_CurrentCompensationIniPos,Y2_4_HmVel
DISABLE Y2_4_axis
TILL ^MST(Y2_4_axis).#ENABLED & ^MST(Y2_4_Yaw_axis).#ENABLED 
MFLAGS(Y2_4_Yaw_axis).#OPEN = 1		
ENABLE Y2_4_axis
TILL MST(Y2_4_axis).#ENABLED & MST(Y2_4_Yaw_axis).#ENABLED 

PTP/EV Y2_4_axis,Y2_4_CurrentCompensationIniPos,Y2_4_HmVel
WAIT Y2_4_CurrentCompensationSettleTime
Y2_4_CurrentCompensationIndex = 0
!Move positive
DISP"Y error table search sequence in positive direction......"
WHILE Y2_4_CurrentCompensationIndex <= Y2_4_CurrentCompensationSegment
	DISP"Y FPOS=%f , Y Yaw Offset = %f ",FPOS(Y2_4_axis),FPOS(Y2_4_Yaw_axis)
	Y2_4_CurrentTableTemp(0)(Y2_4_CurrentCompensationIndex) = FPOS(Y2_4_Yaw_axis)
	IF Y2_4_CurrentCompensationIndex < Y2_4_CurrentCompensationSegment
		PTP/ERV Y2_4_axis,Y2_4_CurrentCompensationSpacing,Y2_4_HmVel		
		WAIT Y2_4_CurrentCompensationSettleTime
	END
	Y2_4_CurrentCompensationIndex = Y2_4_CurrentCompensationIndex + 1	
END

PTP/EV Y2_4_axis,Y2_4_CurrentCompensationIniPos + Y2_4_CurrentCompensationTravel,Y2_4_HmVel
WAIT Y2_4_CurrentCompensationSettleTime
Y2_4_CurrentCompensationIndex = Y2_4_CurrentCompensationSegment
!Move negative unfinished
DISP"Y error table search sequence in negative direction......"
WHILE Y2_4_CurrentCompensationIndex >= 0
	DISP"Y FPOS=%f , Y Yaw Offset = %f ",FPOS(Y2_4_axis),FPOS(Y2_4_Yaw_axis)
	Y2_4_CurrentTableTemp(1)(Y2_4_CurrentCompensationIndex) = FPOS(Y2_4_Yaw_axis)
	IF Y2_4_CurrentCompensationIndex > 0
		PTP/ERV Y2_4_axis,-Y2_4_CurrentCompensationSpacing,Y2_4_HmVel		
		WAIT Y2_4_CurrentCompensationSettleTime
	END
	Y2_4_CurrentCompensationIndex = Y2_4_CurrentCompensationIndex - 1	
END

Y2_4_CurrentCompensationIndex = 0
WHILE Y2_4_CurrentCompensationIndex <= Y2_4_CurrentCompensationSegment
	Y2_4_CurrentTable(Y2_4_CurrentCompensationIndex)	=	(Y2_4_CurrentTableTemp(0)(Y2_4_CurrentCompensationIndex) + Y2_4_CurrentTableTemp(1)(Y2_4_CurrentCompensationIndex))/2
	Y2_4_CurrentCompensationIndex = Y2_4_CurrentCompensationIndex + 1
END

WRITE Y2_4_CurrentTable,Y2_4_CurrentTable
WAIT 1500	
PTP/EV Y2_4_axis,Y2_4_CurrentCompensationIniPos,Y2_4_HmVel
WAIT 500	

Y2_4_TurnOnCurrentCompensation:
DISABLE Y2_4_axis
TILL ^MST(Y2_4_axis).#ENABLED & ^MST(Y2_4_Yaw_axis).#ENABLED
MFLAGS(Y2_4_Yaw_axis).#OPEN = 0
ENABLE (Y2_4_axis,Y2_4_Yaw_axis)
TILL MST(Y2_4_axis).#ENABLED & MST(Y2_4_Yaw_axis).#ENABLED
READ Y2_4_CurrentTable,Y2_4_CurrentTable
ERRORUNMAP Y2_4_Yaw_axis, ZONE0
ERRORMAP1D Y2_4_Yaw_axis, ZONE0, Y2_4_CurrentCompensationIniPos, Y2_4_CurrentCompensationSpacing, Y2_4_CurrentTable
ERRORMAPON Y2_4_Yaw_axis, ZONE0
DISP"Current compensaton completed!"
RET 
STOP
!!*************************************************************************************************************************************!!
!**************************************Gains for homing********************************************!
HmGain:

SLPKP(Y2_4_axis)= Y2_4_GantryHmM_SLPKP	
SLVKP(Y2_4_axis)= Y2_4_GantryHmM_SLVKP	
SLVKI(Y2_4_axis)= Y2_4_GantryHmM_SLVKI	

SLPKP(Y2_4_Yaw_axis)= Y2_4_GantryHmS_SLPKP	
SLVKP(Y2_4_Yaw_axis)= Y2_4_GantryHmS_SLVKP	
SLVKI(Y2_4_Yaw_axis)= Y2_4_GantryHmS_SLVKI	


RET	
STOP
!**************************************Gains for production*****************************************!
ProdGain:

SLPKP(Y2_4_axis)= Y2_4_GantryProdM_SLPKP	
SLVKP(Y2_4_axis)= Y2_4_GantryProdM_SLVKP	
SLVKI(Y2_4_axis)= Y2_4_GantryProdM_SLVKI	

SLPKP(Y2_4_Yaw_axis)= Y2_4_GantryProdS_SLPKP	
SLVKP(Y2_4_Yaw_axis)= Y2_4_GantryProdS_SLVKP	
SLVKI(Y2_4_Yaw_axis)= Y2_4_GantryProdS_SLVKI	

RET
STOP
!!*************************************************************************************************************************************!!


!!#############################################################################################################################

ON Y2_4_GantryHomeStep = 1 & Y2_4_IsFlexibleGantry = 1 & FAULT(Y2_4_axis).#LL
	HALT Y2_4_axis
RET

ON Y2_4_GantryHomeStep = 1 & Y2_4_IsFlexibleGantry = 1 & FAULT(Y2_4_Yaw_axis).#LL
	HALT Y2_4_Yaw_axis
RET

ON Y2_4_GantryHomeStep = 2 & Y2_4_IsFlexibleGantry = 1 & ^FAULT(Y2_4_axis).#LL
	HALT Y2_4_axis
RET

ON Y2_4_GantryHomeStep = 2 & Y2_4_IsFlexibleGantry = 1 & ^FAULT(Y2_4_Yaw_axis).#LL
	HALT Y2_4_Yaw_axis
RET


ON MFLAGS(Y2_4_axis).#HOME=1 &  MFLAGS(Y2_4_Yaw_axis).#HOME=1 & TPOS(Y2_4_axis) < SLLIMIT(Y2_4_axis) 
	IF( FDEF(Y2_4_axis).#SLL=1 & FMASK(Y2_4_axis).#SLL=1 & ^(GMTYPE(Y2_4_axis)=5))
		KILL Y2_4_axis,5016	!Software Left Limit
		TPOS(Y2_4_axis)=FPOS(Y2_4_axis)
		DISP "TPOS(Y2_4_axis) < SLLIMIT(Y2_4_axis)"
	END
RET

ON MFLAGS(Y2_4_axis).#HOME=1 &  MFLAGS(Y2_4_Yaw_axis).#HOME=1 & TPOS(Y2_4_axis) > SRLIMIT(Y2_4_axis) 
	IF(FDEF(Y2_4_axis).#SRL=1 & FMASK(Y2_4_axis).#SRL=1 & ^(GMTYPE(Y2_4_axis)=5))
		KILL Y2_4_axis,5015	!Software Right Limit
		TPOS(Y2_4_axis)=FPOS(Y2_4_axis)
		DISP "TPOS(Y2_4_axis) > SRLIMIT(Y2_4_axis)"
	END
RET

ON MFLAGS(Y2_4_axis).#HOME=1 &  MFLAGS(Y2_4_Yaw_axis).#HOME=1 & TPOS(Y2_4_Yaw_axis) < SLLIMIT(Y2_4_Yaw_axis) 
	IF( FDEF(Y2_4_Yaw_axis).#SLL=1 & FMASK(Y2_4_Yaw_axis).#SLL=1 & ^(GMTYPE(Y2_4_Yaw_axis)=5))
		KILL Y2_4_Yaw_axis,5016	!Software Left Limit
		TPOS(Y2_4_Yaw_axis)=FPOS(Y2_4_Yaw_axis)
		DISP "TPOS(Y2_4_Yaw_axis) < SLLIMIT(Y2_4_Yaw_axis)"
	END
RET

ON  MFLAGS(Y2_4_axis).#HOME=1 &  MFLAGS(Y2_4_Yaw_axis).#HOME=1 & TPOS(Y2_4_Yaw_axis) > SRLIMIT(Y2_4_Yaw_axis) 
	IF(FDEF(Y2_4_Yaw_axis).#SRL=1 & FMASK(Y2_4_Yaw_axis).#SRL=1 & ^(GMTYPE(Y2_4_Yaw_axis)=5))
		KILL Y2_4_Yaw_axis,5015	!Software Right Limit
		TPOS(Y2_4_Yaw_axis)=FPOS(Y2_4_Yaw_axis)
		DISP "TPOS(Y2_4_Yaw_axis) > SRLIMIT(Y2_4_Yaw_axis)"
	END
RET



ON MFLAGS(Y2_4_axis).#HOME=0 & RVEL(Y2_4_axis) > XVEL(Y2_4_axis)*0.5 & ^MST(Y2_4_axis).#INPOS
	IMM VEL(Y2_4_axis) = XVEL(Y2_4_axis)*0.45 !?30
RET

ON MFLAGS(Y2_4_axis).#HOME=0 & RVEL(Y2_4_axis) < -XVEL(Y2_4_axis)*0.5 & ^MST(Y2_4_axis).#INPOS
	IMM VEL(Y2_4_axis) = -XVEL(Y2_4_axis)*0.45 !?30
RET

AUTOEXEC:
	MFLAGS(Y2_4_axis).#HOME=0;	MFLAGS(Y2_4_Yaw_axis).#HOME=0
STOP

#6
!PNAME=
!PDESC=
! X3_axis Gantry-axis_ACS_Drive_Homing_Process_VER1.5
!!****** Setting Parameter ******!!
LOCAL REAL X3_HmType,X3_multi_indHm,X3_multi_indVel
LOCAL REAL X3_HmVel,X3_IndVel,X3_HmOffset	
LOCAL INT X3_ErrCompensation,X3_ErrCompensationSpacing,X3_ErrCompIniPos
LOCAL INT X3_CurrentCompensation,X3_CurrentCompensationIndex,X3_CurrentCompensationSettleTime
LOCAL REAL X3_CurrentTableTemp(2)(21)
LOCAL REAL X3_CurrentCompensationTravel,X3_CurrentCompensationSpacing,X3_CurrentCompensationSegment,X3_CurrentCompensationIniPos
LOCAL INT ZONE0,X3_ErrTableIndex
LOCAL REAL X3_GantryHmM_SLPKP,X3_GantryHmM_SLVKP,X3_GantryHmM_SLVKI,X3_GantryHmS_SLPKP,X3_GantryHmS_SLVKP,X3_GantryHmS_SLVKI
LOCAL REAL X3_GantryProdM_SLPKP,X3_GantryProdM_SLVKP,X3_GantryProdM_SLVKI,X3_GantryProdS_SLPKP,X3_GantryProdS_SLVKP,X3_GantryProdS_SLVKI
LOCAL REAL X3_M_XCURI,X3_M_XCURV,X3_S_XCURI,X3_S_XCURV
LOCAL INT X3_IsUsingGantryHmGain,X3_IsFlexibleGantry,X3_IsGantryComove,X3_EtherCATIndex,X3_GantryHomeStep
LOCAL REAL X3_Yawlock
LOCAL REAL X3_CommutCurrent,X3_Yaw_CommutCurrent
LOCAL INT X3_Yaw_Offset !2023.11.13
!!################ Basic Settings ######################################################################################################
X3_HmType = 0 								!the method of homing
           									!value 0 : Customized homing											
											!	   3 : this type is for gantry mode , and the motion for homing is same as X3_HmType=1.
											!	   4 : this type is for gantry mode , and the motion for homing is same as X3_HmType=2.
X3_HmOffset = 0 								! X3_HmOffset (unit)
X3_HmVel = 100000								! the velocity for homing 	
X3_IndVel = 10000 								! the velocity for finding index
X3_multi_indHm=0							! multi index structure
											! value 0 : nomal Homing
											!	    1 : find the left limit in negative direction,then slowing leave the limit in positive direction,
											!			then slowing find the left limit in negative direction,then slowing find index in positive direction
X3_multi_indVel = 100						! (Do not modify)homing velocity of multi index structure
X3_CommutCurrent = 80						! Commutation excitation current.
X3_Yaw_CommutCurrent = 80					! Yaw axis Commutation excitation current.
!!*********************************** X3_axis Gantry mod ***************************************************!!
X3_IsFlexibleGantry = 1 						! 0: Stiff Gantry ; 1: Flexible Gantry (X3_IsGantryComove automatically set to 1 )
X3_IsGantryComove = 0						! 0: Search limit and index by X3_axis
											! 1: Search limit and index by X3_axis and X3_Yaw_axis comove
X3_Yawlock = 0						! X3_Yaw_axis follow position
X3_M_XCURI = 45								! X3_axis XCURI
X3_M_XCURV = 85								! X3_axis XCURV
X3_S_XCURI = 15							! X3_Yaw_axis XCURI
X3_S_XCURV = 15								! X3_Yaw_axis XCURV

X3_IsUsingGantryHmGain = 1					! 0 : Homing and production using same gain 
											! 1 : Homing and production using different gain 
!------------------Homing and production gain set (Set by X3_IsUsingGantryHmGain = 1)-----------------!
X3_GantryHmM_SLPKP = 100						! X3_axis homing gain
X3_GantryHmM_SLVKP = 250		
X3_GantryHmM_SLVKI = 200
X3_GantryHmS_SLPKP = 100						! X3_Yaw_axis homing gain
X3_GantryHmS_SLVKP = 250
X3_GantryHmS_SLVKI = 200
X3_GantryProdM_SLPKP = 200						! X3_axis production gain
X3_GantryProdM_SLVKP = 300
X3_GantryProdM_SLVKI = 240
X3_GantryProdS_SLPKP = 80						! X3_Yaw_axis production gain
X3_GantryProdS_SLVKP = 120
X3_GantryProdS_SLVKI = 220
!!**************** Configuration of 1D Error Compensation*****************************************************!!
X3_ErrCompensation = 1						! 0 : without compensation  ; 1 : turn on the compensation after homing completed 
X3_ErrCompIniPos = 0							! the initial position of error compensation
X3_ErrCompensationSpacing = 75000				! setting the spacing for error compensation 
!!**************** Configuration of Current Compensation for gantry mode ***************************************!!
X3_CurrentCompensation = 0					! Current Compensation
											! the value 0 : without current compensation.
											!           1 : Enable current compensation mode with exist current table. 
											!           2 : Execute the process of current table search after homing , and then 
											!               enable current compensation mode.
X3_CurrentCompensationIniPos = 0				! compensation start postion
X3_CurrentCompensationTravel = 1500000			! the stroke (unit) of CurrentCompensation
X3_CurrentCompensationSegment = 20			! the segment for current compensation.
X3_CurrentCompensationSettleTime = 3000		! time requiered for Yaw axis to take satisfactory position
X3_CurrentCompensationSpacing = X3_CurrentCompensationTravel / X3_CurrentCompensationSegment	 ! the spacing for current compensation (unit)
!!**********************************************************************************************************!!
!!######################################################################################################################################## 

!!**************************************************************************************************************************************!!
!!************************************************************ Main program ************************************************************!!

IF X3_HmType=0	
	MFLAGS(X3_axis).#HOME=0;	MFLAGS(X3_Yaw_axis).#HOME=0												! Customized homing
	CALL X3_HmType0
ELSEIF X3_HmType>=3 & X3_HmType<=4 			! Gantry Homing	
	MFLAGS(X3_axis).#HOME=0;	MFLAGS(X3_Yaw_axis).#HOME=0
	IF X3_HmType=3
		CALL X3_HmType3
	ELSEIF X3_HmType=4
		CALL X3_HmType4
	END
ELSE
	DISP"ERROR:The value of X3_HmType or X3_HiwinDriveHome is invalid!!"
	STOP
END

IF (X3_CurrentCompensation=1)
	DISP"Turn on the Current Compensation..."	
	CALL X3_TurnOnCurrentCompensation	
ELSEIF (X3_CurrentCompensation=2)
	CALL X3_CurrentCompensation	
ELSEIF (X3_CurrentCompensation=0)	
	ERRORUNMAP X3_Yaw_axis, ZONE0
END

IF X3_ErrCompensation = 1
	DISP "Enable the compensation mode."
	DISP "Execute the compensation prcoess......"
	CALL X3_ErrorCompensation	
ELSE
	DISP "Disable error compensation."
	ERRORUNMAP X3_axis, ZONE0
END 

ENABLE (X3_axis)	
TILL MST(X3_axis).#ENABLED & MST(X3_Yaw_axis).#ENABLED
WAIT 500
DISP"Go home......"	
PTP/EV X3_axis,0,X3_HmVel		
PTP/EV X3_Yaw_axis,0,X3_HmVel !Yaw lock s
MFLAGS(X3_axis).#HOME=1;	MFLAGS(X3_Yaw_axis).#HOME=1	

FDEF(X3_axis).#LL = 	1	;	FDEF(X3_Yaw_axis).#LL =  1			! turn on the response of reaching left limit
FDEF(X3_axis).#SRL = 1	;	FDEF(X3_Yaw_axis).#SRL = 1	 		! enable software right limit response
FDEF(X3_axis).#SLL = 1	;	FDEF(X3_Yaw_axis).#SLL = 1	 		! enable software left limit response
DISP"X3_axis Homing successful!!"	

STOP	

!!*************************************************************************************************************************************!!
!!************************************************************ Homing process	*******************************************************!!
X3_HmType0:
X3_GantryHomeStep = 0
IF X3_IsFlexibleGantry = 1 
	X3_IsGantryComove = 1										!Flexible gantry should comove
END

DISABLE (X3_axis,X3_Yaw_axis)	
TILL ^MST(X3_axis).#ENABLED & ^MST(X3_Yaw_axis).#ENABLED	
WAIT 500	
ERRORMAPOFF X3_axis, -1	;	ERRORMAPOFF X3_Yaw_axis, -1			! Close all X3_axis & X3_yaw_axis error compensation
MFLAGS(X3_axis).#GANTRY = 0	;	MFLAGS(X3_Yaw_axis).#GANTRY = 0	! turn off gantry mode (MFLAGS.25)
FDEF(X3_axis).#SRL = 0	;	FDEF(X3_Yaw_axis).#SRL = 0	 		! disable software right limit response
FDEF(X3_axis).#SLL = 0	;	FDEF(X3_Yaw_axis).#SLL = 0	 		! disable software left limit response

IF (^MFLAGS(X3_axis).#BRUSHOK & MFLAGS(X3_axis).#BRUSHL) 			! Confirm BRUSHOK
	ENABLE X3_axis		
	TILL MST(X3_axis).#ENABLED	
	COMMUT X3_axis,X3_CommutCurrent								! do commutation
	TILL MFLAGS(X3_axis).#BRUSHOK								! Wait for the commutation to complete, BRUSHOK is 1
	DISABLE X3_axis		
	TILL ^MST(X3_axis).#ENABLED	
END	
IF (^MFLAGS(X3_Yaw_axis).#BRUSHOK & MFLAGS(X3_Yaw_axis).#BRUSHL)	! Confirm BRUSHOK
	ENABLE X3_Yaw_axis		
	TILL MST(X3_Yaw_axis).#ENABLED
	COMMUT X3_Yaw_axis,X3_Yaw_CommutCurrent							! do commutation
	TILL MFLAGS(X3_Yaw_axis).#BRUSHOK							! Wait for the commutation to complete, BRUSHOK is 1
	DISABLE X3_Yaw_axis		
	TILL ^MST(X3_Yaw_axis).#ENABLED	
END	

DISABLE (X3_axis,X3_Yaw_axis)	
TILL ^MST(X3_axis).#ENABLED & ^MST(X3_Yaw_axis).#ENABLED	
WAIT 500	
MFLAGS(X3_axis).#OPEN =0 ;	MFLAGS(X3_Yaw_axis).#OPEN =0	 		! close loop control
FDEF(X3_axis).#LL = 	0	;	FDEF(X3_Yaw_axis).#LL =  0			! motor is not disable when left limit signal rising.

IF X3_IsUsingGantryHmGain=1
	CALL HmGain
END
								! Comove
ACC(X3_Yaw_axis)=ACC(X3_axis)									! X3_axis & X3_Yaw_axis should same motion profile
DEC(X3_Yaw_axis)=DEC(X3_axis)	
JERK(X3_Yaw_axis)=JERK(X3_axis)
XCURI(X3_Yaw_axis)=XCURI(X3_axis)	
XCURV(X3_Yaw_axis)=XCURV(X3_axis)	
SLPKP(X3_Yaw_axis)=SLPKP(X3_axis)
SLVKP(X3_Yaw_axis)=SLVKP(X3_axis)
SLVKI(X3_Yaw_axis)=SLVKI(X3_axis)
XCURI(X3_Yaw_axis)=XCURI(X3_axis)
XCURV(X3_Yaw_axis)=XCURV(X3_axis)
ENABLE (X3_axis,X3_Yaw_axis)
TILL MST(X3_axis).#ENABLED & MST(X3_Yaw_axis).#ENABLED	




PTP/VW X3_axis, 0, X3_HmVel ;
PTP/VW X3_Yaw_axis,X3_Yawlock, X3_HmVel ;


GO (X3_axis,X3_Yaw_axis)										! X3_axis & X3_Yaw_axis move same time

TILL ((APOS(X3_axis) = TPOS(X3_axis)) & (APOS(X3_Yaw_axis) = TPOS(X3_Yaw_axis)) & ^MST(X3_axis).#MOVE & ^MST(X3_Yaw_axis).#MOVE ), 20000 ;
WAIT 50 ;

IF ^MST(X3_axis).#MOVE & ^MST(X3_Yaw_axis).#MOVE
	! Deactivate closed-loop and till Zb_axis_CLFlags turn off.
	WAIT 500 ;
ELSE
	HALT(X3_axis,X3_Yaw_axis)
	DISP " move to initial position timeout." ;
	STOP(6)
END	

	
DISP"Already found the index!!"	

DISABLE (X3_axis,X3_Yaw_axis)	
TILL ^MST(X3_axis).#ENABLED & ^MST(X3_Yaw_axis).#ENABLED
wait 3000

MFLAGS(X3_axis).#GANTRY = 1	;	MFLAGS(X3_Yaw_axis).#GANTRY = 1	! turn on gantry mode
XCURI(X3_axis) = X3_M_XCURI	;	XCURI(X3_Yaw_axis) = X3_S_XCURI
XCURV(X3_axis) = X3_M_XCURV	;	XCURV(X3_Yaw_axis) = X3_S_XCURV
IF X3_IsUsingGantryHmGain=1
	CALL ProdGain
END

!Customized
RET
STOP
!------------------------------------------------------------------X3_HmType3--------------------------------------------------------------------------------------
X3_HmType3:

RET	
STOP
!------------------------------------------------------------------X3_HmType4--------------------------------------------------------------------------------------
X3_HmType4:


RET	
STOP
!!****************************************************** Error Compensation Process ***************************************************!!
X3_ErrorCompensation:
!---------- X3_axis Error Compensation Table ------------!
X3_ErrTable(0)=	0	;
X3_ErrTable(1)=	0.1	;
X3_ErrTable(2)=	2.8	;
X3_ErrTable(3)=	5.8	;
X3_ErrTable(4)=	6.5	;
X3_ErrTable(5)=	7.7	;
X3_ErrTable(6)=	10.8	;
X3_ErrTable(7)=	14.4	;
X3_ErrTable(8)=	17.2	;
X3_ErrTable(9)=	20.3	;
X3_ErrTable(10)=	25.2	;
X3_ErrTable(11)=	27.2	;
X3_ErrTable(12)=	29.4	;
X3_ErrTable(13)=	28.6	;
X3_ErrTable(14)=	28.6	;
X3_ErrTable(15)=	29.7	;
X3_ErrTable(16)=	30.9	;
X3_ErrTable(17)=	31.7	;
X3_ErrTable(18)=	34.1	;
X3_ErrTable(19)=	35.4	;
X3_ErrTable(20)=	36.4	;

!-------------------------------------------------------!
X3_ErrTableIndex = 0
WHILE X3_ErrTableIndex < SIZEOF(X3_ErrTable)
	X3_ErrTable(X3_ErrTableIndex) = -X3_ErrTable(X3_ErrTableIndex)
	X3_ErrTableIndex = X3_ErrTableIndex + 1
END
ERRORUNMAP X3_axis, ZONE0
ERRORMAP1D X3_axis, ZONE0, X3_ErrCompIniPos, X3_ErrCompensationSpacing, X3_ErrTable
ERRORMAPON X3_axis, ZONE0

WAIT 500	
DISP "Cmpensation Procces's completed!"

RET 
STOP

!!*************************************************************************************************************************************!!
!!********************************************************* Current Compensation ******************************************************!!
X3_CurrentCompensation:
ENABLE X3_axis
TILL MST(X3_axis).#ENABLED & MST(X3_Yaw_axis).#ENABLED 
PTP/EV X3_axis,X3_CurrentCompensationIniPos,X3_HmVel
DISABLE X3_axis
TILL ^MST(X3_axis).#ENABLED & ^MST(X3_Yaw_axis).#ENABLED 
!MFLAGS(X3_Yaw_axis).#OPEN = 1		
SLPKP(X3_Yaw_axis)=0;
ENABLE X3_axis
TILL MST(X3_axis).#ENABLED & MST(X3_Yaw_axis).#ENABLED 

PTP/EV X3_axis,X3_CurrentCompensationIniPos,X3_HmVel
WAIT X3_CurrentCompensationSettleTime
X3_CurrentCompensationIndex = 0

!Move positive
DISP"Y error table search sequence in positive direction......"
WHILE X3_CurrentCompensationIndex <= X3_CurrentCompensationSegment
	DISP"Y FPOS=%f , Y Yaw Offset = %f ",FPOS(X3_axis),FPOS(X3_Yaw_axis)
	X3_CurrentTableTemp(0)(X3_CurrentCompensationIndex) = FPOS(X3_Yaw_axis)
	IF X3_CurrentCompensationIndex < X3_CurrentCompensationSegment
		PTP/ERV X3_axis,X3_CurrentCompensationSpacing,X3_HmVel		
		WAIT X3_CurrentCompensationSettleTime
	END
	X3_CurrentCompensationIndex = X3_CurrentCompensationIndex + 1	
END

PTP/EV X3_axis,X3_CurrentCompensationIniPos + X3_CurrentCompensationTravel,X3_HmVel
WAIT X3_CurrentCompensationSettleTime
X3_CurrentCompensationIndex = X3_CurrentCompensationSegment
!Move negative unfinished
DISP"Y error table search sequence in negative direction......"
WHILE X3_CurrentCompensationIndex >= 0
	DISP"Y FPOS=%f , Y Yaw Offset = %f ",FPOS(X3_axis),FPOS(X3_Yaw_axis)
	X3_CurrentTableTemp(1)(X3_CurrentCompensationIndex) = FPOS(X3_Yaw_axis)
	IF X3_CurrentCompensationIndex > 0
		PTP/ERV X3_axis,-X3_CurrentCompensationSpacing,X3_HmVel		
		WAIT X3_CurrentCompensationSettleTime
	END
	X3_CurrentCompensationIndex = X3_CurrentCompensationIndex - 1	
END

X3_CurrentCompensationIndex = 0
WHILE X3_CurrentCompensationIndex <= X3_CurrentCompensationSegment
	X3_CurrentTable(X3_CurrentCompensationIndex)	=	(X3_CurrentTableTemp(0)(X3_CurrentCompensationIndex) + X3_CurrentTableTemp(1)(X3_CurrentCompensationIndex))/2
	X3_CurrentCompensationIndex = X3_CurrentCompensationIndex + 1
END

WRITE X3_CurrentTable,X3_CurrentTable
WAIT 1500	
PTP/EV X3_axis,X3_CurrentCompensationIniPos,X3_HmVel
WAIT 500	

X3_TurnOnCurrentCompensation:
DISABLE X3_axis
TILL ^MST(X3_axis).#ENABLED & ^MST(X3_Yaw_axis).#ENABLED
MFLAGS(X3_Yaw_axis).#OPEN = 0
ENABLE (X3_axis,X3_Yaw_axis)
TILL MST(X3_axis).#ENABLED & MST(X3_Yaw_axis).#ENABLED
READ X3_CurrentTable,X3_CurrentTable
ERRORUNMAP X3_Yaw_axis, ZONE0
ERRORMAP1D X3_Yaw_axis, ZONE0, X3_CurrentCompensationIniPos, X3_CurrentCompensationSpacing, X3_CurrentTable
ERRORMAPON X3_Yaw_axis, ZONE0
DISP"Current compensaton completed!"
RET 
STOP
!!*************************************************************************************************************************************!!
!**************************************Gains for homing********************************************!
HmGain:

SLPKP(X3_axis)= X3_GantryHmM_SLPKP	
SLVKP(X3_axis)= X3_GantryHmM_SLVKP	
SLVKI(X3_axis)= X3_GantryHmM_SLVKI	

SLPKP(X3_Yaw_axis)= X3_GantryHmS_SLPKP	
SLVKP(X3_Yaw_axis)= X3_GantryHmS_SLVKP	
SLVKI(X3_Yaw_axis)= X3_GantryHmS_SLVKI	


RET	
STOP
!**************************************Gains for production*****************************************!
ProdGain:

SLPKP(X3_axis)= X3_GantryProdM_SLPKP	
SLVKP(X3_axis)= X3_GantryProdM_SLVKP	
SLVKI(X3_axis)= X3_GantryProdM_SLVKI	

SLPKP(X3_Yaw_axis)= X3_GantryProdS_SLPKP	
SLVKP(X3_Yaw_axis)= X3_GantryProdS_SLVKP	
SLVKI(X3_Yaw_axis)= X3_GantryProdS_SLVKI	

RET
STOP
!!*************************************************************************************************************************************!!


!!#############################################################################################################################

ON X3_GantryHomeStep = 1 & X3_IsFlexibleGantry = 1 & FAULT(X3_axis).#LL
	HALT X3_axis
RET

ON X3_GantryHomeStep = 1 & X3_IsFlexibleGantry = 1 & FAULT(X3_Yaw_axis).#LL
	HALT X3_Yaw_axis
RET

ON X3_GantryHomeStep = 2 & X3_IsFlexibleGantry = 1 & ^FAULT(X3_axis).#LL
	HALT X3_axis
RET

ON X3_GantryHomeStep = 2 & X3_IsFlexibleGantry = 1 & ^FAULT(X3_Yaw_axis).#LL
	HALT X3_Yaw_axis
RET


ON MFLAGS(X3_axis).#HOME=1 & MFLAGS(X3_Yaw_axis).#HOME=1 & TPOS(X3_axis) < SLLIMIT(X3_axis) 
	IF( FDEF(X3_axis).#SLL=1 & FMASK(X3_axis).#SLL=1 & ^(GMTYPE(X3_axis)=5))
		KILL X3_axis,5016	!Software Left Limit
		TPOS(X3_axis)=FPOS(X3_axis)
		DISP "TPOS(X3_axis) < SLLIMIT(X3_axis)"
	END
RET

ON MFLAGS(X3_axis).#HOME=1 & MFLAGS(X3_Yaw_axis).#HOME=1 & TPOS(X3_axis) > SRLIMIT(X3_axis) 
	IF(FDEF(X3_axis).#SRL=1 & FMASK(X3_axis).#SRL=1 & ^(GMTYPE(X3_axis)=5))
		KILL X3_axis,5015	!Software Right Limit
		TPOS(X3_axis)=FPOS(X3_axis)
		DISP "TPOS(X3_axis) > SRLIMIT(X3_axis)"
	END
RET

ON MFLAGS(X3_axis).#HOME=1 & MFLAGS(X3_Yaw_axis).#HOME=1 & TPOS(X3_Yaw_axis) < SLLIMIT(X3_Yaw_axis) 
	IF( FDEF(X3_Yaw_axis).#SLL=1 & FMASK(X3_Yaw_axis).#SLL=1 & ^(GMTYPE(X3_Yaw_axis)=5))
		KILL X3_Yaw_axis,5016	!Software Left Limit
		TPOS(X3_Yaw_axis)=FPOS(X3_Yaw_axis)
		DISP "TPOS(X3_Yaw_axis) < SLLIMIT(X3_Yaw_axis)"
	END
RET

ON MFLAGS(X3_axis).#HOME=1 & MFLAGS(X3_Yaw_axis).#HOME=1 & TPOS(X3_Yaw_axis) > SRLIMIT(X3_Yaw_axis) 
	IF(FDEF(X3_Yaw_axis).#SRL=1 & FMASK(X3_Yaw_axis).#SRL=1 & ^(GMTYPE(X3_Yaw_axis)=5))
		KILL X3_Yaw_axis,5015	!Software Right Limit
		TPOS(X3_Yaw_axis)=FPOS(X3_Yaw_axis)
		DISP "TPOS(X3_Yaw_axis) > SRLIMIT(X3_Yaw_axis)"
	END
RET



ON MFLAGS(X3_axis).#HOME=0 & MFLAGS(X3_Yaw_axis).#HOME=0 & RVEL(X3_axis) > XVEL(X3_axis)*0.5 & ^MST(X3_axis).#INPOS
	IMM VEL(X3_axis) = XVEL(X3_axis)*0.45 
RET

ON MFLAGS(X3_axis).#HOME=0 & MFLAGS(X3_Yaw_axis).#HOME=0 & RVEL(X3_axis) < -XVEL(X3_axis)*0.5 & ^MST(X3_axis).#INPOS
	IMM VEL(X3_axis) = -XVEL(X3_axis)*0.45 
RET

ON MFLAGS(X3_axis).#HOME=0 & MFLAGS(X3_Yaw_axis).#HOME=0 & RVEL(X3_Yaw_axis) > XVEL(X3_Yaw_axis)*0.5 & ^MST(X3_Yaw_axis).#INPOS
	IMM VEL(X3_Yaw_axis) = XVEL(X3_Yaw_axis)*0.45 
RET

ON MFLAGS(X3_axis).#HOME=0 & MFLAGS(X3_Yaw_axis).#HOME=0 & RVEL(X3_Yaw_axis) < -XVEL(X3_Yaw_axis)*0.5 & ^MST(X3_Yaw_axis).#INPOS
	IMM VEL(X3_Yaw_axis) = -XVEL(X3_Yaw_axis)*0.45 
RET

AUTOEXEC:
	!X3_init_pos = -1550617		X3_Yaw_init_pos = -1550680
	X3_Yaw_Offset = 3000 !2023.11.13
	X3_init_pos = -1553833;		X3_Yaw_init_pos = -1556405 + X3_Yaw_Offset !2023.11.08 
	MFLAGS(X3_axis).#HOME=0;	 		MFLAGS(X3_Yaw_axis).#HOME=0
	MFLAGS(X3_axis).#GANTRY=0 ; 		MFLAGS(X3_Yaw_axis).#GANTRY=0
	E_TYPE(X3_axis)=13 ; 				E_TYPE(X3_Yaw_axis)=13 ;
	E_AOFFS(X3_axis) = X3_init_pos ; 	E_AOFFS(X3_Yaw_axis) = X3_Yaw_init_pos ;  	
STOP

#7
!PNAME=
!PDESC=
! Z1_axis Gantry-axis_ACS_Drive_Homing_Process_VER1.5
!!****** Setting Parameter ******!!
LOCAL REAL Z1_HmType,Z1_multi_indHm,Z1_multi_indVel
LOCAL REAL Z1_HmVel,Z1_IndVel,Z1_HmOffset	
LOCAL INT Z1_ErrCompensation,Z1_ErrCompensationSpacing,Z1_ErrCompIniPos
LOCAL INT Z1_CurrentCompensation,Z1_CurrentCompensationIndex,Z1_CurrentCompensationSettleTime
LOCAL REAL Z1_CurrentTableTemp(2)(11)
LOCAL REAL Z1_CurrentCompensationTravel,Z1_CurrentCompensationSpacing,Z1_CurrentCompensationSegment,Z1_CurrentCompensationIniPos
LOCAL INT ZONE0,Z1_ErrTableIndex
LOCAL REAL Z1_GantryHmM_SLPKP,Z1_GantryHmM_SLVKP,Z1_GantryHmM_SLVKI,Z1_GantryHmS_SLPKP,Z1_GantryHmS_SLVKP,Z1_GantryHmS_SLVKI
LOCAL REAL Z1_GantryProdM_SLPKP,Z1_GantryProdM_SLVKP,Z1_GantryProdM_SLVKI,Z1_GantryProdS_SLPKP,Z1_GantryProdS_SLVKP,Z1_GantryProdS_SLVKI
LOCAL REAL Z1_M_XCURI,Z1_M_XCURV,Z1_S_XCURI,Z1_S_XCURV
LOCAL INT Z1_IsUsingGantryHmGain,Z1_IsFlexibleGantry,Z1_IsGantryComove,Z1_EtherCATIndex,Z1_GantryHomeStep
LOCAL REAL Z1_Yawlock
LOCAL REAL Z1_CommutCurrent,Z1_Yaw_CommutCurrent
LOCAL INT Z1_Yaw_Offset !2023.11.13
!!################ Basic Settings ######################################################################################################
Z1_HmType = 0 								!the method of homing
           									!value 0 : Customized homing											
											!	   3 : this type is for gantry mode , and the motion for homing is same as Z1_HmType=1.
											!	   4 : this type is for gantry mode , and the motion for homing is same as Z1_HmType=2.
Z1_HmOffset = 0 								! Z1_HmOffset (unit)
Z1_HmVel = 30000								! the velocity for homing 	
Z1_IndVel = 10000 								! the velocity for finding index
Z1_multi_indHm=0							! multi index structure
											! value 0 : nomal Homing
											!	    1 : find the left limit in negative direction,then slowing leave the limit in positive direction,
											!			then slowing find the left limit in negative direction,then slowing find index in positive direction
Z1_multi_indVel = 100						! (Do not modify)homing velocity of multi index structure
Z1_CommutCurrent = 80						! Commutation excitation current.
Z1_Yaw_CommutCurrent = 80					! Yaw axis Commutation excitation current.
!!*********************************** Z1_axis Gantry mod ***************************************************!!
Z1_IsFlexibleGantry = 0 						! 0: Stiff Gantry ; 1: Flexible Gantry (Z1_IsGantryComove automatically set to 1 )
Z1_IsGantryComove = 0						! 0: Search limit and index by Z1_axis
											! 1: Search limit and index by Z1_axis and Z1_Yaw_axis comove
Z1_Yawlock = 0								! Z1_Yaw_axis follow position
Z1_M_XCURI = 45								! Z1_axis XCURI
Z1_M_XCURV = 90								! Z1_axis XCURV
Z1_S_XCURI = 10							! Z1_Yaw_axis XCURI
Z1_S_XCURV = 10								! Z1_Yaw_axis XCURV

Z1_IsUsingGantryHmGain = 1					! 0 : Homing and production using same gain 
											! 1 : Homing and production using different gain 
!------------------Homing and production gain set (Set by Z1_IsUsingGantryHmGain = 1)-----------------!
Z1_GantryHmM_SLPKP = 120						! Z1_axis homing gain
Z1_GantryHmM_SLVKP = 80		
Z1_GantryHmM_SLVKI = 120
Z1_GantryHmS_SLPKP = 120						! Z1_Yaw_axis homing gain
Z1_GantryHmS_SLVKP = 80
Z1_GantryHmS_SLVKI = 120
Z1_GantryProdM_SLPKP = 150						! Z1_axis production gain
Z1_GantryProdM_SLVKP = 240
Z1_GantryProdM_SLVKI = 150
Z1_GantryProdS_SLPKP = 70						! Z1_Yaw_axis production gain
Z1_GantryProdS_SLVKP = 80
Z1_GantryProdS_SLVKI = 80
!!**************** Configuration of 1D Error Compensation*****************************************************!!
Z1_ErrCompensation = 1						! 0 : without compensation  ; 1 : turn on the compensation after homing completed 
Z1_ErrCompIniPos = 0							! the initial position of error compensation
Z1_ErrCompensationSpacing = 15000				! setting the spacing for error compensation 
!!**************** Configuration of Current Compensation for gantry mode ***************************************!!
Z1_CurrentCompensation = 1					! Current Compensation
											! the value 0 : without current compensation.
											!           1 : Enable current compensation mode with exist current table. 
											!           2 : Execute the process of current table search after homing , and then 
											!               enable current compensation mode.
Z1_CurrentCompensationIniPos = 0				! compensation start postion
Z1_CurrentCompensationTravel = 150000			! the stroke (unit) of CurrentCompensation
Z1_CurrentCompensationSegment = 10			! the segment for current compensation.
Z1_CurrentCompensationSettleTime = 3000		! time requiered for Yaw axis to take satisfactory position
Z1_CurrentCompensationSpacing = Z1_CurrentCompensationTravel / Z1_CurrentCompensationSegment	 ! the spacing for current compensation (unit)
!!**********************************************************************************************************!!
!!######################################################################################################################################## 

!!**************************************************************************************************************************************!!
!!************************************************************ Main program ************************************************************!!

IF Z1_HmType=0													! Customized homing
	MFLAGS(Z1_axis).#HOME=0;	MFLAGS(Z1_Yaw_axis).#HOME=0
	CALL Z1_HmType0
ELSEIF Z1_HmType>=3 & Z1_HmType<=4 			! Gantry Homing	
	MFLAGS(Z1_axis).#HOME=0;	MFLAGS(Z1_Yaw_axis).#HOME=0
	IF Z1_HmType=3
		CALL Z1_HmType3
	ELSEIF Z1_HmType=4
		CALL Z1_HmType4
	END
ELSE
	DISP"ERROR:The value of Z1_HmType or Z1_HiwinDriveHome is invalid!!"
	STOP
END

IF (Z1_CurrentCompensation=1 & Z1_HmType>=3)
	DISP"Turn on the Current Compensation..."	
	CALL Z1_TurnOnCurrentCompensation	
ELSEIF (Z1_CurrentCompensation=2 &  Z1_HmType>=3)
	CALL Z1_CurrentCompensation	
ELSEIF (Z1_CurrentCompensation=0 &  Z1_HmType>=3)	
	ERRORUNMAP Z1_Yaw_axis, ZONE0
END

IF Z1_ErrCompensation = 1
	DISP "Enable the compensation mode."
	DISP "Execute the compensation prcoess......"
	CALL Z1_ErrorCompensation	
ELSE
	DISP "Disable error compensation."
	ERRORUNMAP Z1_axis, ZONE0
END 

ENABLE (Z1_axis)	
TILL MST(Z1_axis).#ENABLED & MST(Z1_Yaw_axis).#ENABLED
WAIT 500
DISP"Go home......"	
PTP/EV Z1_axis,0,Z1_HmVel		
PTP/EV Z1_Yaw_axis,0,Z1_HmVel !Yaw lock s
MFLAGS(Z1_axis).#HOME=1;	MFLAGS(Z1_Yaw_axis).#HOME=1	

FDEF(Z1_axis).#LL = 	1	;	FDEF(Z1_Yaw_axis).#LL =  1			! turn on the response of reaching left limit
FDEF(Z1_axis).#SRL = 1	;	FDEF(Z1_Yaw_axis).#SRL = 1	 		! enable software right limit response
FDEF(Z1_axis).#SLL = 1	;	FDEF(Z1_Yaw_axis).#SLL = 1	 		! enable software left limit response
DISP"Homing successful!!"	

STOP	

!!*************************************************************************************************************************************!!
!!************************************************************ Homing process	*******************************************************!!
Z1_HmType0:
Z1_GantryHomeStep = 0
IF Z1_IsFlexibleGantry = 1 
	Z1_IsGantryComove = 1										!Flexible gantry should comove
END

DISABLE (Z1_axis,Z1_Yaw_axis)	
TILL ^MST(Z1_axis).#ENABLED & ^MST(Z1_Yaw_axis).#ENABLED	
WAIT 500	
ERRORMAPOFF Z1_axis, -1	;	ERRORMAPOFF Z1_Yaw_axis, -1			! Close all Z1_axis & Z1_yaw_axis error compensation
MFLAGS(Z1_axis).#GANTRY = 0	;	MFLAGS(Z1_Yaw_axis).#GANTRY = 0	! turn off gantry mode (MFLAGS.25)
FDEF(Z1_axis).#SRL = 0	;	FDEF(Z1_Yaw_axis).#SRL = 0	 		! disable software right limit response
FDEF(Z1_axis).#SLL = 0	;	FDEF(Z1_Yaw_axis).#SLL = 0	 		! disable software left limit response

IF (^MFLAGS(Z1_axis).#BRUSHOK & MFLAGS(Z1_axis).#BRUSHL) 			! Confirm BRUSHOK
	ENABLE Z1_axis		
	TILL MST(Z1_axis).#ENABLED	
	COMMUT Z1_axis,Z1_CommutCurrent								! do commutation
	TILL MFLAGS(Z1_axis).#BRUSHOK								! Wait for the commutation to complete, BRUSHOK is 1
	DISABLE Z1_axis		
	TILL ^MST(Z1_axis).#ENABLED	
END	
IF (^MFLAGS(Z1_Yaw_axis).#BRUSHOK & MFLAGS(Z1_Yaw_axis).#BRUSHL)	! Confirm BRUSHOK
	ENABLE Z1_Yaw_axis		
	TILL MST(Z1_Yaw_axis).#ENABLED
	COMMUT Z1_Yaw_axis,Z1_Yaw_CommutCurrent							! do commutation
	TILL MFLAGS(Z1_Yaw_axis).#BRUSHOK							! Wait for the commutation to complete, BRUSHOK is 1
	DISABLE Z1_Yaw_axis		
	TILL ^MST(Z1_Yaw_axis).#ENABLED	
END	

DISABLE (Z1_axis,Z1_Yaw_axis)	
TILL ^MST(Z1_axis).#ENABLED & ^MST(Z1_Yaw_axis).#ENABLED	
WAIT 500	
MFLAGS(Z1_axis).#OPEN =0 ;	MFLAGS(Z1_Yaw_axis).#OPEN =0	 		! close loop control
FDEF(Z1_axis).#LL = 	0	;	FDEF(Z1_Yaw_axis).#LL =  0			! motor is not disable when left limit signal rising.

IF Z1_IsUsingGantryHmGain=1
	CALL HmGain
END
								! Comove
ACC(Z1_Yaw_axis)=ACC(Z1_axis)									! Z1_axis & Z1_Yaw_axis should same motion profile
DEC(Z1_Yaw_axis)=DEC(Z1_axis)	
JERK(Z1_Yaw_axis)=JERK(Z1_axis)
XCURI(Z1_Yaw_axis)=XCURI(Z1_axis)	
XCURV(Z1_Yaw_axis)=XCURV(Z1_axis)	
SLPKP(Z1_Yaw_axis)=SLPKP(Z1_axis)
SLVKP(Z1_Yaw_axis)=SLVKP(Z1_axis)
SLVKI(Z1_Yaw_axis)=SLVKI(Z1_axis)
ENABLE (Z1_axis,Z1_Yaw_axis)
TILL MST(Z1_axis).#ENABLED & MST(Z1_Yaw_axis).#ENABLED	


PTP/VW Z1_axis, 0, Z1_HmVel ;
PTP/VW Z1_Yaw_axis,0, Z1_HmVel ;


GO (Z1_axis,Z1_Yaw_axis)										! Z1_axis & Z1_Yaw_axis move same time

TILL ((APOS(Z1_axis) = TPOS(Z1_axis)) & (APOS(Z1_Yaw_axis) = TPOS(Z1_Yaw_axis)) & ^MST(Z1_axis).#MOVE & ^MST(Z1_Yaw_axis).#MOVE ), 10000 ;
WAIT 50 ;

IF ^MST(Z1_axis).#MOVE & ^MST(Z1_Yaw_axis).#MOVE
	! Deactivate closed-loop and till Zb_axis_CLFlags turn off.
	WAIT 2000 ;
ELSE
	DISP " move to initial position timeout." ;
	STOP(7)
END	

	
DISP"Already found the index!!"	

SET FPOS(Z1_axis)=FPOS(Z1_axis)-IND(Z1_axis)-Z1_HmOffset	
SET FPOS(Z1_Yaw_axis)=FPOS(Z1_Yaw_axis)-IND(Z1_Yaw_axis) - Z1_HmOffset	+ Z1_Yawlock
DISABLE (Z1_axis,Z1_Yaw_axis)	
TILL ^MST(Z1_axis).#ENABLED & ^MST(Z1_Yaw_axis).#ENABLED
MFLAGS(Z1_axis).#GANTRY = 1	;	MFLAGS(Z1_Yaw_axis).#GANTRY = 1	! turn on gantry mode
XCURI(Z1_axis) = Z1_M_XCURI	;	XCURI(Z1_Yaw_axis) = Z1_S_XCURI
XCURV(Z1_axis) = Z1_M_XCURV	;	XCURV(Z1_Yaw_axis) = Z1_S_XCURV
IF Z1_IsUsingGantryHmGain=1
	CALL ProdGain
END

!Customized
RET
STOP
!------------------------------------------------------------------Z1_HmType3--------------------------------------------------------------------------------------
Z1_HmType3:

RET	
STOP
!------------------------------------------------------------------Z1_HmType4--------------------------------------------------------------------------------------
Z1_HmType4:


RET	
STOP
!!****************************************************** Error Compensation Process ***************************************************!!
Z1_ErrorCompensation:
!---------- Z1_axis Error Compensation Table ------------!
Z1_ErrTable(0) =  0	;     
Z1_ErrTable(1) =  -1.1	;
Z1_ErrTable(2) =  -2.9	;
Z1_ErrTable(3) = -1.4	;
Z1_ErrTable(4) =  1.0	;
Z1_ErrTable(5) =  0.5	;
Z1_ErrTable(6) = -0.6	;
Z1_ErrTable(7) =  1.4	;
Z1_ErrTable(8) =  5.5	;
Z1_ErrTable(9) =  6.9	;
Z1_ErrTable(10) = 7.1	;

!-------------------------------------------------------!
Z1_ErrTableIndex = 0
WHILE Z1_ErrTableIndex < SIZEOF(Z1_ErrTable)
	Z1_ErrTable(Z1_ErrTableIndex) = -Z1_ErrTable(Z1_ErrTableIndex)
	Z1_ErrTableIndex = Z1_ErrTableIndex + 1
END
ERRORUNMAP Z1_axis, ZONE0
ERRORMAP1D Z1_axis, ZONE0, Z1_ErrCompIniPos, Z1_ErrCompensationSpacing, Z1_ErrTable
ERRORMAPON Z1_axis, ZONE0

WAIT 500	
DISP "Cmpensation Procces's completed!"

RET 
STOP

!!*************************************************************************************************************************************!!
!!********************************************************* Current Compensation ******************************************************!!
Z1_CurrentCompensation:
ENABLE Z1_axis
TILL MST(Z1_axis).#ENABLED & MST(Z1_Yaw_axis).#ENABLED 
PTP/EV Z1_axis,Z1_CurrentCompensationIniPos,Z1_HmVel
DISABLE Z1_axis
TILL ^MST(Z1_axis).#ENABLED & ^MST(Z1_Yaw_axis).#ENABLED 
MFLAGS(Z1_Yaw_axis).#OPEN = 1		
ENABLE Z1_axis
TILL MST(Z1_axis).#ENABLED & MST(Z1_Yaw_axis).#ENABLED 

PTP/EV Z1_axis,Z1_CurrentCompensationIniPos,Z1_HmVel
WAIT Z1_CurrentCompensationSettleTime
Z1_CurrentCompensationIndex = 0
!Move positive
DISP"Y error table search sequence in positive direction......"
WHILE Z1_CurrentCompensationIndex <= Z1_CurrentCompensationSegment
	DISP"Y FPOS=%f , Y Yaw Offset = %f ",FPOS(Z1_axis),FPOS(Z1_Yaw_axis)
	Z1_CurrentTableTemp(0)(Z1_CurrentCompensationIndex) = FPOS(Z1_Yaw_axis)
	IF Z1_CurrentCompensationIndex < Z1_CurrentCompensationSegment
		PTP/ERV Z1_axis,Z1_CurrentCompensationSpacing,Z1_HmVel		
		WAIT Z1_CurrentCompensationSettleTime
	END
	Z1_CurrentCompensationIndex = Z1_CurrentCompensationIndex + 1	
END

PTP/EV Z1_axis,Z1_CurrentCompensationIniPos + Z1_CurrentCompensationTravel,Z1_HmVel
WAIT Z1_CurrentCompensationSettleTime
Z1_CurrentCompensationIndex = Z1_CurrentCompensationSegment
!Move negative unfinished
DISP"Y error table search sequence in negative direction......"
WHILE Z1_CurrentCompensationIndex >= 0
	DISP"Y FPOS=%f , Y Yaw Offset = %f ",FPOS(Z1_axis),FPOS(Z1_Yaw_axis)
	Z1_CurrentTableTemp(1)(Z1_CurrentCompensationIndex) = FPOS(Z1_Yaw_axis)
	IF Z1_CurrentCompensationIndex > 0
		PTP/ERV Z1_axis,-Z1_CurrentCompensationSpacing,Z1_HmVel		
		WAIT Z1_CurrentCompensationSettleTime
	END
	Z1_CurrentCompensationIndex = Z1_CurrentCompensationIndex - 1	
END

Z1_CurrentCompensationIndex = 0
WHILE Z1_CurrentCompensationIndex <= Z1_CurrentCompensationSegment
	Z1_CurrentTable(Z1_CurrentCompensationIndex)	=	(Z1_CurrentTableTemp(0)(Z1_CurrentCompensationIndex) + Z1_CurrentTableTemp(1)(Z1_CurrentCompensationIndex))/2
	Z1_CurrentCompensationIndex = Z1_CurrentCompensationIndex + 1
END

WRITE Z1_CurrentTable,Z1_CurrentTable
WAIT 1500	
PTP/EV Z1_axis,Z1_CurrentCompensationIniPos,Z1_HmVel
WAIT 500	

Z1_TurnOnCurrentCompensation:
DISABLE Z1_axis
TILL ^MST(Z1_axis).#ENABLED & ^MST(Z1_Yaw_axis).#ENABLED
MFLAGS(Z1_Yaw_axis).#OPEN = 0
ENABLE (Z1_axis,Z1_Yaw_axis)
TILL MST(Z1_axis).#ENABLED & MST(Z1_Yaw_axis).#ENABLED
READ Z1_CurrentTable,Z1_CurrentTable
ERRORUNMAP Z1_Yaw_axis, ZONE0
ERRORMAP1D Z1_Yaw_axis, ZONE0, Z1_CurrentCompensationIniPos, Z1_CurrentCompensationSpacing, Z1_CurrentTable
ERRORMAPON Z1_Yaw_axis, ZONE0
DISP"Current compensaton completed!"
RET 
STOP
!!*************************************************************************************************************************************!!
!**************************************Gains for homing********************************************!
HmGain:

SLPKP(Z1_axis)= Z1_GantryHmM_SLPKP	
SLVKP(Z1_axis)= Z1_GantryHmM_SLVKP	
SLVKI(Z1_axis)= Z1_GantryHmM_SLVKI	

SLPKP(Z1_Yaw_axis)= Z1_GantryHmS_SLPKP	
SLVKP(Z1_Yaw_axis)= Z1_GantryHmS_SLVKP	
SLVKI(Z1_Yaw_axis)= Z1_GantryHmS_SLVKI	


RET	
STOP
!**************************************Gains for production*****************************************!
ProdGain:

SLPKP(Z1_axis)= Z1_GantryProdM_SLPKP	
SLVKP(Z1_axis)= Z1_GantryProdM_SLVKP	
SLVKI(Z1_axis)= Z1_GantryProdM_SLVKI	

SLPKP(Z1_Yaw_axis)= Z1_GantryProdS_SLPKP	
SLVKP(Z1_Yaw_axis)= Z1_GantryProdS_SLVKP	
SLVKI(Z1_Yaw_axis)= Z1_GantryProdS_SLVKI	

RET
STOP
!!*************************************************************************************************************************************!!


!!#############################################################################################################################

ON Z1_GantryHomeStep = 1 & Z1_IsFlexibleGantry = 1 & FAULT(Z1_axis).#LL
	HALT Z1_axis
RET

ON Z1_GantryHomeStep = 1 & Z1_IsFlexibleGantry = 1 & FAULT(Z1_Yaw_axis).#LL
	HALT Z1_Yaw_axis
RET

ON Z1_GantryHomeStep = 2 & Z1_IsFlexibleGantry = 1 & ^FAULT(Z1_axis).#LL
	HALT Z1_axis
RET

ON Z1_GantryHomeStep = 2 & Z1_IsFlexibleGantry = 1 & ^FAULT(Z1_Yaw_axis).#LL
	HALT Z1_Yaw_axis
RET


ON MFLAGS(Z1_axis).#HOME=1 & MFLAGS(Z1_Yaw_axis).#HOME=1 & TPOS(Z1_axis) < SLLIMIT(Z1_axis) 
	IF( FDEF(Z1_axis).#SLL=1 & FMASK(Z1_axis).#SLL=1 & ^(GMTYPE(Z1_axis)=5))
		KILL Z1_axis,5016	!Software Left Limit
		TPOS(Z1_axis)=FPOS(Z1_axis)
		DISP "TPOS(Z1_axis) < SLLIMIT(Z1_axis)"
	END
RET

ON MFLAGS(Z1_axis).#HOME=1 & MFLAGS(Z1_Yaw_axis).#HOME=1 & TPOS(Z1_axis) > SRLIMIT(Z1_axis) 
	IF(FDEF(Z1_axis).#SRL=1 & FMASK(Z1_axis).#SRL=1 & ^(GMTYPE(Z1_axis)=5))
		KILL Z1_axis,5015	!Software Right Limit
		TPOS(Z1_axis)=FPOS(Z1_axis)
		DISP "TPOS(Z1_axis) > SRLIMIT(Z1_axis)"
	END
RET

ON MFLAGS(Z1_axis).#HOME=1 & MFLAGS(Z1_Yaw_axis).#HOME=1 & TPOS(Z1_Yaw_axis) < SLLIMIT(Z1_Yaw_axis) 
	IF( FDEF(Z1_Yaw_axis).#SLL=1 & FMASK(Z1_Yaw_axis).#SLL=1 & ^(GMTYPE(Z1_Yaw_axis)=5))
		KILL Z1_Yaw_axis,5016	!Software Left Limit
		TPOS(Z1_Yaw_axis)=FPOS(Z1_Yaw_axis)
		DISP "TPOS(Z1_Yaw_axis) < SLLIMIT(Z1_Yaw_axis)"
	END
RET

ON MFLAGS(Z1_axis).#HOME=1 & MFLAGS(Z1_Yaw_axis).#HOME=1 & TPOS(Z1_Yaw_axis) > SRLIMIT(Z1_Yaw_axis) 
	IF(FDEF(Z1_Yaw_axis).#SRL=1 & FMASK(Z1_Yaw_axis).#SRL=1 & ^(GMTYPE(Z1_Yaw_axis)=5))
		KILL Z1_Yaw_axis,5015	!Software Right Limit
		TPOS(Z1_Yaw_axis)=FPOS(Z1_Yaw_axis)
		DISP "TPOS(Z1_Yaw_axis) > SRLIMIT(Z1_Yaw_axis)"
	END
RET



ON MFLAGS(Z1_axis).#HOME=0 & MFLAGS(Z1_Yaw_axis).#HOME=0 & RVEL(Z1_axis) > XVEL(Z1_axis)*0.5 & ^MST(Z1_axis).#INPOS
	IMM VEL(Z1_axis) = XVEL(Z1_axis)*0.45 
RET

ON MFLAGS(Z1_axis).#HOME=0 & MFLAGS(Z1_Yaw_axis).#HOME=0 & RVEL(Z1_axis) < -XVEL(Z1_axis)*0.5 & ^MST(Z1_axis).#INPOS
	IMM VEL(Z1_axis) = -XVEL(Z1_axis)*0.45 
RET

ON MFLAGS(Z1_axis).#HOME=0 & MFLAGS(Z1_Yaw_axis).#HOME=0 & RVEL(Z1_Yaw_axis) > XVEL(Z1_Yaw_axis)*0.5 & ^MST(Z1_Yaw_axis).#INPOS
	IMM VEL(Z1_Yaw_axis) = XVEL(Z1_Yaw_axis)*0.45 
RET

ON MFLAGS(Z1_axis).#HOME=0 & MFLAGS(Z1_Yaw_axis).#HOME=0 & RVEL(Z1_Yaw_axis) < -XVEL(Z1_Yaw_axis)*0.5 & ^MST(Z1_Yaw_axis).#INPOS
	IMM VEL(Z1_Yaw_axis) = -XVEL(Z1_Yaw_axis)*0.45 
RET

AUTOEXEC:
	!Z1_init_pos = 75050					Z1_Yaw_init_pos = 75210
	Z1_Yaw_Offset = 0 !-750  hsinyung 20240125                !2023.11.13
	Z1_init_pos = 74270					Z1_Yaw_init_pos = 75189 + Z1_Yaw_Offset !2023.1108
	MFLAGS(Z1_axis).#HOME=0;	 		MFLAGS(Z1_Yaw_axis).#HOME=0
	MFLAGS(Z1_axis).#GANTRY=0 ; 		MFLAGS(Z1_Yaw_axis).#GANTRY=0
	E_TYPE(Z1_axis)=13 ; 				E_TYPE(Z1_Yaw_axis)=13 ;
	E_AOFFS(Z1_axis) = Z1_init_pos ; 	E_AOFFS(Z1_Yaw_axis) = Z1_Yaw_init_pos ;  
	
STOP
#8
!PNAME=
!PDESC=
! T1_axis Single-axis_Hiwin_Drive_Homing_Process_VER1.5
!!****** Setting Parameter ******!!
LOCAL REAL T1_HmType,T1_multi_indHm,T1_multi_indVel
LOCAL REAL T1_HmVel,T1_IndVel,T1_HmOffset	
LOCAL INT T1_ErrCompensation,T1_ErrCompensationSpacing,T1_ErrCompIniPos
LOCAL INT ZONE0,T1_ErrTableIndex
LOCAL INT T1_HiwinDriveHome,T1_EtherCATIndex,T1_InternalHmType
LOCAL REAL T1_ControlUnit
LOCAL INT T1_IsModeOfOperationInPDO
LOCAL REAL T1_HiwinDriveHmVel,T1_HiwinDriveIndVel,T1_HiwinDriveHmOffset,T1_HiwinDriveHmAcc
!!################ Basic Settings ######################################################################################################
T1_IOIndex=7
T1_HmType = 1 								!the method of homing
           									!value 0 : Customized homing
           									!	   1 : find the left limit in negative direction,then find index in positive direction 
           									!      2 : find index in positive direction directly 
T1_HmOffset = 0 								! T1_HmOffset (unit)
T1_HmVel = 2000								! the velocity for homing 	
T1_IndVel = 400 								! the velocity for finding index

T1_multi_indHm=0								! multi index structure
											! value 0 : nomal Homing
											!	    1 : find the left limit in negative direction,then slowing leave the limit in positive direction,
											!			then slowing find the left limit in negative direction,then slowing find index in positive direction
T1_multi_indVel = 100						! (Do not modify)homing velocity of multi index structure
!!*********************************** With Hiwin Drive homing support HmType 1&2************************************!!
T1_IsModeOfOperationInPDO = 0					! Check #ETHERCAT if include Mode of operation slect 1 else select 0
T1_HiwinDriveHome = 1							! 1 : With E1 internal homing ; 2 : With E1 Touch probe homing 
T1_EtherCATIndex = 1							! EtherCAT nod index
T1_ControlUnit = 360/17278.760							! E1 Control unit
!!**************** Configuration of 1D Error Compensation*****************************************************!!
T1_ErrCompensation = 0						! 0 : without compensation  ; 1 : turn on the compensation after homing completed 
T1_ErrCompIniPos = 0							! the initial position of error compensation
T1_ErrCompensationSpacing = 50000				! setting the spacing for error compensation 
!!**********************************************************************************************************!!
!!######################################################################################################################################## 

!!**************************************************************************************************************************************!!
!!************************************************************ Main program ************************************************************!!
FCLEAR T1_axis
IF T1_HmType=0													! Customized homing
	CALL T1_HmType0	
ELSEIF T1_HiwinDriveHome=1										! E1 internal
	MFLAGS(T1_axis).#HOME=0	
	IF T1_HmType=1
		T1_InternalHmType = 1
	ELSEIF T1_HmType=2
		T1_InternalHmType = 34
	ELSE
		DISP"ERROR:The value of T1_HmType is invalid!!"
		STOP
	END
	CALL T1_HiwinDriveInternalHmType	
ELSEIF T1_HiwinDriveHome=2										! Touch probe
		MFLAGS(T1_axis).#HOME=0	
	IF T1_HmType=1
		CALL T1_HiwinDriveTouchProbeHmType1
	ELSEIF T1_HmType=2
		CALL T1_HiwinDriveTouchProbeHmType2
	ELSE
		DISP"ERROR:The value of T1_HmType is invalid!!"
		STOP
	END
ELSE
	DISP"ERROR:The value of T1_HmType or T1_HiwinDriveHome is invalid!!"
	STOP
END

IF T1_ErrCompensation = 1
	DISP "Enable the compensation mode."
	DISP "Execute the compensation prcoess......"
	CALL T1_ErrorCompensation	
ELSE
	DISP "Disable error compensation."
	ERRORUNMAP T1_axis, ZONE0
END 

IF (T1_HmType>=1&T1_HmType<=2)
	ENABLE T1_axis
	TILL MST(T1_axis).#ENABLED
	WAIT 500
	DISP"Go home......"	
	PTP/EV T1_axis,0,T1_HmVel	
	MFLAGS(T1_axis).#HOME=1
END	
FDEF(T1_axis).#LL = 1	 		
FDEF(T1_axis).#SRL = 1	 		
FDEF(T1_axis).#SLL = 1	 
DISP"Homing successful!!"	

STOP	

!!*************************************************************************************************************************************!!
!!************************************************************ Homing process	*******************************************************!!
T1_HmType0:
!Customized
RET
STOP
!------------------------------------------------------------------T1_HiwinDriveTouchProbeHmType1--------------------------------------------------------------------------------------
T1_HiwinDriveTouchProbeHmType1:

FCLEAR T1_axis
DISABLE T1_axis		
TILL ^MST(T1_axis).#ENABLED	
WAIT 500	
MFLAGS(T1_axis).#OPEN = 0								! Close loop control
ERRORMAPOFF T1_axis, -1									! Close all axis error compensation
MFLAGS(T1_axis).#GANTRY = 0								! turn off gantry mode (MFLAGS.25)	
FDEF(T1_axis).#SRL = 0	 								! disable software right limit response
FDEF(T1_axis).#SLL = 0	 								! disable software left limit response
FDEF(T1_axis).#LL = 0	 										! motor is not disable when left limit signal rising.

ENABLE	T1_axis	 
TILL MST(T1_axis).#ENABLED	 
WAIT 500	
DISP"Start to find the left limit......"
JOG/V T1_axis,-T1_HmVel									! find the left limit in negative direction
TILL (COEREAD/4 (T1_EtherCATIndex,0x60FD,0)& 1) = 1
HALT T1_axis 
TILL ^MST(T1_axis).#MOVE,1000							! if reach left limit , stop motion
DISP"Already found the left limit!!"

!!!!!!!!!!!!!!!!!!!!multi index Structure Homing Way!!!!!!!!!!!!!!!
IF(T1_multi_indHm = 1)	
	JOG/V T1_axis,T1_multi_indVel							! slowing to leave the limit in negative direction
	TILL (COEREAD/4 (T1_EtherCATIndex,0x60FD,0)& 1) = 0	! waiting to leave the limit
	HALT T1_axis
	TILL ^MST(T1_axis).#MOVE 
	T1_IndVel = T1_multi_indVel							! define slowing velocity to find index velocity
END
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
ECOUT(ECGETOFFSET("Touch probe function",T1_EtherCATIndex),T1_TouchProbFun)
WAIT 200
T1_TouchProbFun = 0										!Reset Touch probe
WAIT 200
T1_TouchProbFun = 17										! Start Touch probe
WAIT 200
DISP"Start to find the index in positive direction......"
JOG/V T1_axis,T1_IndVel									!find the index in positive direction
TILL (COEREAD/2 (T1_EtherCATIndex,0x60B9,0) = 3)			!if reach index	, stop motion
HALT T1_axis	
TILL ^MST(T1_axis).#MOVE 
DISP"Already found the index!!"
SET FPOS(T1_axis) = (COEREAD/4 (T1_EtherCATIndex,0x6064,0) - COEREAD/4 (T1_EtherCATIndex,0x60BA,0))*T1_ControlUnit - T1_HmOffset		!set index position as zero.
WAIT 500
ECUNMAPOUT (ECGETOFFSET("Touch probe function",T1_EtherCATIndex))	
RET	
STOP
!------------------------------------------------------------------T1_HiwinDriveTouchProbeHmType2--------------------------------------------------------------------------------------
T1_HiwinDriveTouchProbeHmType2:

FCLEAR T1_axis
DISABLE T1_axis		
TILL ^MST(T1_axis).#ENABLED	
WAIT 500	
MFLAGS(T1_axis).#OPEN = 0						! Close loop control
ERRORMAPOFF T1_axis, -1							! Close all axis error compensation
MFLAGS(T1_axis).#GANTRY = 0	 					! turn off gantry mode (MFLAGS.25)	
FDEF(T1_axis).#SRL = 0	 						! disable software right limit response
FDEF(T1_axis).#SLL = 0	 						! disable software left limit response
FDEF(T1_axis).#LL = 0	 										! motor is not disable when left limit signal rising.

ENABLE	T1_axis	 
!!!!!!!!!!!!!!!!!!!!multi index Structure Homing Way!!!!!!!!!!!!!!!
IF(T1_multi_indHm = 1)	
	T1_IndVel = T1_multi_indVel					! define slowing velocity to find index velocity
END
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
ECOUT(ECGETOFFSET("Touch probe function",T1_EtherCATIndex),T1_TouchProbFun)
WAIT 200
T1_TouchProbFun = 0								!Reset Touch probe
WAIT 200
T1_TouchProbFun = 17								! Start Touch probe
WAIT 200
DISP"Start to find the index in positive direction......"
JOG/V T1_axis,T1_IndVel							!find the index in positive direction
TILL (COEREAD/2 (T1_EtherCATIndex,0x60B9,0) = 3)	!if reach index	, stop motion
HALT T1_axis	
TILL ^MST(T1_axis).#MOVE 
DISP"Already found the index!!"
SET FPOS(T1_axis) = (COEREAD/4 (T1_EtherCATIndex,0x6064,0) - COEREAD/4 (T1_EtherCATIndex,0x60BA,0))*T1_ControlUnit - T1_HmOffset	!set index position as zero.
WAIT 500
ECUNMAPOUT (ECGETOFFSET("Touch probe function",T1_EtherCATIndex))		
RET	
STOP
!------------------------------------------------------------------T1_HiwinDriveInternalHmType--------------------------------------------------------------------------------------
T1_HiwinDriveInternalHmType:

FCLEAR T1_axis
FDEF(T1_axis).#LL = 0	 										! motor is not disable when left limit signal rising.
FDEF(T1_axis).#SRL = 0	 										! disable software right limit response
FDEF(T1_axis).#SLL = 0	 										! disable software left limit response
T1_HiwinDriveHmVel = T1_HmVel/T1_ControlUnit
T1_HiwinDriveIndVel = T1_IndVel/T1_ControlUnit
T1_HiwinDriveHmOffset = T1_HmOffset/T1_ControlUnit
T1_HiwinDriveHmAcc = ACC(T1_axis)/T1_ControlUnit

ECIN( ECGETOFFSET("Statusword",T1_EtherCATIndex),T1_StatusWord)  
ECOUT(ECGETOFFSET("Controlword",T1_EtherCATIndex),T1_ControlWord)
IF T1_IsModeOfOperationInPDO = 1
	ECOUT(ECGETOFFSET("Mode of operation",T1_EtherCATIndex),T1_ModeOfOperation)
	T1_ModeOfOperation = 6
ELSE
	COEWRITE/1 (T1_EtherCATIndex,0x6060,0,6) !6 is Homing mode  
END  


COEWRITE/1 (T1_EtherCATIndex,0x6098,0,T1_InternalHmType)	
COEWRITE/4 (T1_EtherCATIndex,0x6099,1,T1_HiwinDriveHmVel) 	
COEWRITE/4 (T1_EtherCATIndex,0x6099,2,T1_HiwinDriveIndVel)	
COEWRITE/4 (T1_EtherCATIndex,0x609A,0,T1_HiwinDriveHmAcc)	
COEWRITE/4 (T1_EtherCATIndex,0x607C,0,T1_HiwinDriveHmOffset) 	

T1_ControlWord=6  
TILL T1_StatusWord.0=1  
T1_ControlWord=7  
TILL T1_StatusWord.0=1 & T1_StatusWord.1=1

WAIT 200 

T1_ControlWord=15  
TILL T1_StatusWord.0=1 & T1_StatusWord.1=1 & T1_StatusWord.2=1	!Enabled
!Start Homing Procedure - Bit 4  
T1_ControlWord=31  											!Start Home
TILL T1_StatusWord.12=1 & T1_StatusWord.10=1 | T1_StatusWord.13=1				!Home Finished

IF T1_StatusWord.13=1
	CALL HomeFail
END

T1_ControlWord=0  

WAIT 100

IF T1_IsModeOfOperationInPDO = 1
	T1_ModeOfOperation = 8 
	WAIT 500 
	ECUNMAPOUT (ECGETOFFSET("Mode of operation",T1_EtherCATIndex))
ELSE
	COEWRITE/1 (T1_EtherCATIndex,0x6060,0,8)						!go back to CSP mode 
END  
WAIT 500 
ECUNMAPIN (ECGETOFFSET("Statusword",T1_EtherCATIndex))
ECUNMAPOUT (ECGETOFFSET("Controlword",T1_EtherCATIndex))

WAIT 500 
DISABLE T1_axis
TILL ^MST(T1_axis).#ENABLED 

RET
STOP
!!*************************************************************************************************************************************!!
!!****************************************************** Error Compensation Process ***************************************************!!
T1_ErrorCompensation:
!---------- T1_axis Error Compensation Table ------------!
T1_ErrTable(0) = 0	;     
T1_ErrTable(1) = 0	;
T1_ErrTable(2) = 0	;
T1_ErrTable(3) = 0	;
T1_ErrTable(4) = 0	;
T1_ErrTable(5) = 0	;
T1_ErrTable(6) = 0	;
T1_ErrTable(7) = 0	;
T1_ErrTable(8) = 0	;
T1_ErrTable(9) = 0	;
T1_ErrTable(10) = 0	;

!-------------------------------------------------------!
T1_ErrTableIndex = 0
WHILE T1_ErrTableIndex < SIZEOF(T1_ErrTable)
	T1_ErrTable(T1_ErrTableIndex) = -T1_ErrTable(T1_ErrTableIndex)
	T1_ErrTableIndex = T1_ErrTableIndex + 1
END
ERRORUNMAP T1_axis, ZONE0
ERRORMAP1D T1_axis, ZONE0, T1_ErrCompIniPos, T1_ErrCompensationSpacing, T1_ErrTable
ERRORMAPON T1_axis, ZONE0

WAIT 500	
DISP "Cmpensation Procces's completed!"

RET 
STOP
!!#############################################################################################################################

ON MFLAGS(T1_axis).#HOME=1 & TPOS(T1_axis) < SLLIMIT(T1_axis) 
	IF( FDEF(T1_axis).#SLL=1 & FMASK(T1_axis).#SLL=1 & ^(GMTYPE(T1_axis)=5))
		KILL T1_axis,5016	!Software Left Limit
		TPOS(T1_axis)=FPOS(T1_axis)
		DISP "TPOS(T1_axis) < SLLIMIT(T1_axis)"
	END
RET

ON MFLAGS(T1_axis).#HOME=1 & TPOS(T1_axis) > SRLIMIT(T1_axis) 
	IF(FDEF(T1_axis).#SRL=1 & FMASK(T1_axis).#SRL=1 & ^(GMTYPE(T1_axis)=5))
		KILL T1_axis,5015	!Software Right Limit
		TPOS(T1_axis)=FPOS(T1_axis)
		DISP "TPOS(T1_axis) > SRLIMIT(T1_axis)"
	END
RET


ON MFLAGS(T1_axis).#HOME=0 & RVEL(T1_axis) > XVEL(T1_axis)*0.5 & ^MST(T1_axis).#INPOS
	IMM VEL(T1_axis) = XVEL(T1_axis)*0.45 
RET

ON MFLAGS(T1_axis).#HOME=0 & RVEL(T1_axis) < -XVEL(T1_axis)*0.5 & ^MST(T1_axis).#INPOS
	IMM VEL(T1_axis) = -XVEL(T1_axis)*0.45 
RET

AUTOEXEC:
	T1_IOIndex=7
	MFLAGS(T1_axis).#HOME=0
STOP

ON IN(T1_IOIndex).0 = 1
	SAFINI(T1_axis).#LL = 1
RET

ON IN(T1_IOIndex).0 = 0
	SAFINI(T1_axis).#LL = 0
RET

ON IN(T1_IOIndex).1 = 1
	SAFINI(T1_axis).#RL = 1
RET

ON IN(T1_IOIndex).1 = 0
	SAFINI(T1_axis).#RL = 0
RET

!ON MST(T1_axis).#ENABLED & (IN(T1_IOIndex).24 = 1 | IN(T1_IOIndex).25 = 1)
!	KILL T1_axis
!	TILL ^MST(T1_axis).#MOVE,500 
!	DISABLE T1_axis,5028		!Safe Torque Off
!	TILL ^MST(T1_axis).#ENABLED
!RET	

ON IN(T1_IOIndex).24 = 1 | IN(T1_IOIndex).25 = 1
    DISP"T1_Event Time : %d",TIME
 	DISP"T1_CHECK SF1 Value : %d",IN(T1_IOIndex).24
	DISP"T1_CHECK SF2 Value : %d",IN(T1_IOIndex).25
	WAIT 5
	DISP"T1_CHECK FAULT Value : %d", SAFIN(T1_axis).9
	DISP"T1_CHECK E1 FAULT : %d",AxisErrorCode8
RET

HomeFail:
DISP" E1 homing fail "
IF T1_IsModeOfOperationInPDO = 1
	T1_ModeOfOperation = 8 
	WAIT 500 
	ECUNMAPOUT (ECGETOFFSET("Mode of operation",T1_EtherCATIndex))
ELSE
	COEWRITE/1 (T1_EtherCATIndex,0x6060,0,8)						!go back to CSP mode 
END  
WAIT 500 
ECUNMAPIN (ECGETOFFSET("Statusword",T1_EtherCATIndex))
ECUNMAPOUT (ECGETOFFSET("Controlword",T1_EtherCATIndex))

STOP
#9
!PNAME=
!PDESC=
! X2_1_axis Single-axis_Hiwin_Drive_Homing_Process_VER1.5
!!****** Setting Parameter ******!!
LOCAL REAL X2_1_HmType,X2_1_multi_indHm,X2_1_multi_indVel
LOCAL REAL X2_1_HmVel,X2_1_IndVel,X2_1_HmOffset	
LOCAL INT X2_1_ErrCompensation,X2_1_ErrCompensationSpacing,X2_1_ErrCompIniPos
LOCAL INT ZONE0,X2_1_ErrTableIndex
LOCAL INT X2_1_HiwinDriveHome,X2_1_EtherCATIndex,X2_1_InternalHmType
LOCAL REAL X2_1_ControlUnit
LOCAL INT X2_1_IsModeOfOperationInPDO
LOCAL REAL X2_1_HiwinDriveHmVel,X2_1_HiwinDriveIndVel,X2_1_HiwinDriveHmOffset,X2_1_HiwinDriveHmAcc
!!################ Basic Settings ######################################################################################################
X2_1_IOIndex = 8
X2_1_HmType = 1 								!the method of homing
           									!value 0 : Customized homing
           									!	   1 : find the left limit in negative direction,then find index in positive direction 
           									!      2 : find index in positive direction directly 
X2_1_HmOffset = 0 								! X2_1_HmOffset (unit)
X2_1_HmVel = 30000								! the velocity for homing 	
X2_1_IndVel = 10000 								! the velocity for finding index

X2_1_multi_indHm=0								! multi index structure
											! value 0 : nomal Homing
											!	    1 : find the left limit in negative direction,then slowing leave the limit in positive direction,
											!			then slowing find the left limit in negative direction,then slowing find index in positive direction
X2_1_multi_indVel = 100						! (Do not modify)homing velocity of multi index structure
!!*********************************** With Hiwin Drive homing support HmType 1&2************************************!!
X2_1_IsModeOfOperationInPDO = 0					! Check #ETHERCAT if include Mode of operation slect 1 else select 0
X2_1_HiwinDriveHome = 1						! 1 : With E1 internal homing ; 2 : With E1 Touch probe homing 
X2_1_EtherCATIndex = 4							! EtherCAT nod index
X2_1_ControlUnit = 1/10							! E1 Control unit
!!**************** Configuration of 1D Error Compensation*****************************************************!!
X2_1_ErrCompensation = 1						! 0 : without compensation  ; 1 : turn on the compensation after homing completed 
X2_1_ErrCompIniPos = 0							! the initial position of error compensation
X2_1_ErrCompensationSpacing = 2000				! setting the spacing for error compensation 
!!**********************************************************************************************************!!
!!######################################################################################################################################## 

!!**************************************************************************************************************************************!!
!!************************************************************ Main program ************************************************************!!
FCLEAR X2_1_axis
IF X2_1_HmType=0													! Customized homing
	CALL X2_1_HmType0	
ELSEIF X2_1_HiwinDriveHome=1										! E1 internal
	MFLAGS(X2_1_axis).#HOME=0	
	IF X2_1_HmType=1
		X2_1_InternalHmType = 1
	ELSEIF X2_1_HmType=2
		X2_1_InternalHmType = 34
	ELSE
		DISP"ERROR:The value of X2_1_HmType is invalid!!"
		STOP
	END
	CALL X2_1_HiwinDriveInternalHmType	
ELSEIF X2_1_HiwinDriveHome=2										! Touch probe
		MFLAGS(X2_1_axis).#HOME=0	
	IF X2_1_HmType=1
		CALL X2_1_HiwinDriveTouchProbeHmType1
	ELSEIF X2_1_HmType=2
		CALL X2_1_HiwinDriveTouchProbeHmType2
	ELSE
		DISP"ERROR:The value of X2_1_HmType is invalid!!"
		STOP
	END
ELSE
	DISP"ERROR:The value of X2_1_HmType or X2_1_HiwinDriveHome is invalid!!"
	STOP
END

IF X2_1_ErrCompensation = 1
	DISP "Enable the compensation mode."
	DISP "Execute the compensation prcoess......"
	CALL X2_1_ErrorCompensation	
ELSE
	DISP "Disable error compensation."
	ERRORUNMAP X2_1_axis, ZONE0
END 

IF (X2_1_HmType>=1&X2_1_HmType<=2)
	ENABLE X2_1_axis
	TILL MST(X2_1_axis).#ENABLED
	WAIT 500
	DISP"Go home......"	
	PTP/EV X2_1_axis,0,X2_1_HmVel	
	MFLAGS(X2_1_axis).#HOME=1
END	
FDEF(X2_1_axis).#LL = 1	 		
FDEF(X2_1_axis).#SRL = 1	 		
FDEF(X2_1_axis).#SLL = 1	 
DISP"Homing successful!!"	

STOP	

!!*************************************************************************************************************************************!!
!!************************************************************ Homing process	*******************************************************!!
X2_1_HmType0:
!Customized
RET
STOP
!------------------------------------------------------------------X2_1_HiwinDriveTouchProbeHmType1--------------------------------------------------------------------------------------
X2_1_HiwinDriveTouchProbeHmType1:

FCLEAR X2_1_axis
DISABLE X2_1_axis		
TILL ^MST(X2_1_axis).#ENABLED	
WAIT 500	
MFLAGS(X2_1_axis).#OPEN = 0								! Close loop control
ERRORMAPOFF X2_1_axis, -1									! Close all axis error compensation
MFLAGS(X2_1_axis).#GANTRY = 0								! turn off gantry mode (MFLAGS.25)	
FDEF(X2_1_axis).#SRL = 0	 								! disable software right limit response
FDEF(X2_1_axis).#SLL = 0	 								! disable software left limit response
FDEF(X2_1_axis).#LL = 0	 										! motor is not disable when left limit signal rising.

ENABLE	X2_1_axis	 
TILL MST(X2_1_axis).#ENABLED	 
WAIT 500	
DISP"Start to find the left limit......"
JOG/V X2_1_axis,-X2_1_HmVel									! find the left limit in negative direction
TILL (COEREAD/4 (X2_1_EtherCATIndex,0x60FD,0)& 1) = 1
HALT X2_1_axis 
TILL ^MST(X2_1_axis).#MOVE,1000							! if reach left limit , stop motion
DISP"Already found the left limit!!"

!!!!!!!!!!!!!!!!!!!!multi index Structure Homing Way!!!!!!!!!!!!!!!
IF(X2_1_multi_indHm = 1)	
	JOG/V X2_1_axis,X2_1_multi_indVel							! slowing to leave the limit in negative direction
	TILL (COEREAD/4 (X2_1_EtherCATIndex,0x60FD,0)& 1) = 0	! waiting to leave the limit
	HALT X2_1_axis
	TILL ^MST(X2_1_axis).#MOVE 
	X2_1_IndVel = X2_1_multi_indVel							! define slowing velocity to find index velocity
END
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
ECOUT(ECGETOFFSET("Touch probe function",X2_1_EtherCATIndex),X2_1_TouchProbFun)
WAIT 200
X2_1_TouchProbFun = 0										!Reset Touch probe
WAIT 200
X2_1_TouchProbFun = 17										! Start Touch probe
WAIT 200
DISP"Start to find the index in positive direction......"
JOG/V X2_1_axis,X2_1_IndVel									!find the index in positive direction
TILL (COEREAD/2 (X2_1_EtherCATIndex,0x60B9,0) = 3)			!if reach index	, stop motion
HALT X2_1_axis	
TILL ^MST(X2_1_axis).#MOVE 
DISP"Already found the index!!"
SET FPOS(X2_1_axis) = (COEREAD/4 (X2_1_EtherCATIndex,0x6064,0) - COEREAD/4 (X2_1_EtherCATIndex,0x60BA,0))*X2_1_ControlUnit - X2_1_HmOffset		!set index position as zero.
WAIT 500
ECUNMAPOUT (ECGETOFFSET("Touch probe function",X2_1_EtherCATIndex))	
RET	
STOP
!------------------------------------------------------------------X2_1_HiwinDriveTouchProbeHmType2--------------------------------------------------------------------------------------
X2_1_HiwinDriveTouchProbeHmType2:

FCLEAR X2_1_axis
DISABLE X2_1_axis		
TILL ^MST(X2_1_axis).#ENABLED	
WAIT 500	
MFLAGS(X2_1_axis).#OPEN = 0						! Close loop control
ERRORMAPOFF X2_1_axis, -1							! Close all axis error compensation
MFLAGS(X2_1_axis).#GANTRY = 0	 					! turn off gantry mode (MFLAGS.25)	
FDEF(X2_1_axis).#SRL = 0	 						! disable software right limit response
FDEF(X2_1_axis).#SLL = 0	 						! disable software left limit response
FDEF(X2_1_axis).#LL = 0	 										! motor is not disable when left limit signal rising.

ENABLE	X2_1_axis	 
!!!!!!!!!!!!!!!!!!!!multi index Structure Homing Way!!!!!!!!!!!!!!!
IF(X2_1_multi_indHm = 1)	
	X2_1_IndVel = X2_1_multi_indVel					! define slowing velocity to find index velocity
END
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
ECOUT(ECGETOFFSET("Touch probe function",X2_1_EtherCATIndex),X2_1_TouchProbFun)
WAIT 200
X2_1_TouchProbFun = 0								!Reset Touch probe
WAIT 200
X2_1_TouchProbFun = 17								! Start Touch probe
WAIT 200
DISP"Start to find the index in positive direction......"
JOG/V X2_1_axis,X2_1_IndVel							!find the index in positive direction
TILL (COEREAD/2 (X2_1_EtherCATIndex,0x60B9,0) = 3)	!if reach index	, stop motion
HALT X2_1_axis	
TILL ^MST(X2_1_axis).#MOVE 
DISP"Already found the index!!"
SET FPOS(X2_1_axis) = (COEREAD/4 (X2_1_EtherCATIndex,0x6064,0) - COEREAD/4 (X2_1_EtherCATIndex,0x60BA,0))*X2_1_ControlUnit - X2_1_HmOffset	!set index position as zero.
WAIT 500
ECUNMAPOUT (ECGETOFFSET("Touch probe function",X2_1_EtherCATIndex))		
RET	
STOP
!------------------------------------------------------------------X2_1_HiwinDriveInternalHmType--------------------------------------------------------------------------------------
X2_1_HiwinDriveInternalHmType:

FCLEAR X2_1_axis
FDEF(X2_1_axis).#LL = 0	 										! motor is not disable when left limit signal rising.
FDEF(X2_1_axis).#SRL = 0	 										! disable software right limit response
FDEF(X2_1_axis).#SLL = 0	 										! disable software left limit response
X2_1_HiwinDriveHmVel = X2_1_HmVel/X2_1_ControlUnit
X2_1_HiwinDriveIndVel = X2_1_IndVel/X2_1_ControlUnit
X2_1_HiwinDriveHmOffset = X2_1_HmOffset/X2_1_ControlUnit
X2_1_HiwinDriveHmAcc = ACC(X2_1_axis)/X2_1_ControlUnit

ECIN( ECGETOFFSET("Statusword",X2_1_EtherCATIndex),X2_1_StatusWord)  
ECOUT(ECGETOFFSET("Controlword",X2_1_EtherCATIndex),X2_1_ControlWord)
IF X2_1_IsModeOfOperationInPDO = 1
	ECOUT(ECGETOFFSET("Mode of operation",X2_1_EtherCATIndex),X2_1_ModeOfOperation)
	X2_1_ModeOfOperation = 6
ELSE
	COEWRITE/1 (X2_1_EtherCATIndex,0x6060,0,6) !6 is Homing mode  
END  


COEWRITE/1 (X2_1_EtherCATIndex,0x6098,0,X2_1_InternalHmType)	
COEWRITE/4 (X2_1_EtherCATIndex,0x6099,1,X2_1_HiwinDriveHmVel) 	
COEWRITE/4 (X2_1_EtherCATIndex,0x6099,2,X2_1_HiwinDriveIndVel)	
COEWRITE/4 (X2_1_EtherCATIndex,0x609A,0,X2_1_HiwinDriveHmAcc)	
COEWRITE/4 (X2_1_EtherCATIndex,0x607C,0,X2_1_HiwinDriveHmOffset) 	

X2_1_ControlWord=6  
TILL X2_1_StatusWord.0=1  
X2_1_ControlWord=7  
TILL X2_1_StatusWord.0=1 & X2_1_StatusWord.1=1

WAIT 200 

X2_1_ControlWord=15  
TILL X2_1_StatusWord.0=1 & X2_1_StatusWord.1=1 & X2_1_StatusWord.2=1	!Enabled
!Start Homing Procedure - Bit 4  
X2_1_ControlWord=31  											!Start Home
TILL X2_1_StatusWord.12=1 & X2_1_StatusWord.10=1 | X2_1_StatusWord.13=1				!Home Finished

IF X2_1_StatusWord.13=1
	CALL HomeFail
END

X2_1_ControlWord=0  

WAIT 100

IF X2_1_IsModeOfOperationInPDO = 1
	X2_1_ModeOfOperation = 8 
	WAIT 500 
	ECUNMAPOUT (ECGETOFFSET("Mode of operation",X2_1_EtherCATIndex))
ELSE
	COEWRITE/1 (X2_1_EtherCATIndex,0x6060,0,8)						!go back to CSP mode 
END  
WAIT 500 
ECUNMAPIN (ECGETOFFSET("Statusword",X2_1_EtherCATIndex))
ECUNMAPOUT (ECGETOFFSET("Controlword",X2_1_EtherCATIndex))

WAIT 500 
DISABLE X2_1_axis
TILL ^MST(X2_1_axis).#ENABLED 

RET
STOP
!!*************************************************************************************************************************************!!
!!****************************************************** Error Compensation Process ***************************************************!!
X2_1_ErrorCompensation:
!---------- X2_1_axis Error Compensation Table ------------!
X2_1_ErrTable(0)=	0	;
X2_1_ErrTable(1)=	0.3	;
X2_1_ErrTable(2)=	0.6	;
X2_1_ErrTable(3)=	1	;
X2_1_ErrTable(4)=	1.5	;
X2_1_ErrTable(5)=	1.8	;
X2_1_ErrTable(6)=	2.3	;
X2_1_ErrTable(7)=	2.7	;
X2_1_ErrTable(8)=	3	;
X2_1_ErrTable(9)=	3.4	;
X2_1_ErrTable(10)=	3.8	;

!-------------------------------------------------------!
X2_1_ErrTableIndex = 0
WHILE X2_1_ErrTableIndex < SIZEOF(X2_1_ErrTable)
	X2_1_ErrTable(X2_1_ErrTableIndex) = -X2_1_ErrTable(X2_1_ErrTableIndex)
	X2_1_ErrTableIndex = X2_1_ErrTableIndex + 1
END
ERRORUNMAP X2_1_axis, ZONE0
ERRORMAP1D X2_1_axis, ZONE0, X2_1_ErrCompIniPos, X2_1_ErrCompensationSpacing, X2_1_ErrTable
ERRORMAPON X2_1_axis, ZONE0

WAIT 500	
DISP "Cmpensation Procces's completed!"

RET 
STOP
!!#############################################################################################################################

ON MFLAGS(X2_1_axis).#HOME=1 & TPOS(X2_1_axis) < SLLIMIT(X2_1_axis) 
	IF( FDEF(X2_1_axis).#SLL=1 & FMASK(X2_1_axis).#SLL=1 & ^(GMTYPE(X2_1_axis)=5))
		KILL X2_1_axis,5016	!Software Left Limit
		TPOS(X2_1_axis)=FPOS(X2_1_axis)
		DISP "TPOS(X2_1_axis) < SLLIMIT(X2_1_axis)"
	END
RET

ON MFLAGS(X2_1_axis).#HOME=1 & TPOS(X2_1_axis) > SRLIMIT(X2_1_axis) 
	IF(FDEF(X2_1_axis).#SRL=1 & FMASK(X2_1_axis).#SRL=1 & ^(GMTYPE(X2_1_axis)=5))
		KILL X2_1_axis,5015	!Software Right Limit
		TPOS(X2_1_axis)=FPOS(X2_1_axis)
		DISP "TPOS(X2_1_axis) > SRLIMIT(X2_1_axis)"
	END
RET


ON MFLAGS(X2_1_axis).#HOME=0 & RVEL(X2_1_axis) > XVEL(X2_1_axis)*0.5 & ^MST(X2_1_axis).#INPOS
	IMM VEL(X2_1_axis) = XVEL(X2_1_axis)*0.45 
RET

ON MFLAGS(X2_1_axis).#HOME=0 & RVEL(X2_1_axis) < -XVEL(X2_1_axis)*0.5 & ^MST(X2_1_axis).#INPOS
	IMM VEL(X2_1_axis) = -XVEL(X2_1_axis)*0.45 
RET

AUTOEXEC:
	X2_1_IOIndex = 8
	MFLAGS(X2_1_axis).#HOME=0
STOP

ON IN(X2_1_IOIndex).0 = 1
	SAFINI(X2_1_axis).#LL = 1
RET

ON IN(X2_1_IOIndex).0 = 0
	SAFINI(X2_1_axis).#LL = 0
RET

ON IN(X2_1_IOIndex).1 = 1
	SAFINI(X2_1_axis).#RL = 1
RET

ON IN(X2_1_IOIndex).1 = 0
	SAFINI(X2_1_axis).#RL = 0
RET

!ON MST(X2_1_axis).#ENABLED & (IN(X2_1_IOIndex).24 = 1 | IN(X2_1_IOIndex).25 = 1)
!	KILL X2_1_axis
!	TILL ^MST(X2_1_axis).#MOVE,500 
!	DISABLE X2_1_axis,5028		!Safe Torque Off
!	TILL ^MST(X2_1_axis).#ENABLED
!RET	

ON IN(X2_1_IOIndex).24 = 1 | IN(X2_1_IOIndex).25 = 1
    DISP"X2_1_Event Time : %d",TIME
 	DISP"X2_1_CHECK SF1 Value : %d",IN(X2_1_IOIndex).24
	DISP"X2_1_CHECK SF2 Value : %d",IN(X2_1_IOIndex).25
	WAIT 5
	DISP"X2_1_CHECK FAULT Value : %d", SAFIN(X2_1_axis).9
	DISP"X2_1_CHECK E1 FAULT : %d",AxisErrorCode19
RET

HomeFail:
DISP" E1 homing fail "
IF X2_1_IsModeOfOperationInPDO = 1
	X2_1_ModeOfOperation = 8 
	WAIT 500 
	ECUNMAPOUT (ECGETOFFSET("Mode of operation",X2_1_EtherCATIndex))
ELSE
	COEWRITE/1 (X2_1_EtherCATIndex,0x6060,0,8)						!go back to CSP mode 
END  
WAIT 500 
ECUNMAPIN (ECGETOFFSET("Statusword",X2_1_EtherCATIndex))
ECUNMAPOUT (ECGETOFFSET("Controlword",X2_1_EtherCATIndex))

STOP
#10
!PNAME=
!PDESC=
! X2_2_axis Single-axis_Hiwin_Drive_Homing_Process_VER1.5
!!****** Setting Parameter ******!!
LOCAL REAL X2_2_HmType,X2_2_multi_indHm,X2_2_multi_indVel
LOCAL REAL X2_2_HmVel,X2_2_IndVel,X2_2_HmOffset	
LOCAL INT X2_2_ErrCompensation,X2_2_ErrCompensationSpacing,X2_2_ErrCompIniPos
LOCAL INT ZONE0,X2_2_ErrTableIndex
LOCAL INT X2_2_HiwinDriveHome,X2_2_EtherCATIndex,X2_2_InternalHmType
LOCAL REAL X2_2_ControlUnit
LOCAL INT X2_2_IsModeOfOperationInPDO
LOCAL REAL X2_2_HiwinDriveHmVel,X2_2_HiwinDriveIndVel,X2_2_HiwinDriveHmOffset,X2_2_HiwinDriveHmAcc
!!################ Basic Settings ######################################################################################################
X2_2_IOIndex = 9
X2_2_HmType = 1 								!the method of homing
           									!value 0 : Customized homing
           									!	   1 : find the left limit in negative direction,then find index in positive direction 
           									!      2 : find index in positive direction directly 
X2_2_HmOffset = 0 								! X2_2_HmOffset (unit)
X2_2_HmVel = 30000								! the velocity for homing 	
X2_2_IndVel = 10000 								! the velocity for finding index

X2_2_multi_indHm=0								! multi index structure
											! value 0 : nomal Homing
											!	    1 : find the left limit in negative direction,then slowing leave the limit in positive direction,
											!			then slowing find the left limit in negative direction,then slowing find index in positive direction
X2_2_multi_indVel = 100						! (Do not modify)homing velocity of multi index structure
!!*********************************** With Hiwin Drive homing support HmType 1&2************************************!!
X2_2_IsModeOfOperationInPDO = 0					! Check #ETHERCAT if include Mode of operation slect 1 else select 0
X2_2_HiwinDriveHome = 1						! 1 : With E1 internal homing ; 2 : With E1 Touch probe homing 
X2_2_EtherCATIndex = 5							! EtherCAT nod index
X2_2_ControlUnit = 1/10							! E1 Control unit
!!**************** Configuration of 1D Error Compensation*****************************************************!!
X2_2_ErrCompensation = 1						! 0 : without compensation  ; 1 : turn on the compensation after homing completed 
X2_2_ErrCompIniPos = 0							! the initial position of error compensation
X2_2_ErrCompensationSpacing = 2000				! setting the spacing for error compensation 
!!**********************************************************************************************************!!
!!######################################################################################################################################## 

!!**************************************************************************************************************************************!!
!!************************************************************ Main program ************************************************************!!
FCLEAR X2_2_axis
IF X2_2_HmType=0													! Customized homing
	CALL X2_2_HmType0	
ELSEIF X2_2_HiwinDriveHome=1										! E1 internal
	MFLAGS(X2_2_axis).#HOME=0	
	IF X2_2_HmType=1
		X2_2_InternalHmType = 1
	ELSEIF X2_2_HmType=2
		X2_2_InternalHmType = 34
	ELSE
		DISP"ERROR:The value of X2_2_HmType is invalid!!"
		STOP
	END
	CALL X2_2_HiwinDriveInternalHmType	
ELSEIF X2_2_HiwinDriveHome=2										! Touch probe
		MFLAGS(X2_2_axis).#HOME=0	
	IF X2_2_HmType=1
		CALL X2_2_HiwinDriveTouchProbeHmType1
	ELSEIF X2_2_HmType=2
		CALL X2_2_HiwinDriveTouchProbeHmType2
	ELSE
		DISP"ERROR:The value of X2_2_HmType is invalid!!"
		STOP
	END
ELSE
	DISP"ERROR:The value of X2_2_HmType or X2_2_HiwinDriveHome is invalid!!"
	STOP
END

IF X2_2_ErrCompensation = 1
	DISP "Enable the compensation mode."
	DISP "Execute the compensation prcoess......"
	CALL X2_2_ErrorCompensation	
ELSE
	DISP "Disable error compensation."
	ERRORUNMAP X2_2_axis, ZONE0
END 

IF (X2_2_HmType>=1&X2_2_HmType<=2)
	ENABLE X2_2_axis
	TILL MST(X2_2_axis).#ENABLED
	WAIT 500
	DISP"Go home......"	
	PTP/EV X2_2_axis,0,X2_2_HmVel	
	MFLAGS(X2_2_axis).#HOME=1
END	
FDEF(X2_2_axis).#LL = 1	 		
FDEF(X2_2_axis).#SRL = 1	 		
FDEF(X2_2_axis).#SLL = 1	 
DISP"Homing successful!!"	

STOP	

!!*************************************************************************************************************************************!!
!!************************************************************ Homing process	*******************************************************!!
X2_2_HmType0:
!Customized
RET
STOP
!------------------------------------------------------------------X2_2_HiwinDriveTouchProbeHmType1--------------------------------------------------------------------------------------
X2_2_HiwinDriveTouchProbeHmType1:

FCLEAR X2_2_axis
DISABLE X2_2_axis		
TILL ^MST(X2_2_axis).#ENABLED	
WAIT 500	
MFLAGS(X2_2_axis).#OPEN = 0								! Close loop control
ERRORMAPOFF X2_2_axis, -1									! Close all axis error compensation
MFLAGS(X2_2_axis).#GANTRY = 0								! turn off gantry mode (MFLAGS.25)	
FDEF(X2_2_axis).#SRL = 0	 								! disable software right limit response
FDEF(X2_2_axis).#SLL = 0	 								! disable software left limit response
FDEF(X2_2_axis).#LL = 0	 										! motor is not disable when left limit signal rising.

ENABLE	X2_2_axis	 
TILL MST(X2_2_axis).#ENABLED	 
WAIT 500	
DISP"Start to find the left limit......"
JOG/V X2_2_axis,-X2_2_HmVel									! find the left limit in negative direction
TILL (COEREAD/4 (X2_2_EtherCATIndex,0x60FD,0)& 1) = 1
HALT X2_2_axis 
TILL ^MST(X2_2_axis).#MOVE,1000							! if reach left limit , stop motion
DISP"Already found the left limit!!"

!!!!!!!!!!!!!!!!!!!!multi index Structure Homing Way!!!!!!!!!!!!!!!
IF(X2_2_multi_indHm = 1)	
	JOG/V X2_2_axis,X2_2_multi_indVel							! slowing to leave the limit in negative direction
	TILL (COEREAD/4 (X2_2_EtherCATIndex,0x60FD,0)& 1) = 0	! waiting to leave the limit
	HALT X2_2_axis
	TILL ^MST(X2_2_axis).#MOVE 
	X2_2_IndVel = X2_2_multi_indVel							! define slowing velocity to find index velocity
END
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
ECOUT(ECGETOFFSET("Touch probe function",X2_2_EtherCATIndex),X2_2_TouchProbFun)
WAIT 200
X2_2_TouchProbFun = 0										!Reset Touch probe
WAIT 200
X2_2_TouchProbFun = 17										! Start Touch probe
WAIT 200
DISP"Start to find the index in positive direction......"
JOG/V X2_2_axis,X2_2_IndVel									!find the index in positive direction
TILL (COEREAD/2 (X2_2_EtherCATIndex,0x60B9,0) = 3)			!if reach index	, stop motion
HALT X2_2_axis	
TILL ^MST(X2_2_axis).#MOVE 
DISP"Already found the index!!"
SET FPOS(X2_2_axis) = (COEREAD/4 (X2_2_EtherCATIndex,0x6064,0) - COEREAD/4 (X2_2_EtherCATIndex,0x60BA,0))*X2_2_ControlUnit - X2_2_HmOffset		!set index position as zero.
WAIT 500
ECUNMAPOUT (ECGETOFFSET("Touch probe function",X2_2_EtherCATIndex))	
RET	
STOP
!------------------------------------------------------------------X2_2_HiwinDriveTouchProbeHmType2--------------------------------------------------------------------------------------
X2_2_HiwinDriveTouchProbeHmType2:

FCLEAR X2_2_axis
DISABLE X2_2_axis		
TILL ^MST(X2_2_axis).#ENABLED	
WAIT 500	
MFLAGS(X2_2_axis).#OPEN = 0						! Close loop control
ERRORMAPOFF X2_2_axis, -1							! Close all axis error compensation
MFLAGS(X2_2_axis).#GANTRY = 0	 					! turn off gantry mode (MFLAGS.25)	
FDEF(X2_2_axis).#SRL = 0	 						! disable software right limit response
FDEF(X2_2_axis).#SLL = 0	 						! disable software left limit response
FDEF(X2_2_axis).#LL = 0	 										! motor is not disable when left limit signal rising.

ENABLE	X2_2_axis	 
!!!!!!!!!!!!!!!!!!!!multi index Structure Homing Way!!!!!!!!!!!!!!!
IF(X2_2_multi_indHm = 1)	
	X2_2_IndVel = X2_2_multi_indVel					! define slowing velocity to find index velocity
END
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
ECOUT(ECGETOFFSET("Touch probe function",X2_2_EtherCATIndex),X2_2_TouchProbFun)
WAIT 200
X2_2_TouchProbFun = 0								!Reset Touch probe
WAIT 200
X2_2_TouchProbFun = 17								! Start Touch probe
WAIT 200
DISP"Start to find the index in positive direction......"
JOG/V X2_2_axis,X2_2_IndVel							!find the index in positive direction
TILL (COEREAD/2 (X2_2_EtherCATIndex,0x60B9,0) = 3)	!if reach index	, stop motion
HALT X2_2_axis	
TILL ^MST(X2_2_axis).#MOVE 
DISP"Already found the index!!"
SET FPOS(X2_2_axis) = (COEREAD/4 (X2_2_EtherCATIndex,0x6064,0) - COEREAD/4 (X2_2_EtherCATIndex,0x60BA,0))*X2_2_ControlUnit - X2_2_HmOffset	!set index position as zero.
WAIT 500
ECUNMAPOUT (ECGETOFFSET("Touch probe function",X2_2_EtherCATIndex))		
RET	
STOP
!------------------------------------------------------------------X2_2_HiwinDriveInternalHmType--------------------------------------------------------------------------------------
X2_2_HiwinDriveInternalHmType:

FCLEAR X2_2_axis
FDEF(X2_2_axis).#LL = 0	 										! motor is not disable when left limit signal rising.
FDEF(X2_2_axis).#SRL = 0	 										! disable software right limit response
FDEF(X2_2_axis).#SLL = 0	 										! disable software left limit response
X2_2_HiwinDriveHmVel = X2_2_HmVel/X2_2_ControlUnit
X2_2_HiwinDriveIndVel = X2_2_IndVel/X2_2_ControlUnit
X2_2_HiwinDriveHmOffset = X2_2_HmOffset/X2_2_ControlUnit
X2_2_HiwinDriveHmAcc = ACC(X2_2_axis)/X2_2_ControlUnit

ECIN( ECGETOFFSET("Statusword",X2_2_EtherCATIndex),X2_2_StatusWord)  
ECOUT(ECGETOFFSET("Controlword",X2_2_EtherCATIndex),X2_2_ControlWord)
IF X2_2_IsModeOfOperationInPDO = 1
	ECOUT(ECGETOFFSET("Mode of operation",X2_2_EtherCATIndex),X2_2_ModeOfOperation)
	X2_2_ModeOfOperation = 6
ELSE
	COEWRITE/1 (X2_2_EtherCATIndex,0x6060,0,6) !6 is Homing mode  
END  


COEWRITE/1 (X2_2_EtherCATIndex,0x6098,0,X2_2_InternalHmType)	
COEWRITE/4 (X2_2_EtherCATIndex,0x6099,1,X2_2_HiwinDriveHmVel) 	
COEWRITE/4 (X2_2_EtherCATIndex,0x6099,2,X2_2_HiwinDriveIndVel)	
COEWRITE/4 (X2_2_EtherCATIndex,0x609A,0,X2_2_HiwinDriveHmAcc)	
COEWRITE/4 (X2_2_EtherCATIndex,0x607C,0,X2_2_HiwinDriveHmOffset) 	

X2_2_ControlWord=6  
TILL X2_2_StatusWord.0=1  
X2_2_ControlWord=7  
TILL X2_2_StatusWord.0=1 & X2_2_StatusWord.1=1

WAIT 200 

X2_2_ControlWord=15  
TILL X2_2_StatusWord.0=1 & X2_2_StatusWord.1=1 & X2_2_StatusWord.2=1	!Enabled
!Start Homing Procedure - Bit 4  
X2_2_ControlWord=31  											!Start Home
TILL X2_2_StatusWord.12=1 & X2_2_StatusWord.10=1 | X2_2_StatusWord.13=1				!Home Finished

IF X2_2_StatusWord.13=1
	CALL HomeFail
END

X2_2_ControlWord=0  

WAIT 100

IF X2_2_IsModeOfOperationInPDO = 1
	X2_2_ModeOfOperation = 8 
	WAIT 500 
	ECUNMAPOUT (ECGETOFFSET("Mode of operation",X2_2_EtherCATIndex))
ELSE
	COEWRITE/1 (X2_2_EtherCATIndex,0x6060,0,8)						!go back to CSP mode 
END  
WAIT 500 
ECUNMAPIN (ECGETOFFSET("Statusword",X2_2_EtherCATIndex))
ECUNMAPOUT (ECGETOFFSET("Controlword",X2_2_EtherCATIndex))

WAIT 500 
DISABLE X2_2_axis
TILL ^MST(X2_2_axis).#ENABLED 

RET
STOP
!!*************************************************************************************************************************************!!
!!****************************************************** Error Compensation Process ***************************************************!!
X2_2_ErrorCompensation:
!---------- X2_2_axis Error Compensation Table ------------!
X2_2_ErrTable(0)=	0	;
X2_2_ErrTable(1)=	-0.3	;
X2_2_ErrTable(2)=	-0.5	;
X2_2_ErrTable(3)=	-0.6	;
X2_2_ErrTable(4)=	-0.6	;
X2_2_ErrTable(5)=	-0.7	;
X2_2_ErrTable(6)=	-0.6	;
X2_2_ErrTable(7)=	-0.7	;
X2_2_ErrTable(8)=	-0.7	;
X2_2_ErrTable(9)=	-0.8	;
X2_2_ErrTable(10)=	-0.7	;

!-------------------------------------------------------!
X2_2_ErrTableIndex = 0
WHILE X2_2_ErrTableIndex < SIZEOF(X2_2_ErrTable)
	X2_2_ErrTable(X2_2_ErrTableIndex) = -X2_2_ErrTable(X2_2_ErrTableIndex)
	X2_2_ErrTableIndex = X2_2_ErrTableIndex + 1
END
ERRORUNMAP X2_2_axis, ZONE0
ERRORMAP1D X2_2_axis, ZONE0, X2_2_ErrCompIniPos, X2_2_ErrCompensationSpacing, X2_2_ErrTable
ERRORMAPON X2_2_axis, ZONE0

WAIT 500	
DISP "Cmpensation Procces's completed!"

RET 
STOP
!!#############################################################################################################################

ON MFLAGS(X2_2_axis).#HOME=1 & TPOS(X2_2_axis) < SLLIMIT(X2_2_axis) 
	IF( FDEF(X2_2_axis).#SLL=1 & FMASK(X2_2_axis).#SLL=1 & ^(GMTYPE(X2_2_axis)=5))
		KILL X2_2_axis,5016	!Software Left Limit
		TPOS(X2_2_axis)=FPOS(X2_2_axis)
		DISP "TPOS(X2_2_axis) < SLLIMIT(X2_2_axis)"
	END
RET

ON MFLAGS(X2_2_axis).#HOME=1 & TPOS(X2_2_axis) > SRLIMIT(X2_2_axis) 
	IF(FDEF(X2_2_axis).#SRL=1 & FMASK(X2_2_axis).#SRL=1 & ^(GMTYPE(X2_2_axis)=5))
		KILL X2_2_axis,5015	!Software Right Limit
		TPOS(X2_2_axis)=FPOS(X2_2_axis)
		DISP "TPOS(X2_2_axis) > SRLIMIT(X2_2_axis)"
	END
RET


ON MFLAGS(X2_2_axis).#HOME=0 & RVEL(X2_2_axis) > XVEL(X2_2_axis)*0.5 & ^MST(X2_2_axis).#INPOS
	IMM VEL(X2_2_axis) = XVEL(X2_2_axis)*0.45 
RET

ON MFLAGS(X2_2_axis).#HOME=0 & RVEL(X2_2_axis) < -XVEL(X2_2_axis)*0.5 & ^MST(X2_2_axis).#INPOS
	IMM VEL(X2_2_axis) = -XVEL(X2_2_axis)*0.45 
RET

AUTOEXEC:
	X2_2_IOIndex = 9
	MFLAGS(X2_2_axis).#HOME=0
STOP

ON IN(X2_2_IOIndex).0 = 1
	SAFINI(X2_2_axis).#LL = 1
RET

ON IN(X2_2_IOIndex).0 = 0
	SAFINI(X2_2_axis).#LL = 0
RET

ON IN(X2_2_IOIndex).1 = 1
	SAFINI(X2_2_axis).#RL = 1
RET

ON IN(X2_2_IOIndex).1 = 0
	SAFINI(X2_2_axis).#RL = 0
RET

!ON MST(X2_2_axis).#ENABLED & (IN(X2_2_IOIndex).24 = 1 | IN(X2_2_IOIndex).25 = 1)
!	KILL X2_2_axis
!	TILL ^MST(X2_2_axis).#MOVE,500 
!	DISABLE X2_2_axis,5028		!Safe Torque Off
!	TILL ^MST(X2_2_axis).#ENABLED
!RET	

ON IN(X2_2_IOIndex).24 = 1 | IN(X2_2_IOIndex).25 = 1
    DISP"X2_2_Event Time : %d",TIME
 	DISP"X2_2_CHECK SF1 Value : %d",IN(X2_2_IOIndex).24
	DISP"X2_2_CHECK SF2 Value : %d",IN(X2_2_IOIndex).25
	WAIT 5
	DISP"X2_2_CHECK FAULT Value : %d", SAFIN(X2_2_axis).9
	DISP"X2_2_CHECK E1 FAULT : %d",AxisErrorCode20
RET

HomeFail:
DISP" E1 homing fail "
IF X2_2_IsModeOfOperationInPDO = 1
	X2_2_ModeOfOperation = 8 
	WAIT 500 
	ECUNMAPOUT (ECGETOFFSET("Mode of operation",X2_2_EtherCATIndex))
ELSE
	COEWRITE/1 (X2_2_EtherCATIndex,0x6060,0,8)						!go back to CSP mode 
END  
WAIT 500 
ECUNMAPIN (ECGETOFFSET("Statusword",X2_2_EtherCATIndex))
ECUNMAPOUT (ECGETOFFSET("Controlword",X2_2_EtherCATIndex))

STOP
#11
!PNAME=
!PDESC=
! X2_3_axis Single-axis_Hiwin_Drive_Homing_Process_VER1.5
!!****** Setting Parameter ******!!
LOCAL REAL X2_3_HmType,X2_3_multi_indHm,X2_3_multi_indVel
LOCAL REAL X2_3_HmVel,X2_3_IndVel,X2_3_HmOffset	
LOCAL INT X2_3_ErrCompensation,X2_3_ErrCompensationSpacing,X2_3_ErrCompIniPos
LOCAL INT ZONE0,X2_3_ErrTableIndex
LOCAL INT X2_3_HiwinDriveHome,X2_3_EtherCATIndex,X2_3_InternalHmType
LOCAL REAL X2_3_ControlUnit
LOCAL INT X2_3_IsModeOfOperationInPDO
LOCAL REAL X2_3_HiwinDriveHmVel,X2_3_HiwinDriveIndVel,X2_3_HiwinDriveHmOffset,X2_3_HiwinDriveHmAcc
!!################ Basic Settings ######################################################################################################
X2_3_IOIndex = 10
X2_3_HmType = 1 								!the method of homing
           									!value 0 : Customized homing
           									!	   1 : find the left limit in negative direction,then find index in positive direction 
           									!      2 : find index in positive direction directly 
X2_3_HmOffset = 0 								! X2_3_HmOffset (unit)
X2_3_HmVel = 30000								! the velocity for homing 	
X2_3_IndVel = 10000 								! the velocity for finding index

X2_3_multi_indHm=0								! multi index structure
											! value 0 : nomal Homing
											!	    1 : find the left limit in negative direction,then slowing leave the limit in positive direction,
											!			then slowing find the left limit in negative direction,then slowing find index in positive direction
X2_3_multi_indVel = 100						! (Do not modify)homing velocity of multi index structure
!!*********************************** With Hiwin Drive homing support HmType 1&2************************************!!
X2_3_IsModeOfOperationInPDO = 0					! Check #ETHERCAT if include Mode of operation slect 1 else select 0
X2_3_HiwinDriveHome = 1						! 1 : With E1 internal homing ; 2 : With E1 Touch probe homing 
X2_3_EtherCATIndex = 6							! EtherCAT nod index
X2_3_ControlUnit = 1/10							! E1 Control unit
!!**************** Configuration of 1D Error Compensation*****************************************************!!
X2_3_ErrCompensation = 1						! 0 : without compensation  ; 1 : turn on the compensation after homing completed 
X2_3_ErrCompIniPos = 0							! the initial position of error compensation
X2_3_ErrCompensationSpacing = 2000				! setting the spacing for error compensation 
!!**********************************************************************************************************!!
!!######################################################################################################################################## 

!!**************************************************************************************************************************************!!
!!************************************************************ Main program ************************************************************!!
FCLEAR X2_3_axis
IF X2_3_HmType=0													! Customized homing
	CALL X2_3_HmType0	
ELSEIF X2_3_HiwinDriveHome=1										! E1 internal
	MFLAGS(X2_3_axis).#HOME=0	
	IF X2_3_HmType=1
		X2_3_InternalHmType = 1
	ELSEIF X2_3_HmType=2
		X2_3_InternalHmType = 34
	ELSE
		DISP"ERROR:The value of X2_3_HmType is invalid!!"
		STOP
	END
	CALL X2_3_HiwinDriveInternalHmType	
ELSEIF X2_3_HiwinDriveHome=2										! Touch probe
		MFLAGS(X2_3_axis).#HOME=0	
	IF X2_3_HmType=1
		CALL X2_3_HiwinDriveTouchProbeHmType1
	ELSEIF X2_3_HmType=2
		CALL X2_3_HiwinDriveTouchProbeHmType2
	ELSE
		DISP"ERROR:The value of X2_3_HmType is invalid!!"
		STOP
	END
ELSE
	DISP"ERROR:The value of X2_3_HmType or X2_3_HiwinDriveHome is invalid!!"
	STOP
END

IF X2_3_ErrCompensation = 1
	DISP "Enable the compensation mode."
	DISP "Execute the compensation prcoess......"
	CALL X2_3_ErrorCompensation	
ELSE
	DISP "Disable error compensation."
	ERRORUNMAP X2_3_axis, ZONE0
END 

IF (X2_3_HmType>=1&X2_3_HmType<=2)
	ENABLE X2_3_axis
	TILL MST(X2_3_axis).#ENABLED
	WAIT 500
	DISP"Go home......"	
	PTP/EV X2_3_axis,0,X2_3_HmVel	
	MFLAGS(X2_3_axis).#HOME=1
END	
FDEF(X2_3_axis).#LL = 1	 		
FDEF(X2_3_axis).#SRL = 1	 		
FDEF(X2_3_axis).#SLL = 1	 
DISP"Homing successful!!"	

STOP	

!!*************************************************************************************************************************************!!
!!************************************************************ Homing process	*******************************************************!!
X2_3_HmType0:
!Customized
RET
STOP
!------------------------------------------------------------------X2_3_HiwinDriveTouchProbeHmType1--------------------------------------------------------------------------------------
X2_3_HiwinDriveTouchProbeHmType1:

FCLEAR X2_3_axis
DISABLE X2_3_axis		
TILL ^MST(X2_3_axis).#ENABLED	
WAIT 500	
MFLAGS(X2_3_axis).#OPEN = 0								! Close loop control
ERRORMAPOFF X2_3_axis, -1									! Close all axis error compensation
MFLAGS(X2_3_axis).#GANTRY = 0								! turn off gantry mode (MFLAGS.25)	
FDEF(X2_3_axis).#SRL = 0	 								! disable software right limit response
FDEF(X2_3_axis).#SLL = 0	 								! disable software left limit response
FDEF(X2_3_axis).#LL = 0	 										! motor is not disable when left limit signal rising.

ENABLE	X2_3_axis	 
TILL MST(X2_3_axis).#ENABLED	 
WAIT 500	
DISP"Start to find the left limit......"
JOG/V X2_3_axis,-X2_3_HmVel									! find the left limit in negative direction
TILL (COEREAD/4 (X2_3_EtherCATIndex,0x60FD,0)& 1) = 1
HALT X2_3_axis 
TILL ^MST(X2_3_axis).#MOVE,1000							! if reach left limit , stop motion
DISP"Already found the left limit!!"

!!!!!!!!!!!!!!!!!!!!multi index Structure Homing Way!!!!!!!!!!!!!!!
IF(X2_3_multi_indHm = 1)	
	JOG/V X2_3_axis,X2_3_multi_indVel							! slowing to leave the limit in negative direction
	TILL (COEREAD/4 (X2_3_EtherCATIndex,0x60FD,0)& 1) = 0	! waiting to leave the limit
	HALT X2_3_axis
	TILL ^MST(X2_3_axis).#MOVE 
	X2_3_IndVel = X2_3_multi_indVel							! define slowing velocity to find index velocity
END
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
ECOUT(ECGETOFFSET("Touch probe function",X2_3_EtherCATIndex),X2_3_TouchProbFun)
WAIT 200
X2_3_TouchProbFun = 0										!Reset Touch probe
WAIT 200
X2_3_TouchProbFun = 17										! Start Touch probe
WAIT 200
DISP"Start to find the index in positive direction......"
JOG/V X2_3_axis,X2_3_IndVel									!find the index in positive direction
TILL (COEREAD/2 (X2_3_EtherCATIndex,0x60B9,0) = 3)			!if reach index	, stop motion
HALT X2_3_axis	
TILL ^MST(X2_3_axis).#MOVE 
DISP"Already found the index!!"
SET FPOS(X2_3_axis) = (COEREAD/4 (X2_3_EtherCATIndex,0x6064,0) - COEREAD/4 (X2_3_EtherCATIndex,0x60BA,0))*X2_3_ControlUnit - X2_3_HmOffset		!set index position as zero.
WAIT 500
ECUNMAPOUT (ECGETOFFSET("Touch probe function",X2_3_EtherCATIndex))	
RET	
STOP
!------------------------------------------------------------------X2_3_HiwinDriveTouchProbeHmType2--------------------------------------------------------------------------------------
X2_3_HiwinDriveTouchProbeHmType2:

FCLEAR X2_3_axis
DISABLE X2_3_axis		
TILL ^MST(X2_3_axis).#ENABLED	
WAIT 500	
MFLAGS(X2_3_axis).#OPEN = 0						! Close loop control
ERRORMAPOFF X2_3_axis, -1							! Close all axis error compensation
MFLAGS(X2_3_axis).#GANTRY = 0	 					! turn off gantry mode (MFLAGS.25)	
FDEF(X2_3_axis).#SRL = 0	 						! disable software right limit response
FDEF(X2_3_axis).#SLL = 0	 						! disable software left limit response
FDEF(X2_3_axis).#LL = 0	 										! motor is not disable when left limit signal rising.

ENABLE	X2_3_axis	 
!!!!!!!!!!!!!!!!!!!!multi index Structure Homing Way!!!!!!!!!!!!!!!
IF(X2_3_multi_indHm = 1)	
	X2_3_IndVel = X2_3_multi_indVel					! define slowing velocity to find index velocity
END
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
ECOUT(ECGETOFFSET("Touch probe function",X2_3_EtherCATIndex),X2_3_TouchProbFun)
WAIT 200
X2_3_TouchProbFun = 0								!Reset Touch probe
WAIT 200
X2_3_TouchProbFun = 17								! Start Touch probe
WAIT 200
DISP"Start to find the index in positive direction......"
JOG/V X2_3_axis,X2_3_IndVel							!find the index in positive direction
TILL (COEREAD/2 (X2_3_EtherCATIndex,0x60B9,0) = 3)	!if reach index	, stop motion
HALT X2_3_axis	
TILL ^MST(X2_3_axis).#MOVE 
DISP"Already found the index!!"
SET FPOS(X2_3_axis) = (COEREAD/4 (X2_3_EtherCATIndex,0x6064,0) - COEREAD/4 (X2_3_EtherCATIndex,0x60BA,0))*X2_3_ControlUnit - X2_3_HmOffset	!set index position as zero.
WAIT 500
ECUNMAPOUT (ECGETOFFSET("Touch probe function",X2_3_EtherCATIndex))		
RET	
STOP
!------------------------------------------------------------------X2_3_HiwinDriveInternalHmType--------------------------------------------------------------------------------------
X2_3_HiwinDriveInternalHmType:

FCLEAR X2_3_axis
FDEF(X2_3_axis).#LL = 0	 										! motor is not disable when left limit signal rising.
FDEF(X2_3_axis).#SRL = 0	 										! disable software right limit response
FDEF(X2_3_axis).#SLL = 0	 										! disable software left limit response
X2_3_HiwinDriveHmVel = X2_3_HmVel/X2_3_ControlUnit
X2_3_HiwinDriveIndVel = X2_3_IndVel/X2_3_ControlUnit
X2_3_HiwinDriveHmOffset = X2_3_HmOffset/X2_3_ControlUnit
X2_3_HiwinDriveHmAcc = ACC(X2_3_axis)/X2_3_ControlUnit

ECIN( ECGETOFFSET("Statusword",X2_3_EtherCATIndex),X2_3_StatusWord)  
ECOUT(ECGETOFFSET("Controlword",X2_3_EtherCATIndex),X2_3_ControlWord)
IF X2_3_IsModeOfOperationInPDO = 1
	ECOUT(ECGETOFFSET("Mode of operation",X2_3_EtherCATIndex),X2_3_ModeOfOperation)
	X2_3_ModeOfOperation = 6
ELSE
	COEWRITE/1 (X2_3_EtherCATIndex,0x6060,0,6) !6 is Homing mode  
END  


COEWRITE/1 (X2_3_EtherCATIndex,0x6098,0,X2_3_InternalHmType)	
COEWRITE/4 (X2_3_EtherCATIndex,0x6099,1,X2_3_HiwinDriveHmVel) 	
COEWRITE/4 (X2_3_EtherCATIndex,0x6099,2,X2_3_HiwinDriveIndVel)	
COEWRITE/4 (X2_3_EtherCATIndex,0x609A,0,X2_3_HiwinDriveHmAcc)	
COEWRITE/4 (X2_3_EtherCATIndex,0x607C,0,X2_3_HiwinDriveHmOffset) 	

X2_3_ControlWord=6  
TILL X2_3_StatusWord.0=1  
X2_3_ControlWord=7  
TILL X2_3_StatusWord.0=1 & X2_3_StatusWord.1=1

WAIT 200 

X2_3_ControlWord=15  
TILL X2_3_StatusWord.0=1 & X2_3_StatusWord.1=1 & X2_3_StatusWord.2=1	!Enabled
!Start Homing Procedure - Bit 4  
X2_3_ControlWord=31  											!Start Home
TILL X2_3_StatusWord.12=1 & X2_3_StatusWord.10=1 | X2_3_StatusWord.13=1				!Home Finished

IF X2_3_StatusWord.13=1
	CALL HomeFail
END


X2_3_ControlWord=0  

WAIT 100

IF X2_3_IsModeOfOperationInPDO = 1
	X2_3_ModeOfOperation = 8 
	WAIT 500 
	ECUNMAPOUT (ECGETOFFSET("Mode of operation",X2_3_EtherCATIndex))
ELSE
	COEWRITE/1 (X2_3_EtherCATIndex,0x6060,0,8)						!go back to CSP mode 
END  
WAIT 500 
ECUNMAPIN (ECGETOFFSET("Statusword",X2_3_EtherCATIndex))
ECUNMAPOUT (ECGETOFFSET("Controlword",X2_3_EtherCATIndex))

WAIT 500 
DISABLE X2_3_axis
TILL ^MST(X2_3_axis).#ENABLED 

RET
STOP
!!*************************************************************************************************************************************!!
!!****************************************************** Error Compensation Process ***************************************************!!
X2_3_ErrorCompensation:
!---------- X2_3_axis Error Compensation Table ------------!
X2_3_ErrTable(0)=	0	;
X2_3_ErrTable(1)=	0	;
X2_3_ErrTable(2)=	0.2	;
X2_3_ErrTable(3)=	0.2	;
X2_3_ErrTable(4)=	0.5	;
X2_3_ErrTable(5)=	0.6	;
X2_3_ErrTable(6)=	0.8	;
X2_3_ErrTable(7)=	1.2	;
X2_3_ErrTable(8)=	1.3	;
X2_3_ErrTable(9)=	1.5	;
X2_3_ErrTable(10)=	1.7	;



!-------------------------------------------------------!
X2_3_ErrTableIndex = 0
WHILE X2_3_ErrTableIndex < SIZEOF(X2_3_ErrTable)
	X2_3_ErrTable(X2_3_ErrTableIndex) = -X2_3_ErrTable(X2_3_ErrTableIndex)
	X2_3_ErrTableIndex = X2_3_ErrTableIndex + 1
END
ERRORUNMAP X2_3_axis, ZONE0
ERRORMAP1D X2_3_axis, ZONE0, X2_3_ErrCompIniPos, X2_3_ErrCompensationSpacing, X2_3_ErrTable
ERRORMAPON X2_3_axis, ZONE0

WAIT 500	
DISP "Cmpensation Procces's completed!"

RET 
STOP
!!#############################################################################################################################

ON MFLAGS(X2_3_axis).#HOME=1 & TPOS(X2_3_axis) < SLLIMIT(X2_3_axis) 
	IF( FDEF(X2_3_axis).#SLL=1 & FMASK(X2_3_axis).#SLL=1 & ^(GMTYPE(X2_3_axis)=5))
		KILL X2_3_axis,5016	!Software Left Limit
		TPOS(X2_3_axis)=FPOS(X2_3_axis)
		DISP "TPOS(X2_3_axis) < SLLIMIT(X2_3_axis)"
	END
RET

ON MFLAGS(X2_3_axis).#HOME=1 & TPOS(X2_3_axis) > SRLIMIT(X2_3_axis) 
	IF(FDEF(X2_3_axis).#SRL=1 & FMASK(X2_3_axis).#SRL=1 & ^(GMTYPE(X2_3_axis)=5))
		KILL X2_3_axis,5015	!Software Right Limit
		TPOS(X2_3_axis)=FPOS(X2_3_axis)
		DISP "TPOS(X2_3_axis) > SRLIMIT(X2_3_axis)"
	END
RET


ON MFLAGS(X2_3_axis).#HOME=0 & RVEL(X2_3_axis) > XVEL(X2_3_axis)*0.5 & ^MST(X2_3_axis).#INPOS
	IMM VEL(X2_3_axis) = XVEL(X2_3_axis)*0.45 
RET

ON MFLAGS(X2_3_axis).#HOME=0 & RVEL(X2_3_axis) < -XVEL(X2_3_axis)*0.5 & ^MST(X2_3_axis).#INPOS
	IMM VEL(X2_3_axis) = -XVEL(X2_3_axis)*0.45 
RET

AUTOEXEC:
	X2_3_IOIndex = 10
	MFLAGS(X2_3_axis).#HOME=0
STOP

ON IN(X2_3_IOIndex).0 = 1
	SAFINI(X2_3_axis).#LL = 1
RET

ON IN(X2_3_IOIndex).0 = 0
	SAFINI(X2_3_axis).#LL = 0
RET

ON IN(X2_3_IOIndex).1 = 1
	SAFINI(X2_3_axis).#RL = 1
RET

ON IN(X2_3_IOIndex).1 = 0
	SAFINI(X2_3_axis).#RL = 0
RET

!ON MST(X2_3_axis).#ENABLED & (IN(X2_3_IOIndex).24 = 1 | IN(X2_3_IOIndex).25 = 1)
!	KILL X2_3_axis
!	TILL ^MST(X2_3_axis).#MOVE,500 
!	DISABLE X2_3_axis,5028		!Safe Torque Off
!	TILL ^MST(X2_3_axis).#ENABLED
!RET	

ON IN(X2_3_IOIndex).24 = 1 | IN(X2_3_IOIndex).25 = 1
    DISP"X2_3_Event Time : %d",TIME
 	DISP"X2_3_CHECK SF1 Value : %d",IN(X2_3_IOIndex).24
	DISP"X2_3_CHECK SF2 Value : %d",IN(X2_3_IOIndex).25
	WAIT 5
	DISP"X2_3_CHECK FAULT Value : %d", SAFIN(X2_3_axis).9
	DISP"X2_3_CHECK E1 FAULT : %d",AxisErrorCode21

RET

HomeFail:
DISP" E1 homing fail "
IF X2_3_IsModeOfOperationInPDO = 1
	X2_3_ModeOfOperation = 8 
	WAIT 500 
	ECUNMAPOUT (ECGETOFFSET("Mode of operation",X2_3_EtherCATIndex))
ELSE
	COEWRITE/1 (X2_3_EtherCATIndex,0x6060,0,8)						!go back to CSP mode 
END  
WAIT 500 
ECUNMAPIN (ECGETOFFSET("Statusword",X2_3_EtherCATIndex))
ECUNMAPOUT (ECGETOFFSET("Controlword",X2_3_EtherCATIndex))

STOP
#12
!PNAME=
!PDESC=
! X2_4_axis Single-axis_Hiwin_Drive_Homing_Process_VER1.5
!!****** Setting Parameter ******!!
LOCAL REAL X2_4_HmType,X2_4_multi_indHm,X2_4_multi_indVel
LOCAL REAL X2_4_HmVel,X2_4_IndVel,X2_4_HmOffset	
LOCAL INT X2_4_ErrCompensation,X2_4_ErrCompensationSpacing,X2_4_ErrCompIniPos
LOCAL INT ZONE0,X2_4_ErrTableIndex
LOCAL INT X2_4_HiwinDriveHome,X2_4_EtherCATIndex,X2_4_InternalHmType
LOCAL REAL X2_4_ControlUnit
LOCAL INT X2_4_IsModeOfOperationInPDO
LOCAL REAL X2_4_HiwinDriveHmVel,X2_4_HiwinDriveIndVel,X2_4_HiwinDriveHmOffset,X2_4_HiwinDriveHmAcc
!!################ Basic Settings ######################################################################################################
X2_4_IOIndex = 11
X2_4_HmType = 1 								!the method of homing
           									!value 0 : Customized homing
           									!	   1 : find the left limit in negative direction,then find index in positive direction 
           									!      2 : find index in positive direction directly 
X2_4_HmOffset = 0 								! X2_4_HmOffset (unit)
X2_4_HmVel = 30000								! the velocity for homing 	
X2_4_IndVel = 10000 								! the velocity for finding index

X2_4_multi_indHm=0								! multi index structure
											! value 0 : nomal Homing
											!	    1 : find the left limit in negative direction,then slowing leave the limit in positive direction,
											!			then slowing find the left limit in negative direction,then slowing find index in positive direction
X2_4_multi_indVel = 100						! (Do not modify)homing velocity of multi index structure
!!*********************************** With Hiwin Drive homing support HmType 1&2************************************!!
X2_4_IsModeOfOperationInPDO = 0					! Check #ETHERCAT if include Mode of operation slect 1 else select 0
X2_4_HiwinDriveHome = 1						! 1 : With E1 internal homing ; 2 : With E1 Touch probe homing 
X2_4_EtherCATIndex = 7							! EtherCAT nod index
X2_4_ControlUnit = 1/10							! E1 Control unit
!!**************** Configuration of 1D Error Compensation*****************************************************!!
X2_4_ErrCompensation = 1						! 0 : without compensation  ; 1 : turn on the compensation after homing completed 
X2_4_ErrCompIniPos = 0							! the initial position of error compensation
X2_4_ErrCompensationSpacing = 2000				! setting the spacing for error compensation 
!!**********************************************************************************************************!!
!!######################################################################################################################################## 

!!**************************************************************************************************************************************!!
!!************************************************************ Main program ************************************************************!!
FCLEAR X2_4_axis
IF X2_4_HmType=0													! Customized homing
	CALL X2_4_HmType0	
ELSEIF X2_4_HiwinDriveHome=1										! E1 internal
	MFLAGS(X2_4_axis).#HOME=0	
	IF X2_4_HmType=1
		X2_4_InternalHmType = 1
	ELSEIF X2_4_HmType=2
		X2_4_InternalHmType = 34
	ELSE
		DISP"ERROR:The value of X2_4_HmType is invalid!!"
		STOP
	END
	CALL X2_4_HiwinDriveInternalHmType	
ELSEIF X2_4_HiwinDriveHome=2										! Touch probe
		MFLAGS(X2_4_axis).#HOME=0	
	IF X2_4_HmType=1
		CALL X2_4_HiwinDriveTouchProbeHmType1
	ELSEIF X2_4_HmType=2
		CALL X2_4_HiwinDriveTouchProbeHmType2
	ELSE
		DISP"ERROR:The value of X2_4_HmType is invalid!!"
		STOP
	END
ELSE
	DISP"ERROR:The value of X2_4_HmType or X2_4_HiwinDriveHome is invalid!!"
	STOP
END

IF X2_4_ErrCompensation = 1
	DISP "Enable the compensation mode."
	DISP "Execute the compensation prcoess......"
	CALL X2_4_ErrorCompensation	
ELSE
	DISP "Disable error compensation."
	ERRORUNMAP X2_4_axis, ZONE0
END 

IF (X2_4_HmType>=1&X2_4_HmType<=2)
	ENABLE X2_4_axis
	TILL MST(X2_4_axis).#ENABLED
	WAIT 500
	DISP"Go home......"	
	PTP/EV X2_4_axis,0,X2_4_HmVel	
	MFLAGS(X2_4_axis).#HOME=1
END	
FDEF(X2_4_axis).#LL = 1	 		
FDEF(X2_4_axis).#SRL = 1	 		
FDEF(X2_4_axis).#SLL = 1	 
DISP"Homing successful!!"	

STOP	

!!*************************************************************************************************************************************!!
!!************************************************************ Homing process	*******************************************************!!
X2_4_HmType0:
!Customized
RET
STOP
!------------------------------------------------------------------X2_4_HiwinDriveTouchProbeHmType1--------------------------------------------------------------------------------------
X2_4_HiwinDriveTouchProbeHmType1:

FCLEAR X2_4_axis
DISABLE X2_4_axis		
TILL ^MST(X2_4_axis).#ENABLED	
WAIT 500	
MFLAGS(X2_4_axis).#OPEN = 0								! Close loop control
ERRORMAPOFF X2_4_axis, -1									! Close all axis error compensation
MFLAGS(X2_4_axis).#GANTRY = 0								! turn off gantry mode (MFLAGS.25)	
FDEF(X2_4_axis).#SRL = 0	 								! disable software right limit response
FDEF(X2_4_axis).#SLL = 0	 								! disable software left limit response
FDEF(X2_4_axis).#LL = 0	 										! motor is not disable when left limit signal rising.

ENABLE	X2_4_axis	 
TILL MST(X2_4_axis).#ENABLED	 
WAIT 500	
DISP"Start to find the left limit......"
JOG/V X2_4_axis,-X2_4_HmVel									! find the left limit in negative direction
TILL (COEREAD/4 (X2_4_EtherCATIndex,0x60FD,0)& 1) = 1
HALT X2_4_axis 
TILL ^MST(X2_4_axis).#MOVE,1000							! if reach left limit , stop motion
DISP"Already found the left limit!!"

!!!!!!!!!!!!!!!!!!!!multi index Structure Homing Way!!!!!!!!!!!!!!!
IF(X2_4_multi_indHm = 1)	
	JOG/V X2_4_axis,X2_4_multi_indVel							! slowing to leave the limit in negative direction
	TILL (COEREAD/4 (X2_4_EtherCATIndex,0x60FD,0)& 1) = 0	! waiting to leave the limit
	HALT X2_4_axis
	TILL ^MST(X2_4_axis).#MOVE 
	X2_4_IndVel = X2_4_multi_indVel							! define slowing velocity to find index velocity
END
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
ECOUT(ECGETOFFSET("Touch probe function",X2_4_EtherCATIndex),X2_4_TouchProbFun)
WAIT 200
X2_4_TouchProbFun = 0										!Reset Touch probe
WAIT 200
X2_4_TouchProbFun = 17										! Start Touch probe
WAIT 200
DISP"Start to find the index in positive direction......"
JOG/V X2_4_axis,X2_4_IndVel									!find the index in positive direction
TILL (COEREAD/2 (X2_4_EtherCATIndex,0x60B9,0) = 3)			!if reach index	, stop motion
HALT X2_4_axis	
TILL ^MST(X2_4_axis).#MOVE 
DISP"Already found the index!!"
SET FPOS(X2_4_axis) = (COEREAD/4 (X2_4_EtherCATIndex,0x6064,0) - COEREAD/4 (X2_4_EtherCATIndex,0x60BA,0))*X2_4_ControlUnit - X2_4_HmOffset		!set index position as zero.
WAIT 500
ECUNMAPOUT (ECGETOFFSET("Touch probe function",X2_4_EtherCATIndex))	
RET	
STOP
!------------------------------------------------------------------X2_4_HiwinDriveTouchProbeHmType2--------------------------------------------------------------------------------------
X2_4_HiwinDriveTouchProbeHmType2:

FCLEAR X2_4_axis
DISABLE X2_4_axis		
TILL ^MST(X2_4_axis).#ENABLED	
WAIT 500	
MFLAGS(X2_4_axis).#OPEN = 0						! Close loop control
ERRORMAPOFF X2_4_axis, -1							! Close all axis error compensation
MFLAGS(X2_4_axis).#GANTRY = 0	 					! turn off gantry mode (MFLAGS.25)	
FDEF(X2_4_axis).#SRL = 0	 						! disable software right limit response
FDEF(X2_4_axis).#SLL = 0	 						! disable software left limit response
FDEF(X2_4_axis).#LL = 0	 										! motor is not disable when left limit signal rising.

ENABLE	X2_4_axis	 
!!!!!!!!!!!!!!!!!!!!multi index Structure Homing Way!!!!!!!!!!!!!!!
IF(X2_4_multi_indHm = 1)	
	X2_4_IndVel = X2_4_multi_indVel					! define slowing velocity to find index velocity
END
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
ECOUT(ECGETOFFSET("Touch probe function",X2_4_EtherCATIndex),X2_4_TouchProbFun)
WAIT 200
X2_4_TouchProbFun = 0								!Reset Touch probe
WAIT 200
X2_4_TouchProbFun = 17								! Start Touch probe
WAIT 200
DISP"Start to find the index in positive direction......"
JOG/V X2_4_axis,X2_4_IndVel							!find the index in positive direction
TILL (COEREAD/2 (X2_4_EtherCATIndex,0x60B9,0) = 3)	!if reach index	, stop motion
HALT X2_4_axis	
TILL ^MST(X2_4_axis).#MOVE 
DISP"Already found the index!!"
SET FPOS(X2_4_axis) = (COEREAD/4 (X2_4_EtherCATIndex,0x6064,0) - COEREAD/4 (X2_4_EtherCATIndex,0x60BA,0))*X2_4_ControlUnit - X2_4_HmOffset	!set index position as zero.
WAIT 500
ECUNMAPOUT (ECGETOFFSET("Touch probe function",X2_4_EtherCATIndex))		
RET	
STOP
!------------------------------------------------------------------X2_4_HiwinDriveInternalHmType--------------------------------------------------------------------------------------
X2_4_HiwinDriveInternalHmType:

FCLEAR X2_4_axis
FDEF(X2_4_axis).#LL = 0	 										! motor is not disable when left limit signal rising.
FDEF(X2_4_axis).#SRL = 0	 										! disable software right limit response
FDEF(X2_4_axis).#SLL = 0	 										! disable software left limit response
X2_4_HiwinDriveHmVel = X2_4_HmVel/X2_4_ControlUnit
X2_4_HiwinDriveIndVel = X2_4_IndVel/X2_4_ControlUnit
X2_4_HiwinDriveHmOffset = X2_4_HmOffset/X2_4_ControlUnit
X2_4_HiwinDriveHmAcc = ACC(X2_4_axis)/X2_4_ControlUnit

ECIN( ECGETOFFSET("Statusword",X2_4_EtherCATIndex),X2_4_StatusWord)  
ECOUT(ECGETOFFSET("Controlword",X2_4_EtherCATIndex),X2_4_ControlWord)
IF X2_4_IsModeOfOperationInPDO = 1
	ECOUT(ECGETOFFSET("Mode of operation",X2_4_EtherCATIndex),X2_4_ModeOfOperation)
	X2_4_ModeOfOperation = 6
ELSE
	COEWRITE/1 (X2_4_EtherCATIndex,0x6060,0,6) !6 is Homing mode  
END  


COEWRITE/1 (X2_4_EtherCATIndex,0x6098,0,X2_4_InternalHmType)	
COEWRITE/4 (X2_4_EtherCATIndex,0x6099,1,X2_4_HiwinDriveHmVel) 	
COEWRITE/4 (X2_4_EtherCATIndex,0x6099,2,X2_4_HiwinDriveIndVel)	
COEWRITE/4 (X2_4_EtherCATIndex,0x609A,0,X2_4_HiwinDriveHmAcc)	
COEWRITE/4 (X2_4_EtherCATIndex,0x607C,0,X2_4_HiwinDriveHmOffset) 	

X2_4_ControlWord=6  
TILL X2_4_StatusWord.0=1  
X2_4_ControlWord=7  
TILL X2_4_StatusWord.0=1 & X2_4_StatusWord.1=1

WAIT 200 

X2_4_ControlWord=15  
TILL X2_4_StatusWord.0=1 & X2_4_StatusWord.1=1 & X2_4_StatusWord.2=1	!Enabled
!Start Homing Procedure - Bit 4  
X2_4_ControlWord=31  											!Start Home
TILL X2_4_StatusWord.12=1 & X2_4_StatusWord.10=1 | X2_4_StatusWord.13=1				!Home Finished

IF X2_4_StatusWord.13=1
	CALL HomeFail
END


X2_4_ControlWord=0  

WAIT 100

IF X2_4_IsModeOfOperationInPDO = 1
	X2_4_ModeOfOperation = 8 
	WAIT 500 
	ECUNMAPOUT (ECGETOFFSET("Mode of operation",X2_4_EtherCATIndex))
ELSE
	COEWRITE/1 (X2_4_EtherCATIndex,0x6060,0,8)						!go back to CSP mode 
END  
WAIT 500 
ECUNMAPIN (ECGETOFFSET("Statusword",X2_4_EtherCATIndex))
ECUNMAPOUT (ECGETOFFSET("Controlword",X2_4_EtherCATIndex))

WAIT 500 
DISABLE X2_4_axis
TILL ^MST(X2_4_axis).#ENABLED 

RET
STOP
!!*************************************************************************************************************************************!!
!!****************************************************** Error Compensation Process ***************************************************!!
X2_4_ErrorCompensation:
!---------- X2_4_axis Error Compensation Table ------------!
X2_4_ErrTable(0)=	0	;
X2_4_ErrTable(1)=	-0.3	;
X2_4_ErrTable(2)=	-0.4	;
X2_4_ErrTable(3)=	-0.3	;
X2_4_ErrTable(4)=	-0.2	;
X2_4_ErrTable(5)=	0	;
X2_4_ErrTable(6)=	0	;
X2_4_ErrTable(7)=	0.3	;
X2_4_ErrTable(8)=	0.5	;
X2_4_ErrTable(9)=	0.8	;
X2_4_ErrTable(10)=	0.9	;




!-------------------------------------------------------!
X2_4_ErrTableIndex = 0
WHILE X2_4_ErrTableIndex < SIZEOF(X2_4_ErrTable)
	X2_4_ErrTable(X2_4_ErrTableIndex) = -X2_4_ErrTable(X2_4_ErrTableIndex)
	X2_4_ErrTableIndex = X2_4_ErrTableIndex + 1
END
ERRORUNMAP X2_4_axis, ZONE0
ERRORMAP1D X2_4_axis, ZONE0, X2_4_ErrCompIniPos, X2_4_ErrCompensationSpacing, X2_4_ErrTable
ERRORMAPON X2_4_axis, ZONE0

WAIT 500	
DISP "Cmpensation Procces's completed!"

RET 
STOP
!!#############################################################################################################################

ON MFLAGS(X2_4_axis).#HOME=1 & TPOS(X2_4_axis) < SLLIMIT(X2_4_axis) 
	IF( FDEF(X2_4_axis).#SLL=1 & FMASK(X2_4_axis).#SLL=1 & ^(GMTYPE(X2_4_axis)=5))
		KILL X2_4_axis,5016	!Software Left Limit
		TPOS(X2_4_axis)=FPOS(X2_4_axis)
		DISP "TPOS(X2_4_axis) < SLLIMIT(X2_4_axis)"
	END
RET

ON MFLAGS(X2_4_axis).#HOME=1 & TPOS(X2_4_axis) > SRLIMIT(X2_4_axis) 
	IF(FDEF(X2_4_axis).#SRL=1 & FMASK(X2_4_axis).#SRL=1 & ^(GMTYPE(X2_4_axis)=5))
		KILL X2_4_axis,5015	!Software Right Limit
		TPOS(X2_4_axis)=FPOS(X2_4_axis)
		DISP "TPOS(X2_4_axis) > SRLIMIT(X2_4_axis)"
	END
RET


ON MFLAGS(X2_4_axis).#HOME=0 & RVEL(X2_4_axis) > XVEL(X2_4_axis)*0.5 & ^MST(X2_4_axis).#INPOS
	IMM VEL(X2_4_axis) = XVEL(X2_4_axis)*0.45 
RET

ON MFLAGS(X2_4_axis).#HOME=0 & RVEL(X2_4_axis) < -XVEL(X2_4_axis)*0.5 & ^MST(X2_4_axis).#INPOS
	IMM VEL(X2_4_axis) = -XVEL(X2_4_axis)*0.45 
RET

AUTOEXEC:
	X2_4_IOIndex = 11
	MFLAGS(X2_4_axis).#HOME=0
STOP

ON IN(X2_4_IOIndex).0 = 1
	SAFINI(X2_4_axis).#LL = 1
RET

ON IN(X2_4_IOIndex).0 = 0
	SAFINI(X2_4_axis).#LL = 0
RET

ON IN(X2_4_IOIndex).1 = 1
	SAFINI(X2_4_axis).#RL = 1
RET

ON IN(X2_4_IOIndex).1 = 0
	SAFINI(X2_4_axis).#RL = 0
RET

!ON MST(X2_4_axis).#ENABLED & (IN(X2_4_IOIndex).24 = 1 | IN(X2_4_IOIndex).25 = 1)
!	KILL X2_4_axis
!	TILL ^MST(X2_4_axis).#MOVE,500 
!	DISABLE X2_4_axis,5028		!Safe Torque Off
!	TILL ^MST(X2_4_axis).#ENABLED
!RET	

ON IN(X2_4_IOIndex).24 = 1 | IN(X2_4_IOIndex).25 = 1
    DISP"X2_4_Event Time : %d",TIME
 	DISP"X2_4_CHECK SF1 Value : %d",IN(X2_4_IOIndex).24
	DISP"X2_4_CHECK SF2 Value : %d",IN(X2_4_IOIndex).25
	WAIT 5
	DISP"X2_4_CHECK FAULT Value : %d", SAFIN(X2_4_axis).9
	DISP"X2_4_CHECK E1 FAULT : %d",AxisErrorCode22
RET

HomeFail:
DISP" E1 homing fail "
IF X2_4_IsModeOfOperationInPDO = 1
	X2_4_ModeOfOperation = 8 
	WAIT 500 
	ECUNMAPOUT (ECGETOFFSET("Mode of operation",X2_4_EtherCATIndex))
ELSE
	COEWRITE/1 (X2_4_EtherCATIndex,0x6060,0,8)						!go back to CSP mode 
END  
WAIT 500 
ECUNMAPIN (ECGETOFFSET("Statusword",X2_4_EtherCATIndex))
ECUNMAPOUT (ECGETOFFSET("Controlword",X2_4_EtherCATIndex))


STOP
#13
!PNAME=
!PDESC=
! Z2_1_axis Single-axis_Hiwin_Drive_Homing_Process_VER1.5
!!****** Setting Parameter ******!!
LOCAL REAL Z2_1_HmType,Z2_1_multi_indHm,Z2_1_multi_indVel
LOCAL REAL Z2_1_HmVel,Z2_1_IndVel,Z2_1_HmOffset	
LOCAL INT Z2_1_ErrCompensation,Z2_1_ErrCompensationSpacing,Z2_1_ErrCompIniPos
LOCAL INT ZONE0,Z2_1_ErrTableIndex
LOCAL INT Z2_1_HiwinDriveHome,Z2_1_EtherCATIndex,Z2_1_InternalHmType
LOCAL REAL Z2_1_ControlUnit
LOCAL INT Z2_1_IsModeOfOperationInPDO
LOCAL REAL Z2_1_HiwinDriveHmVel,Z2_1_HiwinDriveIndVel,Z2_1_HiwinDriveHmOffset,Z2_1_HiwinDriveHmAcc
!!################ Basic Settings ######################################################################################################
Z2_1_IOIndex = 12
Z2_1_HmType = 1 								!the method of homing
           									!value 0 : Customized homing
           									!	   1 : find the left limit in negative direction,then find index in positive direction 
           									!      2 : find index in positive direction directly 
Z2_1_HmOffset = 0 								! Z2_1_HmOffset (unit)
Z2_1_HmVel = 30000								! the velocity for homing 	
Z2_1_IndVel = 10000 								! the velocity for finding index

Z2_1_multi_indHm=0								! multi index structure
											! value 0 : nomal Homing
											!	    1 : find the left limit in negative direction,then slowing leave the limit in positive direction,
											!			then slowing find the left limit in negative direction,then slowing find index in positive direction
Z2_1_multi_indVel = 100						! (Do not modify)homing velocity of multi index structure
!!*********************************** With Hiwin Drive homing support HmType 1&2************************************!!
Z2_1_IsModeOfOperationInPDO = 0					! Check #ETHERCAT if include Mode of operation slect 1 else select 0
Z2_1_HiwinDriveHome = 1						! 1 : With E1 internal homing ; 2 : With E1 Touch probe homing 
Z2_1_EtherCATIndex = 8							! EtherCAT nod index
Z2_1_ControlUnit = 1/10							! E1 Control unit
!!**************** Configuration of 1D Error Compensation*****************************************************!!
Z2_1_ErrCompensation = 1						! 0 : without compensation  ; 1 : turn on the compensation after homing completed 
Z2_1_ErrCompIniPos = 0							! the initial position of error compensation
Z2_1_ErrCompensationSpacing = 4000				! setting the spacing for error compensation 
!!**********************************************************************************************************!!
!!######################################################################################################################################## 

!!**************************************************************************************************************************************!!
!!************************************************************ Main program ************************************************************!!
FCLEAR Z2_1_axis
IF Z2_1_HmType=0													! Customized homing
	CALL Z2_1_HmType0	
ELSEIF Z2_1_HiwinDriveHome=1										! E1 internal
	MFLAGS(Z2_1_axis).#HOME=0	
	IF Z2_1_HmType=1
		Z2_1_InternalHmType = 1
	ELSEIF Z2_1_HmType=2
		Z2_1_InternalHmType = 34
	ELSE
		DISP"ERROR:The value of Z2_1_HmType is invalid!!"
		STOP
	END
	CALL Z2_1_HiwinDriveInternalHmType	
ELSEIF Z2_1_HiwinDriveHome=2										! Touch probe
		MFLAGS(Z2_1_axis).#HOME=0	
	IF Z2_1_HmType=1
		CALL Z2_1_HiwinDriveTouchProbeHmType1
	ELSEIF Z2_1_HmType=2
		CALL Z2_1_HiwinDriveTouchProbeHmType2
	ELSE
		DISP"ERROR:The value of Z2_1_HmType is invalid!!"
		STOP
	END
ELSE
	DISP"ERROR:The value of Z2_1_HmType or Z2_1_HiwinDriveHome is invalid!!"
	STOP
END

IF Z2_1_ErrCompensation = 1
	DISP "Enable the compensation mode."
	DISP "Execute the compensation prcoess......"
	CALL Z2_1_ErrorCompensation	
ELSE
	DISP "Disable error compensation."
	ERRORUNMAP Z2_1_axis, ZONE0
END 

IF (Z2_1_HmType>=1&Z2_1_HmType<=2)
	ENABLE Z2_1_axis
	TILL MST(Z2_1_axis).#ENABLED
	WAIT 500
	DISP"Go home......"	
	PTP/EV Z2_1_axis,0,Z2_1_HmVel	
	MFLAGS(Z2_1_axis).#HOME=1
END	
FDEF(Z2_1_axis).#LL = 1	 		
FDEF(Z2_1_axis).#SRL = 1	 		
FDEF(Z2_1_axis).#SLL = 1	 
DISP"Homing successful!!"	

STOP	

!!*************************************************************************************************************************************!!
!!************************************************************ Homing process	*******************************************************!!
Z2_1_HmType0:
!Customized
RET
STOP
!------------------------------------------------------------------Z2_1_HiwinDriveTouchProbeHmType1--------------------------------------------------------------------------------------
Z2_1_HiwinDriveTouchProbeHmType1:

FCLEAR Z2_1_axis
DISABLE Z2_1_axis		
TILL ^MST(Z2_1_axis).#ENABLED	
WAIT 500	
MFLAGS(Z2_1_axis).#OPEN = 0								! Close loop control
ERRORMAPOFF Z2_1_axis, -1									! Close all axis error compensation
MFLAGS(Z2_1_axis).#GANTRY = 0								! turn off gantry mode (MFLAGS.25)	
FDEF(Z2_1_axis).#SRL = 0	 								! disable software right limit response
FDEF(Z2_1_axis).#SLL = 0	 								! disable software left limit response
FDEF(Z2_1_axis).#LL = 0	 										! motor is not disable when left limit signal rising.

ENABLE	Z2_1_axis	 
TILL MST(Z2_1_axis).#ENABLED	 
WAIT 500	
DISP"Start to find the left limit......"
JOG/V Z2_1_axis,-Z2_1_HmVel									! find the left limit in negative direction
TILL (COEREAD/4 (Z2_1_EtherCATIndex,0x60FD,0)& 1) = 1
HALT Z2_1_axis 
TILL ^MST(Z2_1_axis).#MOVE,1000							! if reach left limit , stop motion
DISP"Already found the left limit!!"

!!!!!!!!!!!!!!!!!!!!multi index Structure Homing Way!!!!!!!!!!!!!!!
IF(Z2_1_multi_indHm = 1)	
	JOG/V Z2_1_axis,Z2_1_multi_indVel							! slowing to leave the limit in negative direction
	TILL (COEREAD/4 (Z2_1_EtherCATIndex,0x60FD,0)& 1) = 0	! waiting to leave the limit
	HALT Z2_1_axis
	TILL ^MST(Z2_1_axis).#MOVE 
	Z2_1_IndVel = Z2_1_multi_indVel							! define slowing velocity to find index velocity
END
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
ECOUT(ECGETOFFSET("Touch probe function",Z2_1_EtherCATIndex),Z2_1_TouchProbFun)
WAIT 200
Z2_1_TouchProbFun = 0										!Reset Touch probe
WAIT 200
Z2_1_TouchProbFun = 17										! Start Touch probe
WAIT 200
DISP"Start to find the index in positive direction......"
JOG/V Z2_1_axis,Z2_1_IndVel									!find the index in positive direction
TILL (COEREAD/2 (Z2_1_EtherCATIndex,0x60B9,0) = 3)			!if reach index	, stop motion
HALT Z2_1_axis	
TILL ^MST(Z2_1_axis).#MOVE 
DISP"Already found the index!!"
SET FPOS(Z2_1_axis) = (COEREAD/4 (Z2_1_EtherCATIndex,0x6064,0) - COEREAD/4 (Z2_1_EtherCATIndex,0x60BA,0))*Z2_1_ControlUnit - Z2_1_HmOffset		!set index position as zero.
WAIT 500
ECUNMAPOUT (ECGETOFFSET("Touch probe function",Z2_1_EtherCATIndex))	
RET	
STOP
!------------------------------------------------------------------Z2_1_HiwinDriveTouchProbeHmType2--------------------------------------------------------------------------------------
Z2_1_HiwinDriveTouchProbeHmType2:

FCLEAR Z2_1_axis
DISABLE Z2_1_axis		
TILL ^MST(Z2_1_axis).#ENABLED	
WAIT 500	
MFLAGS(Z2_1_axis).#OPEN = 0						! Close loop control
ERRORMAPOFF Z2_1_axis, -1							! Close all axis error compensation
MFLAGS(Z2_1_axis).#GANTRY = 0	 					! turn off gantry mode (MFLAGS.25)	
FDEF(Z2_1_axis).#SRL = 0	 						! disable software right limit response
FDEF(Z2_1_axis).#SLL = 0	 						! disable software left limit response
FDEF(Z2_1_axis).#LL = 0	 										! motor is not disable when left limit signal rising.

ENABLE	Z2_1_axis	 
!!!!!!!!!!!!!!!!!!!!multi index Structure Homing Way!!!!!!!!!!!!!!!
IF(Z2_1_multi_indHm = 1)	
	Z2_1_IndVel = Z2_1_multi_indVel					! define slowing velocity to find index velocity
END
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
ECOUT(ECGETOFFSET("Touch probe function",Z2_1_EtherCATIndex),Z2_1_TouchProbFun)
WAIT 200
Z2_1_TouchProbFun = 0								!Reset Touch probe
WAIT 200
Z2_1_TouchProbFun = 17								! Start Touch probe
WAIT 200
DISP"Start to find the index in positive direction......"
JOG/V Z2_1_axis,Z2_1_IndVel							!find the index in positive direction
TILL (COEREAD/2 (Z2_1_EtherCATIndex,0x60B9,0) = 3)	!if reach index	, stop motion
HALT Z2_1_axis	
TILL ^MST(Z2_1_axis).#MOVE 
DISP"Already found the index!!"
SET FPOS(Z2_1_axis) = (COEREAD/4 (Z2_1_EtherCATIndex,0x6064,0) - COEREAD/4 (Z2_1_EtherCATIndex,0x60BA,0))*Z2_1_ControlUnit - Z2_1_HmOffset	!set index position as zero.
WAIT 500
ECUNMAPOUT (ECGETOFFSET("Touch probe function",Z2_1_EtherCATIndex))		
RET	
STOP
!------------------------------------------------------------------Z2_1_HiwinDriveInternalHmType--------------------------------------------------------------------------------------
Z2_1_HiwinDriveInternalHmType:

FCLEAR Z2_1_axis
FDEF(Z2_1_axis).#LL = 0	 										! motor is not disable when left limit signal rising.
FDEF(Z2_1_axis).#SRL = 0	 										! disable software right limit response
FDEF(Z2_1_axis).#SLL = 0	 										! disable software left limit response
Z2_1_HiwinDriveHmVel = Z2_1_HmVel/Z2_1_ControlUnit
Z2_1_HiwinDriveIndVel = Z2_1_IndVel/Z2_1_ControlUnit
Z2_1_HiwinDriveHmOffset = Z2_1_HmOffset/Z2_1_ControlUnit
Z2_1_HiwinDriveHmAcc = ACC(Z2_1_axis)/Z2_1_ControlUnit

ECIN( ECGETOFFSET("Statusword",Z2_1_EtherCATIndex),Z2_1_StatusWord)  
ECOUT(ECGETOFFSET("Controlword",Z2_1_EtherCATIndex),Z2_1_ControlWord)
IF Z2_1_IsModeOfOperationInPDO = 1
	ECOUT(ECGETOFFSET("Mode of operation",Z2_1_EtherCATIndex),Z2_1_ModeOfOperation)
	Z2_1_ModeOfOperation = 6
ELSE
	COEWRITE/1 (Z2_1_EtherCATIndex,0x6060,0,6) !6 is Homing mode  
END  


COEWRITE/1 (Z2_1_EtherCATIndex,0x6098,0,Z2_1_InternalHmType)	
COEWRITE/4 (Z2_1_EtherCATIndex,0x6099,1,Z2_1_HiwinDriveHmVel) 	
COEWRITE/4 (Z2_1_EtherCATIndex,0x6099,2,Z2_1_HiwinDriveIndVel)	
COEWRITE/4 (Z2_1_EtherCATIndex,0x609A,0,Z2_1_HiwinDriveHmAcc)	
COEWRITE/4 (Z2_1_EtherCATIndex,0x607C,0,Z2_1_HiwinDriveHmOffset) 	

Z2_1_ControlWord=6  
TILL Z2_1_StatusWord.0=1  
Z2_1_ControlWord=7  
TILL Z2_1_StatusWord.0=1 & Z2_1_StatusWord.1=1

WAIT 200 

Z2_1_ControlWord=15  
TILL Z2_1_StatusWord.0=1 & Z2_1_StatusWord.1=1 & Z2_1_StatusWord.2=1	!Enabled
!Start Homing Procedure - Bit 4  
Z2_1_ControlWord=31  											!Start Home
TILL Z2_1_StatusWord.12=1 & Z2_1_StatusWord.10=1 | Z2_1_StatusWord.13=1				!Home Finished

IF Z2_1_StatusWord.13=1
	CALL HomeFail
END

Z2_1_ControlWord=0  

WAIT 100

IF Z2_1_IsModeOfOperationInPDO = 1
	Z2_1_ModeOfOperation = 8 
	WAIT 500 
	ECUNMAPOUT (ECGETOFFSET("Mode of operation",Z2_1_EtherCATIndex))
ELSE
	COEWRITE/1 (Z2_1_EtherCATIndex,0x6060,0,8)						!go back to CSP mode 
END  
WAIT 500 
ECUNMAPIN (ECGETOFFSET("Statusword",Z2_1_EtherCATIndex))
ECUNMAPOUT (ECGETOFFSET("Controlword",Z2_1_EtherCATIndex))

WAIT 500 
DISABLE Z2_1_axis
TILL ^MST(Z2_1_axis).#ENABLED 

RET
STOP
!!*************************************************************************************************************************************!!
!!****************************************************** Error Compensation Process ***************************************************!!
Z2_1_ErrorCompensation:
!---------- Z2_1_axis Error Compensation Table ------------!
Z2_1_ErrTable(0)=	0	;
Z2_1_ErrTable(1)=	-0.5	;
Z2_1_ErrTable(2)=	-1	;
Z2_1_ErrTable(3)=	-1.5	;
Z2_1_ErrTable(4)=	-2	;
Z2_1_ErrTable(5)=	-2.4	;
Z2_1_ErrTable(6)=	-3	;
Z2_1_ErrTable(7)=	-3.4	;
Z2_1_ErrTable(8)=	-3.8	;
Z2_1_ErrTable(9)=	-4.4	;
Z2_1_ErrTable(10)=	-5.1	;

!-------------------------------------------------------!
Z2_1_ErrTableIndex = 0
WHILE Z2_1_ErrTableIndex < SIZEOF(Z2_1_ErrTable)
	Z2_1_ErrTable(Z2_1_ErrTableIndex) = -Z2_1_ErrTable(Z2_1_ErrTableIndex)
	Z2_1_ErrTableIndex = Z2_1_ErrTableIndex + 1
END
ERRORUNMAP Z2_1_axis, ZONE0
ERRORMAP1D Z2_1_axis, ZONE0, Z2_1_ErrCompIniPos, Z2_1_ErrCompensationSpacing, Z2_1_ErrTable
ERRORMAPON Z2_1_axis, ZONE0

WAIT 500	
DISP "Cmpensation Procces's completed!"

RET 
STOP
!!#############################################################################################################################

ON MFLAGS(Z2_1_axis).#HOME=1 & TPOS(Z2_1_axis) < SLLIMIT(Z2_1_axis) 
	IF( FDEF(Z2_1_axis).#SLL=1 & FMASK(Z2_1_axis).#SLL=1 & ^(GMTYPE(Z2_1_axis)=5))
		KILL Z2_1_axis,5016	!Software Left Limit
		TPOS(Z2_1_axis)=FPOS(Z2_1_axis)
		DISP "TPOS(Z2_1_axis) < SLLIMIT(Z2_1_axis)"
	END
RET

ON MFLAGS(Z2_1_axis).#HOME=1 & TPOS(Z2_1_axis) > SRLIMIT(Z2_1_axis) 
	IF(FDEF(Z2_1_axis).#SRL=1 & FMASK(Z2_1_axis).#SRL=1 & ^(GMTYPE(Z2_1_axis)=5))
		KILL Z2_1_axis,5015	!Software Right Limit
		TPOS(Z2_1_axis)=FPOS(Z2_1_axis)
		DISP "TPOS(Z2_1_axis) > SRLIMIT(Z2_1_axis)"
	END
RET


ON MFLAGS(Z2_1_axis).#HOME=0 & RVEL(Z2_1_axis) > XVEL(Z2_1_axis)*0.5 & ^MST(Z2_1_axis).#INPOS
	IMM VEL(Z2_1_axis) = XVEL(Z2_1_axis)*0.45 
RET

ON MFLAGS(Z2_1_axis).#HOME=0 & RVEL(Z2_1_axis) < -XVEL(Z2_1_axis)*0.5 & ^MST(Z2_1_axis).#INPOS
	IMM VEL(Z2_1_axis) = -XVEL(Z2_1_axis)*0.45 
RET

AUTOEXEC:
	Z2_1_IOIndex = 12
	MFLAGS(Z2_1_axis).#HOME=0
STOP

ON IN(Z2_1_IOIndex).0 = 1
	SAFINI(Z2_1_axis).#LL = 1
RET

ON IN(Z2_1_IOIndex).0 = 0
	SAFINI(Z2_1_axis).#LL = 0
RET

ON IN(Z2_1_IOIndex).1 = 1
	SAFINI(Z2_1_axis).#RL = 1
RET

ON IN(Z2_1_IOIndex).1 = 0
	SAFINI(Z2_1_axis).#RL = 0
RET

!ON MST(Z2_1_axis).#ENABLED & (IN(Z2_1_IOIndex).24 = 1 | IN(Z2_1_IOIndex).25 = 1)
!	KILL Z2_1_axis
!	TILL ^MST(Z2_1_axis).#MOVE,500 
!	DISABLE Z2_1_axis,5028		!Safe Torque Off
!	TILL ^MST(Z2_1_axis).#ENABLED
!RET	

ON IN(Z2_1_IOIndex).24 = 1 | IN(Z2_1_IOIndex).25 = 1
    DISP"Z2_1_Event Time : %d",TIME
 	DISP"Z2_1_CHECK SF1 Value : %d",IN(Z2_1_IOIndex).24
	DISP"Z2_1_CHECK SF2 Value : %d",IN(Z2_1_IOIndex).25
	WAIT 5
	DISP"Z2_1_CHECK FAULT Value : %d", SAFIN(Z2_1_axis).9
	DISP"Z2_1_CHECK E1 FAULT : %d",AxisErrorCode23
RET

HomeFail:
DISP" E1 homing fail "
IF Z2_1_IsModeOfOperationInPDO = 1
	Z2_1_ModeOfOperation = 8 
	WAIT 500 
	ECUNMAPOUT (ECGETOFFSET("Mode of operation",Z2_1_EtherCATIndex))
ELSE
	COEWRITE/1 (Z2_1_EtherCATIndex,0x6060,0,8)						!go back to CSP mode 
END  
WAIT 500 
ECUNMAPIN (ECGETOFFSET("Statusword",Z2_1_EtherCATIndex))
ECUNMAPOUT (ECGETOFFSET("Controlword",Z2_1_EtherCATIndex))

STOP
#14
!PNAME=
!PDESC=
! Z2_2_axis Single-axis_Hiwin_Drive_Homing_Process_VER1.5
!!****** Setting Parameter ******!!
LOCAL REAL Z2_2_HmType,Z2_2_multi_indHm,Z2_2_multi_indVel
LOCAL REAL Z2_2_HmVel,Z2_2_IndVel,Z2_2_HmOffset	
LOCAL INT Z2_2_ErrCompensation,Z2_2_ErrCompensationSpacing,Z2_2_ErrCompIniPos
LOCAL INT ZONE0,Z2_2_ErrTableIndex
LOCAL INT Z2_2_HiwinDriveHome,Z2_2_EtherCATIndex,Z2_2_InternalHmType
LOCAL REAL Z2_2_ControlUnit
LOCAL INT Z2_2_IsModeOfOperationInPDO
LOCAL REAL Z2_2_HiwinDriveHmVel,Z2_2_HiwinDriveIndVel,Z2_2_HiwinDriveHmOffset,Z2_2_HiwinDriveHmAcc
!!################ Basic Settings ######################################################################################################
Z2_2_IOIndex = 13
Z2_2_HmType = 1 								!the method of homing
           									!value 0 : Customized homing
           									!	   1 : find the left limit in negative direction,then find index in positive direction 
           									!      2 : find index in positive direction directly 
Z2_2_HmOffset = 0 								! Z2_2_HmOffset (unit)
Z2_2_HmVel = 30000								! the velocity for homing 	
Z2_2_IndVel = 10000 								! the velocity for finding index

Z2_2_multi_indHm=0								! multi index structure
											! value 0 : nomal Homing
											!	    1 : find the left limit in negative direction,then slowing leave the limit in positive direction,
											!			then slowing find the left limit in negative direction,then slowing find index in positive direction
Z2_2_multi_indVel = 100						! (Do not modify)homing velocity of multi index structure
!!*********************************** With Hiwin Drive homing support HmType 1&2************************************!!
Z2_2_IsModeOfOperationInPDO = 0					! Check #ETHERCAT if include Mode of operation slect 1 else select 0
Z2_2_HiwinDriveHome = 1						! 1 : With E1 internal homing ; 2 : With E1 Touch probe homing 
Z2_2_EtherCATIndex = 9							! EtherCAT nod index
Z2_2_ControlUnit = 1/10							! E1 Control unit
!!**************** Configuration of 1D Error Compensation*****************************************************!!
Z2_2_ErrCompensation = 1						! 0 : without compensation  ; 1 : turn on the compensation after homing completed 
Z2_2_ErrCompIniPos = 0							! the initial position of error compensation
Z2_2_ErrCompensationSpacing = 4000				! setting the spacing for error compensation 
!!**********************************************************************************************************!!
!!######################################################################################################################################## 

!!**************************************************************************************************************************************!!
!!************************************************************ Main program ************************************************************!!
FCLEAR Z2_2_axis
IF Z2_2_HmType=0													! Customized homing
	CALL Z2_2_HmType0	
ELSEIF Z2_2_HiwinDriveHome=1										! E1 internal
	MFLAGS(Z2_2_axis).#HOME=0	
	IF Z2_2_HmType=1
		Z2_2_InternalHmType = 1
	ELSEIF Z2_2_HmType=2
		Z2_2_InternalHmType = 34
	ELSE
		DISP"ERROR:The value of Z2_2_HmType is invalid!!"
		STOP
	END
	CALL Z2_2_HiwinDriveInternalHmType	
ELSEIF Z2_2_HiwinDriveHome=2										! Touch probe
		MFLAGS(Z2_2_axis).#HOME=0	
	IF Z2_2_HmType=1
		CALL Z2_2_HiwinDriveTouchProbeHmType1
	ELSEIF Z2_2_HmType=2
		CALL Z2_2_HiwinDriveTouchProbeHmType2
	ELSE
		DISP"ERROR:The value of Z2_2_HmType is invalid!!"
		STOP
	END
ELSE
	DISP"ERROR:The value of Z2_2_HmType or Z2_2_HiwinDriveHome is invalid!!"
	STOP
END

IF Z2_2_ErrCompensation = 1
	DISP "Enable the compensation mode."
	DISP "Execute the compensation prcoess......"
	CALL Z2_2_ErrorCompensation	
ELSE
	DISP "Disable error compensation."
	ERRORUNMAP Z2_2_axis, ZONE0
END 

IF (Z2_2_HmType>=1&Z2_2_HmType<=2)
	ENABLE Z2_2_axis
	TILL MST(Z2_2_axis).#ENABLED
	WAIT 500
	DISP"Go home......"	
	PTP/EV Z2_2_axis,0,Z2_2_HmVel	
	MFLAGS(Z2_2_axis).#HOME=1
END	
FDEF(Z2_2_axis).#LL = 1	 		
FDEF(Z2_2_axis).#SRL = 1	 		
FDEF(Z2_2_axis).#SLL = 1	 
DISP"Homing successful!!"	

STOP	

!!*************************************************************************************************************************************!!
!!************************************************************ Homing process	*******************************************************!!
Z2_2_HmType0:
!Customized
RET
STOP
!------------------------------------------------------------------Z2_2_HiwinDriveTouchProbeHmType1--------------------------------------------------------------------------------------
Z2_2_HiwinDriveTouchProbeHmType1:

FCLEAR Z2_2_axis
DISABLE Z2_2_axis		
TILL ^MST(Z2_2_axis).#ENABLED	
WAIT 500	
MFLAGS(Z2_2_axis).#OPEN = 0								! Close loop control
ERRORMAPOFF Z2_2_axis, -1									! Close all axis error compensation
MFLAGS(Z2_2_axis).#GANTRY = 0								! turn off gantry mode (MFLAGS.25)	
FDEF(Z2_2_axis).#SRL = 0	 								! disable software right limit response
FDEF(Z2_2_axis).#SLL = 0	 								! disable software left limit response
FDEF(Z2_2_axis).#LL = 0	 										! motor is not disable when left limit signal rising.

ENABLE	Z2_2_axis	 
TILL MST(Z2_2_axis).#ENABLED	 
WAIT 500	
DISP"Start to find the left limit......"
JOG/V Z2_2_axis,-Z2_2_HmVel									! find the left limit in negative direction
TILL (COEREAD/4 (Z2_2_EtherCATIndex,0x60FD,0)& 1) = 1
HALT Z2_2_axis 
TILL ^MST(Z2_2_axis).#MOVE,1000							! if reach left limit , stop motion
DISP"Already found the left limit!!"

!!!!!!!!!!!!!!!!!!!!multi index Structure Homing Way!!!!!!!!!!!!!!!
IF(Z2_2_multi_indHm = 1)	
	JOG/V Z2_2_axis,Z2_2_multi_indVel							! slowing to leave the limit in negative direction
	TILL (COEREAD/4 (Z2_2_EtherCATIndex,0x60FD,0)& 1) = 0	! waiting to leave the limit
	HALT Z2_2_axis
	TILL ^MST(Z2_2_axis).#MOVE 
	Z2_2_IndVel = Z2_2_multi_indVel							! define slowing velocity to find index velocity
END
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
ECOUT(ECGETOFFSET("Touch probe function",Z2_2_EtherCATIndex),Z2_2_TouchProbFun)
WAIT 200
Z2_2_TouchProbFun = 0										!Reset Touch probe
WAIT 200
Z2_2_TouchProbFun = 17										! Start Touch probe
WAIT 200
DISP"Start to find the index in positive direction......"
JOG/V Z2_2_axis,Z2_2_IndVel									!find the index in positive direction
TILL (COEREAD/2 (Z2_2_EtherCATIndex,0x60B9,0) = 3)			!if reach index	, stop motion
HALT Z2_2_axis	
TILL ^MST(Z2_2_axis).#MOVE 
DISP"Already found the index!!"
SET FPOS(Z2_2_axis) = (COEREAD/4 (Z2_2_EtherCATIndex,0x6064,0) - COEREAD/4 (Z2_2_EtherCATIndex,0x60BA,0))*Z2_2_ControlUnit - Z2_2_HmOffset		!set index position as zero.
WAIT 500
ECUNMAPOUT (ECGETOFFSET("Touch probe function",Z2_2_EtherCATIndex))	
RET	
STOP
!------------------------------------------------------------------Z2_2_HiwinDriveTouchProbeHmType2--------------------------------------------------------------------------------------
Z2_2_HiwinDriveTouchProbeHmType2:

FCLEAR Z2_2_axis
DISABLE Z2_2_axis		
TILL ^MST(Z2_2_axis).#ENABLED	
WAIT 500	
MFLAGS(Z2_2_axis).#OPEN = 0						! Close loop control
ERRORMAPOFF Z2_2_axis, -1							! Close all axis error compensation
MFLAGS(Z2_2_axis).#GANTRY = 0	 					! turn off gantry mode (MFLAGS.25)	
FDEF(Z2_2_axis).#SRL = 0	 						! disable software right limit response
FDEF(Z2_2_axis).#SLL = 0	 						! disable software left limit response
FDEF(Z2_2_axis).#LL = 0	 										! motor is not disable when left limit signal rising.

ENABLE	Z2_2_axis	 
!!!!!!!!!!!!!!!!!!!!multi index Structure Homing Way!!!!!!!!!!!!!!!
IF(Z2_2_multi_indHm = 1)	
	Z2_2_IndVel = Z2_2_multi_indVel					! define slowing velocity to find index velocity
END
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
ECOUT(ECGETOFFSET("Touch probe function",Z2_2_EtherCATIndex),Z2_2_TouchProbFun)
WAIT 200
Z2_2_TouchProbFun = 0								!Reset Touch probe
WAIT 200
Z2_2_TouchProbFun = 17								! Start Touch probe
WAIT 200
DISP"Start to find the index in positive direction......"
JOG/V Z2_2_axis,Z2_2_IndVel							!find the index in positive direction
TILL (COEREAD/2 (Z2_2_EtherCATIndex,0x60B9,0) = 3)	!if reach index	, stop motion
HALT Z2_2_axis	
TILL ^MST(Z2_2_axis).#MOVE 
DISP"Already found the index!!"
SET FPOS(Z2_2_axis) = (COEREAD/4 (Z2_2_EtherCATIndex,0x6064,0) - COEREAD/4 (Z2_2_EtherCATIndex,0x60BA,0))*Z2_2_ControlUnit - Z2_2_HmOffset	!set index position as zero.
WAIT 500
ECUNMAPOUT (ECGETOFFSET("Touch probe function",Z2_2_EtherCATIndex))		
RET	
STOP
!------------------------------------------------------------------Z2_2_HiwinDriveInternalHmType--------------------------------------------------------------------------------------
Z2_2_HiwinDriveInternalHmType:

FCLEAR Z2_2_axis
FDEF(Z2_2_axis).#LL = 0	 										! motor is not disable when left limit signal rising.
FDEF(Z2_2_axis).#SRL = 0	 										! disable software right limit response
FDEF(Z2_2_axis).#SLL = 0	 										! disable software left limit response
Z2_2_HiwinDriveHmVel = Z2_2_HmVel/Z2_2_ControlUnit
Z2_2_HiwinDriveIndVel = Z2_2_IndVel/Z2_2_ControlUnit
Z2_2_HiwinDriveHmOffset = Z2_2_HmOffset/Z2_2_ControlUnit
Z2_2_HiwinDriveHmAcc = ACC(Z2_2_axis)/Z2_2_ControlUnit

ECIN( ECGETOFFSET("Statusword",Z2_2_EtherCATIndex),Z2_2_StatusWord)  
ECOUT(ECGETOFFSET("Controlword",Z2_2_EtherCATIndex),Z2_2_ControlWord)
IF Z2_2_IsModeOfOperationInPDO = 1
	ECOUT(ECGETOFFSET("Mode of operation",Z2_2_EtherCATIndex),Z2_2_ModeOfOperation)
	Z2_2_ModeOfOperation = 6
ELSE
	COEWRITE/1 (Z2_2_EtherCATIndex,0x6060,0,6) !6 is Homing mode  
END  


COEWRITE/1 (Z2_2_EtherCATIndex,0x6098,0,Z2_2_InternalHmType)	
COEWRITE/4 (Z2_2_EtherCATIndex,0x6099,1,Z2_2_HiwinDriveHmVel) 	
COEWRITE/4 (Z2_2_EtherCATIndex,0x6099,2,Z2_2_HiwinDriveIndVel)	
COEWRITE/4 (Z2_2_EtherCATIndex,0x609A,0,Z2_2_HiwinDriveHmAcc)	
COEWRITE/4 (Z2_2_EtherCATIndex,0x607C,0,Z2_2_HiwinDriveHmOffset) 	

Z2_2_ControlWord=6  
TILL Z2_2_StatusWord.0=1  
Z2_2_ControlWord=7  
TILL Z2_2_StatusWord.0=1 & Z2_2_StatusWord.1=1

WAIT 200 

Z2_2_ControlWord=15  
TILL Z2_2_StatusWord.0=1 & Z2_2_StatusWord.1=1 & Z2_2_StatusWord.2=1	!Enabled
!Start Homing Procedure - Bit 4  
Z2_2_ControlWord=31  											!Start Home
TILL Z2_2_StatusWord.12=1 & Z2_2_StatusWord.10=1 | Z2_2_StatusWord.13=1				!Home Finished

IF Z2_2_StatusWord.13=1
	CALL HomeFail
END

Z2_2_ControlWord=0  

WAIT 100

IF Z2_2_IsModeOfOperationInPDO = 1
	Z2_2_ModeOfOperation = 8 
	WAIT 500 
	ECUNMAPOUT (ECGETOFFSET("Mode of operation",Z2_2_EtherCATIndex))
ELSE
	COEWRITE/1 (Z2_2_EtherCATIndex,0x6060,0,8)						!go back to CSP mode 
END  
WAIT 500 
ECUNMAPIN (ECGETOFFSET("Statusword",Z2_2_EtherCATIndex))
ECUNMAPOUT (ECGETOFFSET("Controlword",Z2_2_EtherCATIndex))

WAIT 500 
DISABLE Z2_2_axis
TILL ^MST(Z2_2_axis).#ENABLED 

RET
STOP
!!*************************************************************************************************************************************!!
!!****************************************************** Error Compensation Process ***************************************************!!
Z2_2_ErrorCompensation:
!---------- Z2_2_axis Error Compensation Table ------------!
Z2_2_ErrTable(0)=	0	;
Z2_2_ErrTable(1)=	0.5	;
Z2_2_ErrTable(2)=	0.9	;
Z2_2_ErrTable(3)=	1.3	;
Z2_2_ErrTable(4)=	1.5	;
Z2_2_ErrTable(5)=	1.8	;
Z2_2_ErrTable(6)=	2.3	;
Z2_2_ErrTable(7)=	2.6	;
Z2_2_ErrTable(8)=	2.7	;
Z2_2_ErrTable(9)=	3.1	;
Z2_2_ErrTable(10)=	3.2	;


!-------------------------------------------------------!
Z2_2_ErrTableIndex = 0
WHILE Z2_2_ErrTableIndex < SIZEOF(Z2_2_ErrTable)
	Z2_2_ErrTable(Z2_2_ErrTableIndex) = -Z2_2_ErrTable(Z2_2_ErrTableIndex)
	Z2_2_ErrTableIndex = Z2_2_ErrTableIndex + 1
END
ERRORUNMAP Z2_2_axis, ZONE0
ERRORMAP1D Z2_2_axis, ZONE0, Z2_2_ErrCompIniPos, Z2_2_ErrCompensationSpacing, Z2_2_ErrTable
ERRORMAPON Z2_2_axis, ZONE0

WAIT 500	
DISP "Cmpensation Procces's completed!"

RET 
STOP
!!#############################################################################################################################

ON MFLAGS(Z2_2_axis).#HOME=1 & TPOS(Z2_2_axis) < SLLIMIT(Z2_2_axis) 
	IF( FDEF(Z2_2_axis).#SLL=1 & FMASK(Z2_2_axis).#SLL=1 & ^(GMTYPE(Z2_2_axis)=5))
		KILL Z2_2_axis,5016	!Software Left Limit
		TPOS(Z2_2_axis)=FPOS(Z2_2_axis)
		DISP "TPOS(Z2_2_axis) < SLLIMIT(Z2_2_axis)"
	END
RET

ON MFLAGS(Z2_2_axis).#HOME=1 & TPOS(Z2_2_axis) > SRLIMIT(Z2_2_axis) 
	IF(FDEF(Z2_2_axis).#SRL=1 & FMASK(Z2_2_axis).#SRL=1 & ^(GMTYPE(Z2_2_axis)=5))
		KILL Z2_2_axis,5015	!Software Right Limit
		TPOS(Z2_2_axis)=FPOS(Z2_2_axis)
		DISP "TPOS(Z2_2_axis) > SRLIMIT(Z2_2_axis)"
	END
RET


ON MFLAGS(Z2_2_axis).#HOME=0 & RVEL(Z2_2_axis) > XVEL(Z2_2_axis)*0.5 & ^MST(Z2_2_axis).#INPOS
	IMM VEL(Z2_2_axis) = XVEL(Z2_2_axis)*0.45 
RET

ON MFLAGS(Z2_2_axis).#HOME=0 & RVEL(Z2_2_axis) < -XVEL(Z2_2_axis)*0.5 & ^MST(Z2_2_axis).#INPOS
	IMM VEL(Z2_2_axis) = -XVEL(Z2_2_axis)*0.45 
RET

AUTOEXEC:
	Z2_2_IOIndex = 13
	MFLAGS(Z2_2_axis).#HOME=0
STOP

ON IN(Z2_2_IOIndex).0 = 1
	SAFINI(Z2_2_axis).#LL = 1
RET

ON IN(Z2_2_IOIndex).0 = 0
	SAFINI(Z2_2_axis).#LL = 0
RET

ON IN(Z2_2_IOIndex).1 = 1
	SAFINI(Z2_2_axis).#RL = 1
RET

ON IN(Z2_2_IOIndex).1 = 0
	SAFINI(Z2_2_axis).#RL = 0
RET

!ON MST(Z2_2_axis).#ENABLED & (IN(Z2_2_IOIndex).24 = 1 | IN(Z2_2_IOIndex).25 = 1)
!	KILL Z2_2_axis
!	TILL ^MST(Z2_2_axis).#MOVE,500 
!	DISABLE Z2_2_axis,5028		!Safe Torque Off
!	TILL ^MST(Z2_2_axis).#ENABLED
!RET	

ON IN(Z2_2_IOIndex).24 = 1 | IN(Z2_2_IOIndex).25 = 1
    DISP"Z2_2_Event Time : %d",TIME
 	DISP"Z2_2_CHECK SF1 Value : %d",IN(Z2_2_IOIndex).24
	DISP"Z2_2_CHECK SF2 Value : %d",IN(Z2_2_IOIndex).25
	WAIT 5
	DISP"Z2_2_CHECK FAULT Value : %d", SAFIN(Z2_2_axis).9
	DISP"Z2_2_CHECK E1 FAULT : %d",AxisErrorCode24
RET

HomeFail:
DISP" E1 homing fail "
IF Z2_2_IsModeOfOperationInPDO = 1
	Z2_2_ModeOfOperation = 8 
	WAIT 500 
	ECUNMAPOUT (ECGETOFFSET("Mode of operation",Z2_2_EtherCATIndex))
ELSE
	COEWRITE/1 (Z2_2_EtherCATIndex,0x6060,0,8)						!go back to CSP mode 
END  
WAIT 500 
ECUNMAPIN (ECGETOFFSET("Statusword",Z2_2_EtherCATIndex))
ECUNMAPOUT (ECGETOFFSET("Controlword",Z2_2_EtherCATIndex))

STOP
#15
!PNAME=
!PDESC=
! Z2_3_axis Single-axis_Hiwin_Drive_Homing_Process_VER1.5
!!****** Setting Parameter ******!!
LOCAL REAL Z2_3_HmType,Z2_3_multi_indHm,Z2_3_multi_indVel
LOCAL REAL Z2_3_HmVel,Z2_3_IndVel,Z2_3_HmOffset	
LOCAL INT Z2_3_ErrCompensation,Z2_3_ErrCompensationSpacing,Z2_3_ErrCompIniPos
LOCAL INT ZONE0,Z2_3_ErrTableIndex
LOCAL INT Z2_3_HiwinDriveHome,Z2_3_EtherCATIndex,Z2_3_InternalHmType
LOCAL REAL Z2_3_ControlUnit
LOCAL INT Z2_3_IsModeOfOperationInPDO
LOCAL REAL Z2_3_HiwinDriveHmVel,Z2_3_HiwinDriveIndVel,Z2_3_HiwinDriveHmOffset,Z2_3_HiwinDriveHmAcc
!!################ Basic Settings ######################################################################################################
Z2_3_IOIndex = 14
Z2_3_HmType = 1 								!the method of homing
           									!value 0 : Customized homing
           									!	   1 : find the left limit in negative direction,then find index in positive direction 
           									!      2 : find index in positive direction directly 
Z2_3_HmOffset = 0 								! Z2_3_HmOffset (unit)
Z2_3_HmVel = 30000								! the velocity for homing 	
Z2_3_IndVel = 10000 								! the velocity for finding index

Z2_3_multi_indHm=0								! multi index structure
											! value 0 : nomal Homing
											!	    1 : find the left limit in negative direction,then slowing leave the limit in positive direction,
											!			then slowing find the left limit in negative direction,then slowing find index in positive direction
Z2_3_multi_indVel = 100						! (Do not modify)homing velocity of multi index structure
!!*********************************** With Hiwin Drive homing support HmType 1&2************************************!!
Z2_3_IsModeOfOperationInPDO = 0					! Check #ETHERCAT if include Mode of operation slect 1 else select 0
Z2_3_HiwinDriveHome = 1						! 1 : With E1 internal homing ; 2 : With E1 Touch probe homing 
Z2_3_EtherCATIndex = 10							! EtherCAT nod index
Z2_3_ControlUnit = 1/10							! E1 Control unit
!!**************** Configuration of 1D Error Compensation*****************************************************!!
Z2_3_ErrCompensation = 1						! 0 : without compensation  ; 1 : turn on the compensation after homing completed 
Z2_3_ErrCompIniPos = 0							! the initial position of error compensation
Z2_3_ErrCompensationSpacing = 4000				! setting the spacing for error compensation 
!!**********************************************************************************************************!!
!!######################################################################################################################################## 

!!**************************************************************************************************************************************!!
!!************************************************************ Main program ************************************************************!!
FCLEAR Z2_3_axis
IF Z2_3_HmType=0													! Customized homing
	CALL Z2_3_HmType0	
ELSEIF Z2_3_HiwinDriveHome=1										! E1 internal
	MFLAGS(Z2_3_axis).#HOME=0	
	IF Z2_3_HmType=1
		Z2_3_InternalHmType = 1
	ELSEIF Z2_3_HmType=2
		Z2_3_InternalHmType = 34
	ELSE
		DISP"ERROR:The value of Z2_3_HmType is invalid!!"
		STOP
	END
	CALL Z2_3_HiwinDriveInternalHmType	
ELSEIF Z2_3_HiwinDriveHome=2										! Touch probe
		MFLAGS(Z2_3_axis).#HOME=0	
	IF Z2_3_HmType=1
		CALL Z2_3_HiwinDriveTouchProbeHmType1
	ELSEIF Z2_3_HmType=2
		CALL Z2_3_HiwinDriveTouchProbeHmType2
	ELSE
		DISP"ERROR:The value of Z2_3_HmType is invalid!!"
		STOP
	END
ELSE
	DISP"ERROR:The value of Z2_3_HmType or Z2_3_HiwinDriveHome is invalid!!"
	STOP
END

IF Z2_3_ErrCompensation = 1
	DISP "Enable the compensation mode."
	DISP "Execute the compensation prcoess......"
	CALL Z2_3_ErrorCompensation	
ELSE
	DISP "Disable error compensation."
	ERRORUNMAP Z2_3_axis, ZONE0
END 

IF (Z2_3_HmType>=1&Z2_3_HmType<=2)
	ENABLE Z2_3_axis
	TILL MST(Z2_3_axis).#ENABLED
	WAIT 500
	DISP"Go home......"	
	PTP/EV Z2_3_axis,0,Z2_3_HmVel	
	MFLAGS(Z2_3_axis).#HOME=1
END	
FDEF(Z2_3_axis).#LL = 1	 		
FDEF(Z2_3_axis).#SRL = 1	 		
FDEF(Z2_3_axis).#SLL = 1	 
DISP"Homing successful!!"	

STOP	

!!*************************************************************************************************************************************!!
!!************************************************************ Homing process	*******************************************************!!
Z2_3_HmType0:
!Customized
RET
STOP
!------------------------------------------------------------------Z2_3_HiwinDriveTouchProbeHmType1--------------------------------------------------------------------------------------
Z2_3_HiwinDriveTouchProbeHmType1:

FCLEAR Z2_3_axis
DISABLE Z2_3_axis		
TILL ^MST(Z2_3_axis).#ENABLED	
WAIT 500	
MFLAGS(Z2_3_axis).#OPEN = 0								! Close loop control
ERRORMAPOFF Z2_3_axis, -1									! Close all axis error compensation
MFLAGS(Z2_3_axis).#GANTRY = 0								! turn off gantry mode (MFLAGS.25)	
FDEF(Z2_3_axis).#SRL = 0	 								! disable software right limit response
FDEF(Z2_3_axis).#SLL = 0	 								! disable software left limit response
FDEF(Z2_3_axis).#LL = 0	 										! motor is not disable when left limit signal rising.

ENABLE	Z2_3_axis	 
TILL MST(Z2_3_axis).#ENABLED	 
WAIT 500	
DISP"Start to find the left limit......"
JOG/V Z2_3_axis,-Z2_3_HmVel									! find the left limit in negative direction
TILL (COEREAD/4 (Z2_3_EtherCATIndex,0x60FD,0)& 1) = 1
HALT Z2_3_axis 
TILL ^MST(Z2_3_axis).#MOVE,1000							! if reach left limit , stop motion
DISP"Already found the left limit!!"

!!!!!!!!!!!!!!!!!!!!multi index Structure Homing Way!!!!!!!!!!!!!!!
IF(Z2_3_multi_indHm = 1)	
	JOG/V Z2_3_axis,Z2_3_multi_indVel							! slowing to leave the limit in negative direction
	TILL (COEREAD/4 (Z2_3_EtherCATIndex,0x60FD,0)& 1) = 0	! waiting to leave the limit
	HALT Z2_3_axis
	TILL ^MST(Z2_3_axis).#MOVE 
	Z2_3_IndVel = Z2_3_multi_indVel							! define slowing velocity to find index velocity
END
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
ECOUT(ECGETOFFSET("Touch probe function",Z2_3_EtherCATIndex),Z2_3_TouchProbFun)
WAIT 200
Z2_3_TouchProbFun = 0										!Reset Touch probe
WAIT 200
Z2_3_TouchProbFun = 17										! Start Touch probe
WAIT 200
DISP"Start to find the index in positive direction......"
JOG/V Z2_3_axis,Z2_3_IndVel									!find the index in positive direction
TILL (COEREAD/2 (Z2_3_EtherCATIndex,0x60B9,0) = 3)			!if reach index	, stop motion
HALT Z2_3_axis	
TILL ^MST(Z2_3_axis).#MOVE 
DISP"Already found the index!!"
SET FPOS(Z2_3_axis) = (COEREAD/4 (Z2_3_EtherCATIndex,0x6064,0) - COEREAD/4 (Z2_3_EtherCATIndex,0x60BA,0))*Z2_3_ControlUnit - Z2_3_HmOffset		!set index position as zero.
WAIT 500
ECUNMAPOUT (ECGETOFFSET("Touch probe function",Z2_3_EtherCATIndex))	
RET	
STOP
!------------------------------------------------------------------Z2_3_HiwinDriveTouchProbeHmType2--------------------------------------------------------------------------------------
Z2_3_HiwinDriveTouchProbeHmType2:

FCLEAR Z2_3_axis
DISABLE Z2_3_axis		
TILL ^MST(Z2_3_axis).#ENABLED	
WAIT 500	
MFLAGS(Z2_3_axis).#OPEN = 0						! Close loop control
ERRORMAPOFF Z2_3_axis, -1							! Close all axis error compensation
MFLAGS(Z2_3_axis).#GANTRY = 0	 					! turn off gantry mode (MFLAGS.25)	
FDEF(Z2_3_axis).#SRL = 0	 						! disable software right limit response
FDEF(Z2_3_axis).#SLL = 0	 						! disable software left limit response
FDEF(Z2_3_axis).#LL = 0	 										! motor is not disable when left limit signal rising.

ENABLE	Z2_3_axis	 
!!!!!!!!!!!!!!!!!!!!multi index Structure Homing Way!!!!!!!!!!!!!!!
IF(Z2_3_multi_indHm = 1)	
	Z2_3_IndVel = Z2_3_multi_indVel					! define slowing velocity to find index velocity
END
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
ECOUT(ECGETOFFSET("Touch probe function",Z2_3_EtherCATIndex),Z2_3_TouchProbFun)
WAIT 200
Z2_3_TouchProbFun = 0								!Reset Touch probe
WAIT 200
Z2_3_TouchProbFun = 17								! Start Touch probe
WAIT 200
DISP"Start to find the index in positive direction......"
JOG/V Z2_3_axis,Z2_3_IndVel							!find the index in positive direction
TILL (COEREAD/2 (Z2_3_EtherCATIndex,0x60B9,0) = 3)	!if reach index	, stop motion
HALT Z2_3_axis	
TILL ^MST(Z2_3_axis).#MOVE 
DISP"Already found the index!!"
SET FPOS(Z2_3_axis) = (COEREAD/4 (Z2_3_EtherCATIndex,0x6064,0) - COEREAD/4 (Z2_3_EtherCATIndex,0x60BA,0))*Z2_3_ControlUnit - Z2_3_HmOffset	!set index position as zero.
WAIT 500
ECUNMAPOUT (ECGETOFFSET("Touch probe function",Z2_3_EtherCATIndex))		
RET	
STOP
!------------------------------------------------------------------Z2_3_HiwinDriveInternalHmType--------------------------------------------------------------------------------------
Z2_3_HiwinDriveInternalHmType:

FCLEAR Z2_3_axis
FDEF(Z2_3_axis).#LL = 0	 										! motor is not disable when left limit signal rising.
FDEF(Z2_3_axis).#SRL = 0	 										! disable software right limit response
FDEF(Z2_3_axis).#SLL = 0	 										! disable software left limit response
Z2_3_HiwinDriveHmVel = Z2_3_HmVel/Z2_3_ControlUnit
Z2_3_HiwinDriveIndVel = Z2_3_IndVel/Z2_3_ControlUnit
Z2_3_HiwinDriveHmOffset = Z2_3_HmOffset/Z2_3_ControlUnit
Z2_3_HiwinDriveHmAcc = ACC(Z2_3_axis)/Z2_3_ControlUnit

ECIN( ECGETOFFSET("Statusword",Z2_3_EtherCATIndex),Z2_3_StatusWord)  
ECOUT(ECGETOFFSET("Controlword",Z2_3_EtherCATIndex),Z2_3_ControlWord)
IF Z2_3_IsModeOfOperationInPDO = 1
	ECOUT(ECGETOFFSET("Mode of operation",Z2_3_EtherCATIndex),Z2_3_ModeOfOperation)
	Z2_3_ModeOfOperation = 6
ELSE
	COEWRITE/1 (Z2_3_EtherCATIndex,0x6060,0,6) !6 is Homing mode  
END  


COEWRITE/1 (Z2_3_EtherCATIndex,0x6098,0,Z2_3_InternalHmType)	
COEWRITE/4 (Z2_3_EtherCATIndex,0x6099,1,Z2_3_HiwinDriveHmVel) 	
COEWRITE/4 (Z2_3_EtherCATIndex,0x6099,2,Z2_3_HiwinDriveIndVel)	
COEWRITE/4 (Z2_3_EtherCATIndex,0x609A,0,Z2_3_HiwinDriveHmAcc)	
COEWRITE/4 (Z2_3_EtherCATIndex,0x607C,0,Z2_3_HiwinDriveHmOffset) 	

Z2_3_ControlWord=6  
TILL Z2_3_StatusWord.0=1  
Z2_3_ControlWord=7  
TILL Z2_3_StatusWord.0=1 & Z2_3_StatusWord.1=1

WAIT 200 

Z2_3_ControlWord=15  
TILL Z2_3_StatusWord.0=1 & Z2_3_StatusWord.1=1 & Z2_3_StatusWord.2=1	!Enabled
!Start Homing Procedure - Bit 4  
Z2_3_ControlWord=31  											!Start Home
TILL Z2_3_StatusWord.12=1 & Z2_3_StatusWord.10=1 | Z2_3_StatusWord.13=1				!Home Finished

IF Z2_3_StatusWord.13=1
	CALL HomeFail
END

Z2_3_ControlWord=0  

WAIT 100

IF Z2_3_IsModeOfOperationInPDO = 1
	Z2_3_ModeOfOperation = 8 
	WAIT 500 
	ECUNMAPOUT (ECGETOFFSET("Mode of operation",Z2_3_EtherCATIndex))
ELSE
	COEWRITE/1 (Z2_3_EtherCATIndex,0x6060,0,8)						!go back to CSP mode 
END  
WAIT 500 
ECUNMAPIN (ECGETOFFSET("Statusword",Z2_3_EtherCATIndex))
ECUNMAPOUT (ECGETOFFSET("Controlword",Z2_3_EtherCATIndex))

WAIT 500 
DISABLE Z2_3_axis
TILL ^MST(Z2_3_axis).#ENABLED 

RET
STOP
!!*************************************************************************************************************************************!!
!!****************************************************** Error Compensation Process ***************************************************!!
Z2_3_ErrorCompensation:
!---------- Z2_3_axis Error Compensation Table ------------!
Z2_3_ErrTable(0)=	0	;
Z2_3_ErrTable(1)=	-0.1	;
Z2_3_ErrTable(2)=	-0.2	;
Z2_3_ErrTable(3)=	-0.3	;
Z2_3_ErrTable(4)=	-0.5	;
Z2_3_ErrTable(5)=	-0.6	;
Z2_3_ErrTable(6)=	-0.6	;
Z2_3_ErrTable(7)=	-0.6	;
Z2_3_ErrTable(8)=	-0.6	;
Z2_3_ErrTable(9)=	-0.5	;
Z2_3_ErrTable(10)=	-0.6	;


!-------------------------------------------------------!
Z2_3_ErrTableIndex = 0
WHILE Z2_3_ErrTableIndex < SIZEOF(Z2_3_ErrTable)
	Z2_3_ErrTable(Z2_3_ErrTableIndex) = -Z2_3_ErrTable(Z2_3_ErrTableIndex)
	Z2_3_ErrTableIndex = Z2_3_ErrTableIndex + 1
END
ERRORUNMAP Z2_3_axis, ZONE0
ERRORMAP1D Z2_3_axis, ZONE0, Z2_3_ErrCompIniPos, Z2_3_ErrCompensationSpacing, Z2_3_ErrTable
ERRORMAPON Z2_3_axis, ZONE0

WAIT 500	
DISP "Cmpensation Procces's completed!"

RET 
STOP
!!#############################################################################################################################

ON MFLAGS(Z2_3_axis).#HOME=1 & TPOS(Z2_3_axis) < SLLIMIT(Z2_3_axis) 
	IF( FDEF(Z2_3_axis).#SLL=1 & FMASK(Z2_3_axis).#SLL=1 & ^(GMTYPE(Z2_3_axis)=5))
		KILL Z2_3_axis,5016	!Software Left Limit
		TPOS(Z2_3_axis)=FPOS(Z2_3_axis)
		DISP "TPOS(Z2_3_axis) < SLLIMIT(Z2_3_axis)"
	END
RET

ON MFLAGS(Z2_3_axis).#HOME=1 & TPOS(Z2_3_axis) > SRLIMIT(Z2_3_axis) 
	IF(FDEF(Z2_3_axis).#SRL=1 & FMASK(Z2_3_axis).#SRL=1 & ^(GMTYPE(Z2_3_axis)=5))
		KILL Z2_3_axis,5015	!Software Right Limit
		TPOS(Z2_3_axis)=FPOS(Z2_3_axis)
		DISP "TPOS(Z2_3_axis) > SRLIMIT(Z2_3_axis)"
	END
RET


ON MFLAGS(Z2_3_axis).#HOME=0 & RVEL(Z2_3_axis) > XVEL(Z2_3_axis)*0.5 & ^MST(Z2_3_axis).#INPOS
	IMM VEL(Z2_3_axis) = XVEL(Z2_3_axis)*0.45 
RET

ON MFLAGS(Z2_3_axis).#HOME=0 & RVEL(Z2_3_axis) < -XVEL(Z2_3_axis)*0.5 & ^MST(Z2_3_axis).#INPOS
	IMM VEL(Z2_3_axis) = -XVEL(Z2_3_axis)*0.45 
RET

AUTOEXEC:
	Z2_3_IOIndex = 14
	MFLAGS(Z2_3_axis).#HOME=0
STOP

ON IN(Z2_3_IOIndex).0 = 1
	SAFINI(Z2_3_axis).#LL = 1
RET

ON IN(Z2_3_IOIndex).0 = 0
	SAFINI(Z2_3_axis).#LL = 0
RET

ON IN(Z2_3_IOIndex).1 = 1
	SAFINI(Z2_3_axis).#RL = 1
RET

ON IN(Z2_3_IOIndex).1 = 0
	SAFINI(Z2_3_axis).#RL = 0
RET

!ON MST(Z2_3_axis).#ENABLED & (IN(Z2_3_IOIndex).24 = 1 | IN(Z2_3_IOIndex).25 = 1)
!	KILL Z2_3_axis
!	TILL ^MST(Z2_3_axis).#MOVE,500 
!	DISABLE Z2_3_axis,5028		!Safe Torque Off
!	TILL ^MST(Z2_3_axis).#ENABLED
!RET

ON IN(Z2_3_IOIndex).24 = 1 | IN(Z2_3_IOIndex).25 = 1
    DISP"Z2_3_Event Time : %d",TIME
 	DISP"Z2_3_CHECK SF1 Value : %d",IN(Z2_3_IOIndex).24
	DISP"Z2_3_CHECK SF2 Value : %d",IN(Z2_3_IOIndex).25
	WAIT 5
	DISP"Z2_3_CHECK FAULT Value : %d", SAFIN(Z2_3_axis).9
	DISP"Z2_3_CHECK E1 FAULT : %d",AxisErrorCode25
RET

HomeFail:
DISP" E1 homing fail "
IF Z2_3_IsModeOfOperationInPDO = 1
	Z2_3_ModeOfOperation = 8 
	WAIT 500 
	ECUNMAPOUT (ECGETOFFSET("Mode of operation",Z2_3_EtherCATIndex))
ELSE
	COEWRITE/1 (Z2_3_EtherCATIndex,0x6060,0,8)						!go back to CSP mode 
END  
WAIT 500 
ECUNMAPIN (ECGETOFFSET("Statusword",Z2_3_EtherCATIndex))
ECUNMAPOUT (ECGETOFFSET("Controlword",Z2_3_EtherCATIndex))

STOP
#16
!PNAME=
!PDESC=
! Z2_4_axis Single-axis_Hiwin_Drive_Homing_Process_VER1.5
!!****** Setting Parameter ******!!
LOCAL REAL Z2_4_HmType,Z2_4_multi_indHm,Z2_4_multi_indVel
LOCAL REAL Z2_4_HmVel,Z2_4_IndVel,Z2_4_HmOffset	
LOCAL INT Z2_4_ErrCompensation,Z2_4_ErrCompensationSpacing,Z2_4_ErrCompIniPos
LOCAL INT ZONE0,Z2_4_ErrTableIndex
LOCAL INT Z2_4_HiwinDriveHome,Z2_4_EtherCATIndex,Z2_4_InternalHmType
LOCAL REAL Z2_4_ControlUnit
LOCAL INT Z2_4_IsModeOfOperationInPDO
LOCAL REAL Z2_4_HiwinDriveHmVel,Z2_4_HiwinDriveIndVel,Z2_4_HiwinDriveHmOffset,Z2_4_HiwinDriveHmAcc
!!################ Basic Settings ######################################################################################################
Z2_4_IOIndex = 15
Z2_4_HmType = 1 								!the method of homing
           									!value 0 : Customized homing
           									!	   1 : find the left limit in negative direction,then find index in positive direction 
           									!      2 : find index in positive direction directly 
Z2_4_HmOffset = 0 								! Z2_4_HmOffset (unit)
Z2_4_HmVel = 30000								! the velocity for homing 	
Z2_4_IndVel = 10000 								! the velocity for finding index

Z2_4_multi_indHm=0								! multi index structure
											! value 0 : nomal Homing
											!	    1 : find the left limit in negative direction,then slowing leave the limit in positive direction,
											!			then slowing find the left limit in negative direction,then slowing find index in positive direction
Z2_4_multi_indVel = 100						! (Do not modify)homing velocity of multi index structure
!!*********************************** With Hiwin Drive homing support HmType 1&2************************************!!
Z2_4_IsModeOfOperationInPDO = 0					! Check #ETHERCAT if include Mode of operation slect 1 else select 0
Z2_4_HiwinDriveHome = 1						! 1 : With E1 internal homing ; 2 : With E1 Touch probe homing 
Z2_4_EtherCATIndex = 11							! EtherCAT nod index
Z2_4_ControlUnit = 1/10							! E1 Control unit
!!**************** Configuration of 1D Error Compensation*****************************************************!!
Z2_4_ErrCompensation = 1						! 0 : without compensation  ; 1 : turn on the compensation after homing completed 
Z2_4_ErrCompIniPos = 0							! the initial position of error compensation
Z2_4_ErrCompensationSpacing = 4000				! setting the spacing for error compensation 
!!**********************************************************************************************************!!
!!######################################################################################################################################## 

!!**************************************************************************************************************************************!!
!!************************************************************ Main program ************************************************************!!
FCLEAR Z2_4_axis
IF Z2_4_HmType=0													! Customized homing
	CALL Z2_4_HmType0	
ELSEIF Z2_4_HiwinDriveHome=1										! E1 internal
	MFLAGS(Z2_4_axis).#HOME=0	
	IF Z2_4_HmType=1
		Z2_4_InternalHmType = 1
	ELSEIF Z2_4_HmType=2
		Z2_4_InternalHmType = 34
	ELSE
		DISP"ERROR:The value of Z2_4_HmType is invalid!!"
		STOP
	END
	CALL Z2_4_HiwinDriveInternalHmType	
ELSEIF Z2_4_HiwinDriveHome=2										! Touch probe
		MFLAGS(Z2_4_axis).#HOME=0	
	IF Z2_4_HmType=1
		CALL Z2_4_HiwinDriveTouchProbeHmType1
	ELSEIF Z2_4_HmType=2
		CALL Z2_4_HiwinDriveTouchProbeHmType2
	ELSE
		DISP"ERROR:The value of Z2_4_HmType is invalid!!"
		STOP
	END
ELSE
	DISP"ERROR:The value of Z2_4_HmType or Z2_4_HiwinDriveHome is invalid!!"
	STOP
END

IF Z2_4_ErrCompensation = 1
	DISP "Enable the compensation mode."
	DISP "Execute the compensation prcoess......"
	CALL Z2_4_ErrorCompensation	
ELSE
	DISP "Disable error compensation."
	ERRORUNMAP Z2_4_axis, ZONE0
END 

IF (Z2_4_HmType>=1&Z2_4_HmType<=2)
	ENABLE Z2_4_axis
	TILL MST(Z2_4_axis).#ENABLED
	WAIT 500
	DISP"Go home......"	
	PTP/EV Z2_4_axis,0,Z2_4_HmVel	
	MFLAGS(Z2_4_axis).#HOME=1
END	
FDEF(Z2_4_axis).#LL = 1	 		
FDEF(Z2_4_axis).#SRL = 1	 		
FDEF(Z2_4_axis).#SLL = 1	 
DISP"Homing successful!!"	

STOP	

!!*************************************************************************************************************************************!!
!!************************************************************ Homing process	*******************************************************!!
Z2_4_HmType0:
!Customized
RET
STOP
!------------------------------------------------------------------Z2_4_HiwinDriveTouchProbeHmType1--------------------------------------------------------------------------------------
Z2_4_HiwinDriveTouchProbeHmType1:

FCLEAR Z2_4_axis
DISABLE Z2_4_axis		
TILL ^MST(Z2_4_axis).#ENABLED	
WAIT 500	
MFLAGS(Z2_4_axis).#OPEN = 0								! Close loop control
ERRORMAPOFF Z2_4_axis, -1									! Close all axis error compensation
MFLAGS(Z2_4_axis).#GANTRY = 0								! turn off gantry mode (MFLAGS.25)	
FDEF(Z2_4_axis).#SRL = 0	 								! disable software right limit response
FDEF(Z2_4_axis).#SLL = 0	 								! disable software left limit response
FDEF(Z2_4_axis).#LL = 0	 										! motor is not disable when left limit signal rising.

ENABLE	Z2_4_axis	 
TILL MST(Z2_4_axis).#ENABLED	 
WAIT 500	
DISP"Start to find the left limit......"
JOG/V Z2_4_axis,-Z2_4_HmVel									! find the left limit in negative direction
TILL (COEREAD/4 (Z2_4_EtherCATIndex,0x60FD,0)& 1) = 1
HALT Z2_4_axis 
TILL ^MST(Z2_4_axis).#MOVE,1000							! if reach left limit , stop motion
DISP"Already found the left limit!!"

!!!!!!!!!!!!!!!!!!!!multi index Structure Homing Way!!!!!!!!!!!!!!!
IF(Z2_4_multi_indHm = 1)	
	JOG/V Z2_4_axis,Z2_4_multi_indVel							! slowing to leave the limit in negative direction
	TILL (COEREAD/4 (Z2_4_EtherCATIndex,0x60FD,0)& 1) = 0	! waiting to leave the limit
	HALT Z2_4_axis
	TILL ^MST(Z2_4_axis).#MOVE 
	Z2_4_IndVel = Z2_4_multi_indVel							! define slowing velocity to find index velocity
END
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
ECOUT(ECGETOFFSET("Touch probe function",Z2_4_EtherCATIndex),Z2_4_TouchProbFun)
WAIT 200
Z2_4_TouchProbFun = 0										!Reset Touch probe
WAIT 200
Z2_4_TouchProbFun = 17										! Start Touch probe
WAIT 200
DISP"Start to find the index in positive direction......"
JOG/V Z2_4_axis,Z2_4_IndVel									!find the index in positive direction
TILL (COEREAD/2 (Z2_4_EtherCATIndex,0x60B9,0) = 3)			!if reach index	, stop motion
HALT Z2_4_axis	
TILL ^MST(Z2_4_axis).#MOVE 
DISP"Already found the index!!"
SET FPOS(Z2_4_axis) = (COEREAD/4 (Z2_4_EtherCATIndex,0x6064,0) - COEREAD/4 (Z2_4_EtherCATIndex,0x60BA,0))*Z2_4_ControlUnit - Z2_4_HmOffset		!set index position as zero.
WAIT 500
ECUNMAPOUT (ECGETOFFSET("Touch probe function",Z2_4_EtherCATIndex))	
RET	
STOP
!------------------------------------------------------------------Z2_4_HiwinDriveTouchProbeHmType2--------------------------------------------------------------------------------------
Z2_4_HiwinDriveTouchProbeHmType2:

FCLEAR Z2_4_axis
DISABLE Z2_4_axis		
TILL ^MST(Z2_4_axis).#ENABLED	
WAIT 500	
MFLAGS(Z2_4_axis).#OPEN = 0						! Close loop control
ERRORMAPOFF Z2_4_axis, -1							! Close all axis error compensation
MFLAGS(Z2_4_axis).#GANTRY = 0	 					! turn off gantry mode (MFLAGS.25)	
FDEF(Z2_4_axis).#SRL = 0	 						! disable software right limit response
FDEF(Z2_4_axis).#SLL = 0	 						! disable software left limit response
FDEF(Z2_4_axis).#LL = 0	 										! motor is not disable when left limit signal rising.

ENABLE	Z2_4_axis	 
!!!!!!!!!!!!!!!!!!!!multi index Structure Homing Way!!!!!!!!!!!!!!!
IF(Z2_4_multi_indHm = 1)	
	Z2_4_IndVel = Z2_4_multi_indVel					! define slowing velocity to find index velocity
END
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
ECOUT(ECGETOFFSET("Touch probe function",Z2_4_EtherCATIndex),Z2_4_TouchProbFun)
WAIT 200
Z2_4_TouchProbFun = 0								!Reset Touch probe
WAIT 200
Z2_4_TouchProbFun = 17								! Start Touch probe
WAIT 200
DISP"Start to find the index in positive direction......"
JOG/V Z2_4_axis,Z2_4_IndVel							!find the index in positive direction
TILL (COEREAD/2 (Z2_4_EtherCATIndex,0x60B9,0) = 3)	!if reach index	, stop motion
HALT Z2_4_axis	
TILL ^MST(Z2_4_axis).#MOVE 
DISP"Already found the index!!"
SET FPOS(Z2_4_axis) = (COEREAD/4 (Z2_4_EtherCATIndex,0x6064,0) - COEREAD/4 (Z2_4_EtherCATIndex,0x60BA,0))*Z2_4_ControlUnit - Z2_4_HmOffset	!set index position as zero.
WAIT 500
ECUNMAPOUT (ECGETOFFSET("Touch probe function",Z2_4_EtherCATIndex))		
RET	
STOP
!------------------------------------------------------------------Z2_4_HiwinDriveInternalHmType--------------------------------------------------------------------------------------
Z2_4_HiwinDriveInternalHmType:

FCLEAR Z2_4_axis
FDEF(Z2_4_axis).#LL = 0	 										! motor is not disable when left limit signal rising.
FDEF(Z2_4_axis).#SRL = 0	 										! disable software right limit response
FDEF(Z2_4_axis).#SLL = 0	 										! disable software left limit response
Z2_4_HiwinDriveHmVel = Z2_4_HmVel/Z2_4_ControlUnit
Z2_4_HiwinDriveIndVel = Z2_4_IndVel/Z2_4_ControlUnit
Z2_4_HiwinDriveHmOffset = Z2_4_HmOffset/Z2_4_ControlUnit
Z2_4_HiwinDriveHmAcc = ACC(Z2_4_axis)/Z2_4_ControlUnit

ECIN( ECGETOFFSET("Statusword",Z2_4_EtherCATIndex),Z2_4_StatusWord)  
ECOUT(ECGETOFFSET("Controlword",Z2_4_EtherCATIndex),Z2_4_ControlWord)
IF Z2_4_IsModeOfOperationInPDO = 1
	ECOUT(ECGETOFFSET("Mode of operation",Z2_4_EtherCATIndex),Z2_4_ModeOfOperation)
	Z2_4_ModeOfOperation = 6
ELSE
	COEWRITE/1 (Z2_4_EtherCATIndex,0x6060,0,6) !6 is Homing mode  
END  


COEWRITE/1 (Z2_4_EtherCATIndex,0x6098,0,Z2_4_InternalHmType)	
COEWRITE/4 (Z2_4_EtherCATIndex,0x6099,1,Z2_4_HiwinDriveHmVel) 	
COEWRITE/4 (Z2_4_EtherCATIndex,0x6099,2,Z2_4_HiwinDriveIndVel)	
COEWRITE/4 (Z2_4_EtherCATIndex,0x609A,0,Z2_4_HiwinDriveHmAcc)	
COEWRITE/4 (Z2_4_EtherCATIndex,0x607C,0,Z2_4_HiwinDriveHmOffset) 	

Z2_4_ControlWord=6  
TILL Z2_4_StatusWord.0=1  
Z2_4_ControlWord=7  
TILL Z2_4_StatusWord.0=1 & Z2_4_StatusWord.1=1

WAIT 200 

Z2_4_ControlWord=15  
TILL Z2_4_StatusWord.0=1 & Z2_4_StatusWord.1=1 & Z2_4_StatusWord.2=1	!Enabled
!Start Homing Procedure - Bit 4  
Z2_4_ControlWord=31  											!Start Home
TILL Z2_4_StatusWord.12=1 & Z2_4_StatusWord.10=1 | Z2_4_StatusWord.13=1				!Home Finished

IF Z2_4_StatusWord.13=1
	CALL HomeFail
END

Z2_4_ControlWord=0  

WAIT 100

IF Z2_4_IsModeOfOperationInPDO = 1
	Z2_4_ModeOfOperation = 8 
	WAIT 500 
	ECUNMAPOUT (ECGETOFFSET("Mode of operation",Z2_4_EtherCATIndex))
ELSE
	COEWRITE/1 (Z2_4_EtherCATIndex,0x6060,0,8)						!go back to CSP mode 
END  
WAIT 500 
ECUNMAPIN (ECGETOFFSET("Statusword",Z2_4_EtherCATIndex))
ECUNMAPOUT (ECGETOFFSET("Controlword",Z2_4_EtherCATIndex))

WAIT 500 
DISABLE Z2_4_axis
TILL ^MST(Z2_4_axis).#ENABLED 

RET
STOP
!!*************************************************************************************************************************************!!
!!****************************************************** Error Compensation Process ***************************************************!!
Z2_4_ErrorCompensation:
!---------- Z2_4_axis Error Compensation Table ------------!
Z2_4_ErrTable(0)=	0	;
Z2_4_ErrTable(1)=	0	;
Z2_4_ErrTable(2)=	0.1	;
Z2_4_ErrTable(3)=	0.1	;
Z2_4_ErrTable(4)=	0.1	;
Z2_4_ErrTable(5)=	0.4	;
Z2_4_ErrTable(6)=	0.2	;
Z2_4_ErrTable(7)=	0.3	;
Z2_4_ErrTable(8)=	0.6	;
Z2_4_ErrTable(9)=	0.5	;
Z2_4_ErrTable(10)=	0.6	;


!-------------------------------------------------------!
Z2_4_ErrTableIndex = 0
WHILE Z2_4_ErrTableIndex < SIZEOF(Z2_4_ErrTable)
	Z2_4_ErrTable(Z2_4_ErrTableIndex) = -Z2_4_ErrTable(Z2_4_ErrTableIndex)
	Z2_4_ErrTableIndex = Z2_4_ErrTableIndex + 1
END
ERRORUNMAP Z2_4_axis, ZONE0
ERRORMAP1D Z2_4_axis, ZONE0, Z2_4_ErrCompIniPos, Z2_4_ErrCompensationSpacing, Z2_4_ErrTable
ERRORMAPON Z2_4_axis, ZONE0

WAIT 500	
DISP "Cmpensation Procces's completed!"

RET 
STOP
!!#############################################################################################################################

ON MFLAGS(Z2_4_axis).#HOME=1 & TPOS(Z2_4_axis) < SLLIMIT(Z2_4_axis) 
	IF( FDEF(Z2_4_axis).#SLL=1 & FMASK(Z2_4_axis).#SLL=1 & ^(GMTYPE(Z2_4_axis)=5))
		KILL Z2_4_axis,5016	!Software Left Limit
		TPOS(Z2_4_axis)=FPOS(Z2_4_axis)
		DISP "TPOS(Z2_4_axis) < SLLIMIT(Z2_4_axis)"
	END
RET

ON MFLAGS(Z2_4_axis).#HOME=1 & TPOS(Z2_4_axis) > SRLIMIT(Z2_4_axis) 
	IF(FDEF(Z2_4_axis).#SRL=1 & FMASK(Z2_4_axis).#SRL=1 & ^(GMTYPE(Z2_4_axis)=5))
		KILL Z2_4_axis,5015	!Software Right Limit
		TPOS(Z2_4_axis)=FPOS(Z2_4_axis)
		DISP "TPOS(Z2_4_axis) > SRLIMIT(Z2_4_axis)"
	END
RET


ON MFLAGS(Z2_4_axis).#HOME=0 & RVEL(Z2_4_axis) > XVEL(Z2_4_axis)*0.5 & ^MST(Z2_4_axis).#INPOS
	IMM VEL(Z2_4_axis) = XVEL(Z2_4_axis)*0.45 
RET

ON MFLAGS(Z2_4_axis).#HOME=0 & RVEL(Z2_4_axis) < -XVEL(Z2_4_axis)*0.5 & ^MST(Z2_4_axis).#INPOS
	IMM VEL(Z2_4_axis) = -XVEL(Z2_4_axis)*0.45 
RET

AUTOEXEC:
	Z2_4_IOIndex = 15
	MFLAGS(Z2_4_axis).#HOME=0
STOP

ON IN(Z2_4_IOIndex).0 = 1
	SAFINI(Z2_4_axis).#LL = 1
RET

ON IN(Z2_4_IOIndex).0 = 0
	SAFINI(Z2_4_axis).#LL = 0
RET

ON IN(Z2_4_IOIndex).1 = 1
	SAFINI(Z2_4_axis).#RL = 1
RET

ON IN(Z2_4_IOIndex).1 = 0
	SAFINI(Z2_4_axis).#RL = 0
RET

!ON MST(Z2_4_axis).#ENABLED & (IN(Z2_4_IOIndex).24 = 1 | IN(Z2_4_IOIndex).25 = 1)
!	KILL Z2_4_axis
!	TILL ^MST(Z2_4_axis).#MOVE,500 
!	DISABLE Z2_4_axis,5028		!Safe Torque Off
!	TILL ^MST(Z2_4_axis).#ENABLED
!RET	

ON IN(Z2_4_IOIndex).24 = 1 | IN(Z2_4_IOIndex).25 = 1
    DISP"Z2_4_Event Time : %d",TIME
 	DISP"Z2_4_Z2_4_CHECK SF1 Value : %d",IN(Z2_4_IOIndex).24
	DISP"Z2_4_CHECK SF2 Value : %d",IN(Z2_4_IOIndex).25
	WAIT 5
	DISP"Z2_4_CHECK FAULT Value : %d", SAFIN(Z2_4_axis).9
	DISP"Z2_4_CHECK E1 FAULT : %d",AxisErrorCode26
RET
RET	

HomeFail:
DISP" E1 homing fail "
IF Z2_4_IsModeOfOperationInPDO = 1
	Z2_4_ModeOfOperation = 8 
	WAIT 500 
	ECUNMAPOUT (ECGETOFFSET("Mode of operation",Z2_4_EtherCATIndex))
ELSE
	COEWRITE/1 (Z2_4_EtherCATIndex,0x6060,0,8)						!go back to CSP mode 
END  
WAIT 500 
ECUNMAPIN (ECGETOFFSET("Statusword",Z2_4_EtherCATIndex))
ECUNMAPOUT (ECGETOFFSET("Controlword",Z2_4_EtherCATIndex))

STOP
#17
!PNAME=
!PDESC=
! T2_1_axis Single-axis_Hiwin_Drive_Homing_Process_VER1.5
!!****** Setting Parameter ******!!
LOCAL REAL T2_1_HmType,T2_1_multi_indHm,T2_1_multi_indVel
LOCAL REAL T2_1_HmVel,T2_1_IndVel,T2_1_HmOffset	
LOCAL INT T2_1_ErrCompensation,T2_1_ErrCompensationSpacing,T2_1_ErrCompIniPos
LOCAL INT ZONE0,T2_1_ErrTableIndex
LOCAL INT T2_1_HiwinDriveHome,T2_1_EtherCATIndex,T2_1_InternalHmType
LOCAL REAL T2_1_ControlUnit
LOCAL INT T2_1_IsModeOfOperationInPDO
LOCAL REAL T2_1_HiwinDriveHmVel,T2_1_HiwinDriveIndVel,T2_1_HiwinDriveHmOffset,T2_1_HiwinDriveHmAcc
!!################ Basic Settings ######################################################################################################
T2_1_IOIndex = 16
T2_1_HmType = 1 								!the method of homing
           									!value 0 : Customized homing
           									!	   1 : find the left limit in negative direction,then find index in positive direction 
           									!      2 : find index in positive direction directly 
T2_1_HmOffset = 0 								! T2_1_HmOffset (unit)
T2_1_HmVel = 3000								! the velocity for homing 	
T2_1_IndVel = 500!1000 								! the velocity for finding index

T2_1_multi_indHm=0								! multi index structure
											! value 0 : nomal Homing
											!	    1 : find the left limit in negative direction,then slowing leave the limit in positive direction,
											!			then slowing find the left limit in negative direction,then slowing find index in positive direction
T2_1_multi_indVel = 0.1						! (Do not modify)homing velocity of multi index structure
!!*********************************** With Hiwin Drive homing support HmType 1&2************************************!!
T2_1_IsModeOfOperationInPDO = 0					! Check #ETHERCAT if include Mode of operation slect 1 else select 0
T2_1_HiwinDriveHome = 1						! 1 : With E1 internal homing ; 2 : With E1 Touch probe homing 
T2_1_EtherCATIndex = 12							! EtherCAT nod index
T2_1_ControlUnit = 360/5000							! E1 Control unit
!!**************** Configuration of 1D Error Compensation*****************************************************!!
T2_1_ErrCompensation = 0						! 0 : without compensation  ; 1 : turn on the compensation after homing completed 
T2_1_ErrCompIniPos = 0							! the initial position of error compensation
T2_1_ErrCompensationSpacing = 50				! setting the spacing for error compensation 
!!**********************************************************************************************************!!
!!######################################################################################################################################## 

!!**************************************************************************************************************************************!!
!!************************************************************ Main program ************************************************************!!
FCLEAR T2_1_axis
IF T2_1_HmType=0													! Customized homing
	CALL T2_1_HmType0	
ELSEIF T2_1_HiwinDriveHome=1										! E1 internal
	MFLAGS(T2_1_axis).#HOME=0	
	IF T2_1_HmType=1
		T2_1_InternalHmType = 1
	ELSEIF T2_1_HmType=2
		T2_1_InternalHmType = 34
	ELSE
		DISP"ERROR:The value of T2_1_HmType is invalid!!"
		STOP
	END
	CALL T2_1_HiwinDriveInternalHmType	
ELSEIF T2_1_HiwinDriveHome=2										! Touch probe
		MFLAGS(T2_1_axis).#HOME=0	
	IF T2_1_HmType=1
		CALL T2_1_HiwinDriveTouchProbeHmType1
	ELSEIF T2_1_HmType=2
		CALL T2_1_HiwinDriveTouchProbeHmType2
	ELSE
		DISP"ERROR:The value of T2_1_HmType is invalid!!"
		STOP
	END
ELSE
	DISP"ERROR:The value of T2_1_HmType or T2_1_HiwinDriveHome is invalid!!"
	STOP
END

IF T2_1_ErrCompensation = 1
	DISP "Enable the compensation mode."
	DISP "Execute the compensation prcoess......"
	CALL T2_1_ErrorCompensation	
ELSE
	DISP "Disable error compensation."
	ERRORUNMAP T2_1_axis, ZONE0
END 

IF (T2_1_HmType>=1&T2_1_HmType<=2)
	ENABLE T2_1_axis
	TILL MST(T2_1_axis).#ENABLED
	WAIT 500
	DISP"Go home......"	
	PTP/EV T2_1_axis,0,T2_1_HmVel	
	MFLAGS(T2_1_axis).#HOME=1
END	
FDEF(T2_1_axis).#LL = 1	 		
FDEF(T2_1_axis).#SRL = 1	 		
FDEF(T2_1_axis).#SLL = 1	 
DISP"Homing successful!!"	

STOP	

!!*************************************************************************************************************************************!!
!!************************************************************ Homing process	*******************************************************!!
T2_1_HmType0:
!Customized
RET
STOP
!------------------------------------------------------------------T2_1_HiwinDriveTouchProbeHmType1--------------------------------------------------------------------------------------
T2_1_HiwinDriveTouchProbeHmType1:

FCLEAR T2_1_axis
DISABLE T2_1_axis		
TILL ^MST(T2_1_axis).#ENABLED	
WAIT 500	
MFLAGS(T2_1_axis).#OPEN = 0								! Close loop control
ERRORMAPOFF T2_1_axis, -1									! Close all axis error compensation
MFLAGS(T2_1_axis).#GANTRY = 0								! turn off gantry mode (MFLAGS.25)	
FDEF(T2_1_axis).#SRL = 0	 								! disable software right limit response
FDEF(T2_1_axis).#SLL = 0	 								! disable software left limit response
FDEF(T2_1_axis).#LL = 0	 										! motor is not disable when left limit signal rising.

ENABLE	T2_1_axis	 
TILL MST(T2_1_axis).#ENABLED	 
WAIT 500	
DISP"Start to find the left limit......"
JOG/V T2_1_axis,-T2_1_HmVel									! find the left limit in negative direction
TILL (COEREAD/4 (T2_1_EtherCATIndex,0x60FD,0)& 1) = 1
HALT T2_1_axis 
TILL ^MST(T2_1_axis).#MOVE,1000							! if reach left limit , stop motion
DISP"Already found the left limit!!"

!!!!!!!!!!!!!!!!!!!!multi index Structure Homing Way!!!!!!!!!!!!!!!
IF(T2_1_multi_indHm = 1)	
	JOG/V T2_1_axis,T2_1_multi_indVel							! slowing to leave the limit in negative direction
	TILL (COEREAD/4 (T2_1_EtherCATIndex,0x60FD,0)& 1) = 0	! waiting to leave the limit
	HALT T2_1_axis
	TILL ^MST(T2_1_axis).#MOVE 
	T2_1_IndVel = T2_1_multi_indVel							! define slowing velocity to find index velocity
END
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
ECOUT(ECGETOFFSET("Touch probe function",T2_1_EtherCATIndex),T2_1_TouchProbFun)
WAIT 200
T2_1_TouchProbFun = 0										!Reset Touch probe
WAIT 200
T2_1_TouchProbFun = 17										! Start Touch probe
WAIT 200
DISP"Start to find the index in positive direction......"
JOG/V T2_1_axis,T2_1_IndVel									!find the index in positive direction
TILL (COEREAD/2 (T2_1_EtherCATIndex,0x60B9,0) = 3)			!if reach index	, stop motion
HALT T2_1_axis	
TILL ^MST(T2_1_axis).#MOVE 
DISP"Already found the index!!"
SET FPOS(T2_1_axis) = (COEREAD/4 (T2_1_EtherCATIndex,0x6064,0) - COEREAD/4 (T2_1_EtherCATIndex,0x60BA,0))*T2_1_ControlUnit - T2_1_HmOffset		!set index position as zero.
WAIT 500
ECUNMAPOUT (ECGETOFFSET("Touch probe function",T2_1_EtherCATIndex))	
RET	
STOP
!------------------------------------------------------------------T2_1_HiwinDriveTouchProbeHmType2--------------------------------------------------------------------------------------
T2_1_HiwinDriveTouchProbeHmType2:

FCLEAR T2_1_axis
DISABLE T2_1_axis		
TILL ^MST(T2_1_axis).#ENABLED	
WAIT 500	
MFLAGS(T2_1_axis).#OPEN = 0						! Close loop control
ERRORMAPOFF T2_1_axis, -1							! Close all axis error compensation
MFLAGS(T2_1_axis).#GANTRY = 0	 					! turn off gantry mode (MFLAGS.25)	
FDEF(T2_1_axis).#SRL = 0	 						! disable software right limit response
FDEF(T2_1_axis).#SLL = 0	 						! disable software left limit response
FDEF(T2_1_axis).#LL = 0	 										! motor is not disable when left limit signal rising.

ENABLE	T2_1_axis	 
!!!!!!!!!!!!!!!!!!!!multi index Structure Homing Way!!!!!!!!!!!!!!!
IF(T2_1_multi_indHm = 1)	
	T2_1_IndVel = T2_1_multi_indVel					! define slowing velocity to find index velocity
END
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
ECOUT(ECGETOFFSET("Touch probe function",T2_1_EtherCATIndex),T2_1_TouchProbFun)
WAIT 200
T2_1_TouchProbFun = 0								!Reset Touch probe
WAIT 200
T2_1_TouchProbFun = 17								! Start Touch probe
WAIT 200
DISP"Start to find the index in positive direction......"
JOG/V T2_1_axis,T2_1_IndVel							!find the index in positive direction
TILL (COEREAD/2 (T2_1_EtherCATIndex,0x60B9,0) = 3)	!if reach index	, stop motion
HALT T2_1_axis	
TILL ^MST(T2_1_axis).#MOVE 
DISP"Already found the index!!"
SET FPOS(T2_1_axis) = (COEREAD/4 (T2_1_EtherCATIndex,0x6064,0) - COEREAD/4 (T2_1_EtherCATIndex,0x60BA,0))*T2_1_ControlUnit - T2_1_HmOffset	!set index position as zero.
WAIT 500
ECUNMAPOUT (ECGETOFFSET("Touch probe function",T2_1_EtherCATIndex))		
RET	
STOP
!------------------------------------------------------------------T2_1_HiwinDriveInternalHmType--------------------------------------------------------------------------------------
T2_1_HiwinDriveInternalHmType:

FCLEAR T2_1_axis
FDEF(T2_1_axis).#LL = 0	 										! motor is not disable when left limit signal rising.
FDEF(T2_1_axis).#SRL = 0	 										! disable software right limit response
FDEF(T2_1_axis).#SLL = 0	 										! disable software left limit response
T2_1_HiwinDriveHmVel = T2_1_HmVel/T2_1_ControlUnit
T2_1_HiwinDriveIndVel = T2_1_IndVel/T2_1_ControlUnit
T2_1_HiwinDriveHmOffset = T2_1_HmOffset/T2_1_ControlUnit
T2_1_HiwinDriveHmAcc = ACC(T2_1_axis)/T2_1_ControlUnit

ECIN( ECGETOFFSET("Statusword",T2_1_EtherCATIndex),T2_1_StatusWord)  
ECOUT(ECGETOFFSET("Controlword",T2_1_EtherCATIndex),T2_1_ControlWord)
IF T2_1_IsModeOfOperationInPDO = 1
	ECOUT(ECGETOFFSET("Mode of operation",T2_1_EtherCATIndex),T2_1_ModeOfOperation)
	T2_1_ModeOfOperation = 6
ELSE
	COEWRITE/1 (T2_1_EtherCATIndex,0x6060,0,6) !6 is Homing mode  
END  


COEWRITE/1 (T2_1_EtherCATIndex,0x6098,0,T2_1_InternalHmType)	
COEWRITE/4 (T2_1_EtherCATIndex,0x6099,1,T2_1_HiwinDriveHmVel) 	
COEWRITE/4 (T2_1_EtherCATIndex,0x6099,2,T2_1_HiwinDriveIndVel)	
COEWRITE/4 (T2_1_EtherCATIndex,0x609A,0,T2_1_HiwinDriveHmAcc)	
COEWRITE/4 (T2_1_EtherCATIndex,0x607C,0,T2_1_HiwinDriveHmOffset) 	

T2_1_ControlWord=6  
TILL T2_1_StatusWord.0=1  
T2_1_ControlWord=7  
TILL T2_1_StatusWord.0=1 & T2_1_StatusWord.1=1

WAIT 200 

T2_1_ControlWord=15  
TILL T2_1_StatusWord.0=1 & T2_1_StatusWord.1=1 & T2_1_StatusWord.2=1	!Enabled
!Start Homing Procedure - Bit 4  
T2_1_ControlWord=31  											!Start Home
TILL T2_1_StatusWord.12=1 & T2_1_StatusWord.10=1 | T2_1_StatusWord.13=1				!Home Finished

IF T2_1_StatusWord.13=1
	CALL HomeFail
END


T2_1_ControlWord=0  

WAIT 100

IF T2_1_IsModeOfOperationInPDO = 1
	T2_1_ModeOfOperation = 8 
	WAIT 500 
	ECUNMAPOUT (ECGETOFFSET("Mode of operation",T2_1_EtherCATIndex))
ELSE
	COEWRITE/1 (T2_1_EtherCATIndex,0x6060,0,8)						!go back to CSP mode 
END  
WAIT 500 
ECUNMAPIN (ECGETOFFSET("Statusword",T2_1_EtherCATIndex))
ECUNMAPOUT (ECGETOFFSET("Controlword",T2_1_EtherCATIndex))

WAIT 500 
DISABLE T2_1_axis
TILL ^MST(T2_1_axis).#ENABLED 

RET
STOP
!!*************************************************************************************************************************************!!
!!****************************************************** Error Compensation Process ***************************************************!!
T2_1_ErrorCompensation:
!---------- T2_1_axis Error Compensation Table ------------!
T2_1_ErrTable(0) = 0	;     
T2_1_ErrTable(1) = 0	;
T2_1_ErrTable(2) = 0	;
T2_1_ErrTable(3) = 0	;
T2_1_ErrTable(4) = 0	;
T2_1_ErrTable(5) = 0	;
T2_1_ErrTable(6) = 0	;
T2_1_ErrTable(7) = 0	;
T2_1_ErrTable(8) = 0	;
T2_1_ErrTable(9) = 0	;
T2_1_ErrTable(10) = 0	;

!-------------------------------------------------------!
T2_1_ErrTableIndex = 0
WHILE T2_1_ErrTableIndex < SIZEOF(T2_1_ErrTable)
	T2_1_ErrTable(T2_1_ErrTableIndex) = -T2_1_ErrTable(T2_1_ErrTableIndex)
	T2_1_ErrTableIndex = T2_1_ErrTableIndex + 1
END
ERRORUNMAP T2_1_axis, ZONE0
ERRORMAP1D T2_1_axis, ZONE0, T2_1_ErrCompIniPos, T2_1_ErrCompensationSpacing, T2_1_ErrTable
ERRORMAPON T2_1_axis, ZONE0

WAIT 500	
DISP "Cmpensation Procces's completed!"

RET 
STOP
!!#############################################################################################################################

ON MFLAGS(T2_1_axis).#HOME=1 & TPOS(T2_1_axis) < SLLIMIT(T2_1_axis) 
	IF( FDEF(T2_1_axis).#SLL=1 & FMASK(T2_1_axis).#SLL=1 & ^(GMTYPE(T2_1_axis)=5))
		KILL T2_1_axis,5016	!Software Left Limit
		TPOS(T2_1_axis)=FPOS(T2_1_axis)
		DISP "TPOS(T2_1_axis) < SLLIMIT(T2_1_axis)"
	END
RET

ON MFLAGS(T2_1_axis).#HOME=1 & TPOS(T2_1_axis) > SRLIMIT(T2_1_axis) 
	IF(FDEF(T2_1_axis).#SRL=1 & FMASK(T2_1_axis).#SRL=1 & ^(GMTYPE(T2_1_axis)=5))
		KILL T2_1_axis,5015	!Software Right Limit
		TPOS(T2_1_axis)=FPOS(T2_1_axis)
		DISP "TPOS(T2_1_axis) > SRLIMIT(T2_1_axis)"
	END
RET


ON MFLAGS(T2_1_axis).#HOME=0 & RVEL(T2_1_axis) > XVEL(T2_1_axis)*0.5 & ^MST(T2_1_axis).#INPOS
	IMM VEL(T2_1_axis) = XVEL(T2_1_axis)*0.45 
RET

ON MFLAGS(T2_1_axis).#HOME=0 & RVEL(T2_1_axis) < -XVEL(T2_1_axis)*0.5 & ^MST(T2_1_axis).#INPOS
	IMM VEL(T2_1_axis) = -XVEL(T2_1_axis)*0.45 
RET

AUTOEXEC:
	T2_1_IOIndex = 16
	MFLAGS(T2_1_axis).#HOME=0
STOP

ON IN(T2_1_IOIndex).0 = 1
	SAFINI(T2_1_axis).#LL = 1
RET

ON IN(T2_1_IOIndex).0 = 0
	SAFINI(T2_1_axis).#LL = 0
RET

ON IN(T2_1_IOIndex).1 = 1
	SAFINI(T2_1_axis).#RL = 1
RET

ON IN(T2_1_IOIndex).1 = 0
	SAFINI(T2_1_axis).#RL = 0
RET

!ON MST(T2_1_axis).#ENABLED & (IN(T2_1_IOIndex).24 = 1 | IN(T2_1_IOIndex).25 = 1)
!	KILL T2_1_axis
!	TILL ^MST(T2_1_axis).#MOVE,500 
!	DISABLE T2_1_axis,5028		!Safe Torque Off
!	TILL ^MST(T2_1_axis).#ENABLED
!RET	

ON IN(T2_1_IOIndex).24 = 1 | IN(T2_1_IOIndex).25 = 1
    DISP"T2_1_Event Time : %d",TIME
 	DISP"T2_1_CHECK SF1 Value : %d",IN(T2_1_IOIndex).24
	DISP"T2_1_CHECK SF2 Value : %d",IN(T2_1_IOIndex).25
	WAIT 5
	DISP"T2_1_CHECK FAULT Value : %d", SAFIN(T2_1_axis).9
	DISP"T2_1_CHECK E1 FAULT : %d",AxisErrorCode27
RET	


HomeFail:
DISP" E1 homing fail "
IF T2_1_IsModeOfOperationInPDO = 1
	T2_1_ModeOfOperation = 8 
	WAIT 500 
	ECUNMAPOUT (ECGETOFFSET("Mode of operation",T2_1_EtherCATIndex))
ELSE
	COEWRITE/1 (T2_1_EtherCATIndex,0x6060,0,8)						!go back to CSP mode 
END  
WAIT 500 
ECUNMAPIN (ECGETOFFSET("Statusword",T2_1_EtherCATIndex))
ECUNMAPOUT (ECGETOFFSET("Controlword",T2_1_EtherCATIndex))

STOP
#18
!PNAME=
!PDESC=
! T2_2_axis Single-axis_Hiwin_Drive_Homing_Process_VER1.5
!!****** Setting Parameter ******!!
LOCAL REAL T2_2_HmType,T2_2_multi_indHm,T2_2_multi_indVel
LOCAL REAL T2_2_HmVel,T2_2_IndVel,T2_2_HmOffset	
LOCAL INT T2_2_ErrCompensation,T2_2_ErrCompensationSpacing,T2_2_ErrCompIniPos
LOCAL INT ZONE0,T2_2_ErrTableIndex
LOCAL INT T2_2_HiwinDriveHome,T2_2_EtherCATIndex,T2_2_InternalHmType
LOCAL REAL T2_2_ControlUnit
LOCAL INT T2_2_IsModeOfOperationInPDO
LOCAL REAL T2_2_HiwinDriveHmVel,T2_2_HiwinDriveIndVel,T2_2_HiwinDriveHmOffset,T2_2_HiwinDriveHmAcc
!!################ Basic Settings ######################################################################################################
T2_2_IOIndex = 17
T2_2_HmType = 1 								!the method of homing
           									!value 0 : Customized homing
           									!	   1 : find the left limit in negative direction,then find index in positive direction 
           									!      2 : find index in positive direction directly 
T2_2_HmOffset = 0 								! T2_2_HmOffset (unit)
T2_2_HmVel = 3000								! the velocity for homing 	
T2_2_IndVel = 500!1000 								! the velocity for finding index

T2_2_multi_indHm=0								! multi index structure
											! value 0 : nomal Homing
											!	    1 : find the left limit in negative direction,then slowing leave the limit in positive direction,
											!			then slowing find the left limit in negative direction,then slowing find index in positive direction
T2_2_multi_indVel = 0.1						! (Do not modify)homing velocity of multi index structure
!!*********************************** With Hiwin Drive homing support HmType 1&2************************************!!
T2_2_IsModeOfOperationInPDO = 0					! Check #ETHERCAT if include Mode of operation slect 1 else select 0
T2_2_HiwinDriveHome = 1						! 1 : With E1 internal homing ; 2 : With E1 Touch probe homing 
T2_2_EtherCATIndex = 13							! EtherCAT nod index
T2_2_ControlUnit = 360/5000							! E1 Control unit
!!**************** Configuration of 1D Error Compensation*****************************************************!!
T2_2_ErrCompensation = 0						! 0 : without compensation  ; 1 : turn on the compensation after homing completed 
T2_2_ErrCompIniPos = 0							! the initial position of error compensation
T2_2_ErrCompensationSpacing = 50				! setting the spacing for error compensation 
!!**********************************************************************************************************!!
!!######################################################################################################################################## 

!!**************************************************************************************************************************************!!
!!************************************************************ Main program ************************************************************!!
FCLEAR T2_2_axis
IF T2_2_HmType=0													! Customized homing
	CALL T2_2_HmType0	
ELSEIF T2_2_HiwinDriveHome=1										! E1 internal
	MFLAGS(T2_2_axis).#HOME=0	
	IF T2_2_HmType=1
		T2_2_InternalHmType = 1
	ELSEIF T2_2_HmType=2
		T2_2_InternalHmType = 34
	ELSE
		DISP"ERROR:The value of T2_2_HmType is invalid!!"
		STOP
	END
	CALL T2_2_HiwinDriveInternalHmType	
ELSEIF T2_2_HiwinDriveHome=2										! Touch probe
		MFLAGS(T2_2_axis).#HOME=0	
	IF T2_2_HmType=1
		CALL T2_2_HiwinDriveTouchProbeHmType1
	ELSEIF T2_2_HmType=2
		CALL T2_2_HiwinDriveTouchProbeHmType2
	ELSE
		DISP"ERROR:The value of T2_2_HmType is invalid!!"
		STOP
	END
ELSE
	DISP"ERROR:The value of T2_2_HmType or T2_2_HiwinDriveHome is invalid!!"
	STOP
END

IF T2_2_ErrCompensation = 1
	DISP "Enable the compensation mode."
	DISP "Execute the compensation prcoess......"
	CALL T2_2_ErrorCompensation	
ELSE
	DISP "Disable error compensation."
	ERRORUNMAP T2_2_axis, ZONE0
END 

IF (T2_2_HmType>=1&T2_2_HmType<=2)
	ENABLE T2_2_axis
	TILL MST(T2_2_axis).#ENABLED
	WAIT 500
	DISP"Go home......"	
	PTP/EV T2_2_axis,0,T2_2_HmVel	
	MFLAGS(T2_2_axis).#HOME=1
END	
FDEF(T2_2_axis).#LL = 1	 		
FDEF(T2_2_axis).#SRL = 1	 		
FDEF(T2_2_axis).#SLL = 1	 
DISP"Homing successful!!"	

STOP	

!!*************************************************************************************************************************************!!
!!************************************************************ Homing process	*******************************************************!!
T2_2_HmType0:
!Customized
RET
STOP
!------------------------------------------------------------------T2_2_HiwinDriveTouchProbeHmType1--------------------------------------------------------------------------------------
T2_2_HiwinDriveTouchProbeHmType1:

FCLEAR T2_2_axis
DISABLE T2_2_axis		
TILL ^MST(T2_2_axis).#ENABLED	
WAIT 500	
MFLAGS(T2_2_axis).#OPEN = 0								! Close loop control
ERRORMAPOFF T2_2_axis, -1									! Close all axis error compensation
MFLAGS(T2_2_axis).#GANTRY = 0								! turn off gantry mode (MFLAGS.25)	
FDEF(T2_2_axis).#SRL = 0	 								! disable software right limit response
FDEF(T2_2_axis).#SLL = 0	 								! disable software left limit response
FDEF(T2_2_axis).#LL = 0	 										! motor is not disable when left limit signal rising.

ENABLE	T2_2_axis	 
TILL MST(T2_2_axis).#ENABLED	 
WAIT 500	
DISP"Start to find the left limit......"
JOG/V T2_2_axis,-T2_2_HmVel									! find the left limit in negative direction
TILL (COEREAD/4 (T2_2_EtherCATIndex,0x60FD,0)& 1) = 1
HALT T2_2_axis 
TILL ^MST(T2_2_axis).#MOVE,1000							! if reach left limit , stop motion
DISP"Already found the left limit!!"

!!!!!!!!!!!!!!!!!!!!multi index Structure Homing Way!!!!!!!!!!!!!!!
IF(T2_2_multi_indHm = 1)	
	JOG/V T2_2_axis,T2_2_multi_indVel							! slowing to leave the limit in negative direction
	TILL (COEREAD/4 (T2_2_EtherCATIndex,0x60FD,0)& 1) = 0	! waiting to leave the limit
	HALT T2_2_axis
	TILL ^MST(T2_2_axis).#MOVE 
	T2_2_IndVel = T2_2_multi_indVel							! define slowing velocity to find index velocity
END
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
ECOUT(ECGETOFFSET("Touch probe function",T2_2_EtherCATIndex),T2_2_TouchProbFun)
WAIT 200
T2_2_TouchProbFun = 0										!Reset Touch probe
WAIT 200
T2_2_TouchProbFun = 17										! Start Touch probe
WAIT 200
DISP"Start to find the index in positive direction......"
JOG/V T2_2_axis,T2_2_IndVel									!find the index in positive direction
TILL (COEREAD/2 (T2_2_EtherCATIndex,0x60B9,0) = 3)			!if reach index	, stop motion
HALT T2_2_axis	
TILL ^MST(T2_2_axis).#MOVE 
DISP"Already found the index!!"
SET FPOS(T2_2_axis) = (COEREAD/4 (T2_2_EtherCATIndex,0x6064,0) - COEREAD/4 (T2_2_EtherCATIndex,0x60BA,0))*T2_2_ControlUnit - T2_2_HmOffset		!set index position as zero.
WAIT 500
ECUNMAPOUT (ECGETOFFSET("Touch probe function",T2_2_EtherCATIndex))	
RET	
STOP
!------------------------------------------------------------------T2_2_HiwinDriveTouchProbeHmType2--------------------------------------------------------------------------------------
T2_2_HiwinDriveTouchProbeHmType2:

FCLEAR T2_2_axis
DISABLE T2_2_axis		
TILL ^MST(T2_2_axis).#ENABLED	
WAIT 500	
MFLAGS(T2_2_axis).#OPEN = 0						! Close loop control
ERRORMAPOFF T2_2_axis, -1							! Close all axis error compensation
MFLAGS(T2_2_axis).#GANTRY = 0	 					! turn off gantry mode (MFLAGS.25)	
FDEF(T2_2_axis).#SRL = 0	 						! disable software right limit response
FDEF(T2_2_axis).#SLL = 0	 						! disable software left limit response
FDEF(T2_2_axis).#LL = 0	 										! motor is not disable when left limit signal rising.

ENABLE	T2_2_axis	 
!!!!!!!!!!!!!!!!!!!!multi index Structure Homing Way!!!!!!!!!!!!!!!
IF(T2_2_multi_indHm = 1)	
	T2_2_IndVel = T2_2_multi_indVel					! define slowing velocity to find index velocity
END
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
ECOUT(ECGETOFFSET("Touch probe function",T2_2_EtherCATIndex),T2_2_TouchProbFun)
WAIT 200
T2_2_TouchProbFun = 0								!Reset Touch probe
WAIT 200
T2_2_TouchProbFun = 17								! Start Touch probe
WAIT 200
DISP"Start to find the index in positive direction......"
JOG/V T2_2_axis,T2_2_IndVel							!find the index in positive direction
TILL (COEREAD/2 (T2_2_EtherCATIndex,0x60B9,0) = 3)	!if reach index	, stop motion
HALT T2_2_axis	
TILL ^MST(T2_2_axis).#MOVE 
DISP"Already found the index!!"
SET FPOS(T2_2_axis) = (COEREAD/4 (T2_2_EtherCATIndex,0x6064,0) - COEREAD/4 (T2_2_EtherCATIndex,0x60BA,0))*T2_2_ControlUnit - T2_2_HmOffset	!set index position as zero.
WAIT 500
ECUNMAPOUT (ECGETOFFSET("Touch probe function",T2_2_EtherCATIndex))		
RET	
STOP
!------------------------------------------------------------------T2_2_HiwinDriveInternalHmType--------------------------------------------------------------------------------------
T2_2_HiwinDriveInternalHmType:

FCLEAR T2_2_axis
FDEF(T2_2_axis).#LL = 0	 										! motor is not disable when left limit signal rising.
FDEF(T2_2_axis).#SRL = 0	 										! disable software right limit response
FDEF(T2_2_axis).#SLL = 0	 										! disable software left limit response
T2_2_HiwinDriveHmVel = T2_2_HmVel/T2_2_ControlUnit
T2_2_HiwinDriveIndVel = T2_2_IndVel/T2_2_ControlUnit
T2_2_HiwinDriveHmOffset = T2_2_HmOffset/T2_2_ControlUnit
T2_2_HiwinDriveHmAcc = ACC(T2_2_axis)/T2_2_ControlUnit

ECIN( ECGETOFFSET("Statusword",T2_2_EtherCATIndex),T2_2_StatusWord)  
ECOUT(ECGETOFFSET("Controlword",T2_2_EtherCATIndex),T2_2_ControlWord)
IF T2_2_IsModeOfOperationInPDO = 1
	ECOUT(ECGETOFFSET("Mode of operation",T2_2_EtherCATIndex),T2_2_ModeOfOperation)
	T2_2_ModeOfOperation = 6
ELSE
	COEWRITE/1 (T2_2_EtherCATIndex,0x6060,0,6) !6 is Homing mode  
END  


COEWRITE/1 (T2_2_EtherCATIndex,0x6098,0,T2_2_InternalHmType)	
COEWRITE/4 (T2_2_EtherCATIndex,0x6099,1,T2_2_HiwinDriveHmVel) 	
COEWRITE/4 (T2_2_EtherCATIndex,0x6099,2,T2_2_HiwinDriveIndVel)	
COEWRITE/4 (T2_2_EtherCATIndex,0x609A,0,T2_2_HiwinDriveHmAcc)	
COEWRITE/4 (T2_2_EtherCATIndex,0x607C,0,T2_2_HiwinDriveHmOffset) 	

T2_2_ControlWord=6  
TILL T2_2_StatusWord.0=1  
T2_2_ControlWord=7  
TILL T2_2_StatusWord.0=1 & T2_2_StatusWord.1=1

WAIT 200 

T2_2_ControlWord=15  
TILL T2_2_StatusWord.0=1 & T2_2_StatusWord.1=1 & T2_2_StatusWord.2=1	!Enabled
!Start Homing Procedure - Bit 4  
T2_2_ControlWord=31  											!Start Home
TILL T2_2_StatusWord.12=1 & T2_2_StatusWord.10=1 | T2_2_StatusWord.13=1				!Home Finished

IF T2_2_StatusWord.13=1
	CALL HomeFail
END


T2_2_ControlWord=0  

WAIT 100

IF T2_2_IsModeOfOperationInPDO = 1
	T2_2_ModeOfOperation = 8 
	WAIT 500 
	ECUNMAPOUT (ECGETOFFSET("Mode of operation",T2_2_EtherCATIndex))
ELSE
	COEWRITE/1 (T2_2_EtherCATIndex,0x6060,0,8)						!go back to CSP mode 
END  
WAIT 500 
ECUNMAPIN (ECGETOFFSET("Statusword",T2_2_EtherCATIndex))
ECUNMAPOUT (ECGETOFFSET("Controlword",T2_2_EtherCATIndex))

WAIT 500 
DISABLE T2_2_axis
TILL ^MST(T2_2_axis).#ENABLED 

RET
STOP
!!*************************************************************************************************************************************!!
!!****************************************************** Error Compensation Process ***************************************************!!
T2_2_ErrorCompensation:
!---------- T2_2_axis Error Compensation Table ------------!
T2_2_ErrTable(0) = 0	;     
T2_2_ErrTable(1) = 0	;
T2_2_ErrTable(2) = 0	;
T2_2_ErrTable(3) = 0	;
T2_2_ErrTable(4) = 0	;
T2_2_ErrTable(5) = 0	;
T2_2_ErrTable(6) = 0	;
T2_2_ErrTable(7) = 0	;
T2_2_ErrTable(8) = 0	;
T2_2_ErrTable(9) = 0	;
T2_2_ErrTable(10) = 0	;

!-------------------------------------------------------!
T2_2_ErrTableIndex = 0
WHILE T2_2_ErrTableIndex < SIZEOF(T2_2_ErrTable)
	T2_2_ErrTable(T2_2_ErrTableIndex) = -T2_2_ErrTable(T2_2_ErrTableIndex)
	T2_2_ErrTableIndex = T2_2_ErrTableIndex + 1
END
ERRORUNMAP T2_2_axis, ZONE0
ERRORMAP1D T2_2_axis, ZONE0, T2_2_ErrCompIniPos, T2_2_ErrCompensationSpacing, T2_2_ErrTable
ERRORMAPON T2_2_axis, ZONE0

WAIT 500	
DISP "Cmpensation Procces's completed!"

RET 
STOP
!!#############################################################################################################################

ON MFLAGS(T2_2_axis).#HOME=1 & TPOS(T2_2_axis) < SLLIMIT(T2_2_axis) 
	IF( FDEF(T2_2_axis).#SLL=1 & FMASK(T2_2_axis).#SLL=1 & ^(GMTYPE(T2_2_axis)=5))
		KILL T2_2_axis,5016	!Software Left Limit
		TPOS(T2_2_axis)=FPOS(T2_2_axis)
		DISP "TPOS(T2_2_axis) < SLLIMIT(T2_2_axis)"
	END
RET

ON MFLAGS(T2_2_axis).#HOME=1 & TPOS(T2_2_axis) > SRLIMIT(T2_2_axis) 
	IF(FDEF(T2_2_axis).#SRL=1 & FMASK(T2_2_axis).#SRL=1 & ^(GMTYPE(T2_2_axis)=5))
		KILL T2_2_axis,5015	!Software Right Limit
		TPOS(T2_2_axis)=FPOS(T2_2_axis)
		DISP "TPOS(T2_2_axis) > SRLIMIT(T2_2_axis)"
	END
RET


ON MFLAGS(T2_2_axis).#HOME=0 & RVEL(T2_2_axis) > XVEL(T2_2_axis)*0.5 & ^MST(T2_2_axis).#INPOS
	IMM VEL(T2_2_axis) = XVEL(T2_2_axis)*0.45 
RET

ON MFLAGS(T2_2_axis).#HOME=0 & RVEL(T2_2_axis) < -XVEL(T2_2_axis)*0.5 & ^MST(T2_2_axis).#INPOS
	IMM VEL(T2_2_axis) = -XVEL(T2_2_axis)*0.45 
RET

AUTOEXEC:
	T2_2_IOIndex = 17
	MFLAGS(T2_2_axis).#HOME=0
STOP

ON IN(T2_2_IOIndex).0 = 1
	SAFINI(T2_2_axis).#LL = 1
RET

ON IN(T2_2_IOIndex).0 = 0
	SAFINI(T2_2_axis).#LL = 0
RET

ON IN(T2_2_IOIndex).1 = 1
	SAFINI(T2_2_axis).#RL = 1
RET

ON IN(T2_2_IOIndex).1 = 0
	SAFINI(T2_2_axis).#RL = 0
RET

!ON MST(T2_2_axis).#ENABLED & (IN(T2_2_IOIndex).24 = 1 | IN(T2_2_IOIndex).25 = 1)
!	KILL T2_2_axis
!	TILL ^MST(T2_2_axis).#MOVE,500 
!	DISABLE T2_2_axis,5028		!Safe Torque Off
!	TILL ^MST(T2_2_axis).#ENABLED
!RET	

ON IN(T2_2_IOIndex).24 = 1 | IN(T2_2_IOIndex).25 = 1
    DISP"T2_3_Event Time : %d",TIME
 	DISP"T2_3_CHECK SF1 Value : %d",IN(T2_2_IOIndex).24
	DISP"T2_3_CHECK SF2 Value : %d",IN(T2_2_IOIndex).25
	WAIT 5
	DISP"T2_3_CHECK FAULT Value : %d", SAFIN(T2_2_axis).9
	DISP"T2_3_CHECK E1 FAULT : %d",AxisErrorCode28
RET	

HomeFail:
DISP" E1 homing fail "
IF T2_2_IsModeOfOperationInPDO = 1
	T2_2_ModeOfOperation = 8 
	WAIT 500 
	ECUNMAPOUT (ECGETOFFSET("Mode of operation",T2_2_EtherCATIndex))
ELSE
	COEWRITE/1 (T2_2_EtherCATIndex,0x6060,0,8)						!go back to CSP mode 
END  
WAIT 500 
ECUNMAPIN (ECGETOFFSET("Statusword",T2_2_EtherCATIndex))
ECUNMAPOUT (ECGETOFFSET("Controlword",T2_2_EtherCATIndex))

STOP
#19
!PNAME=
!PDESC=
! T2_3_axis Single-axis_Hiwin_Drive_Homing_Process_VER1.5
!!****** Setting Parameter ******!!
LOCAL REAL T2_3_HmType,T2_3_multi_indHm,T2_3_multi_indVel
LOCAL REAL T2_3_HmVel,T2_3_IndVel,T2_3_HmOffset	
LOCAL INT T2_3_ErrCompensation,T2_3_ErrCompensationSpacing,T2_3_ErrCompIniPos
LOCAL INT ZONE0,T2_3_ErrTableIndex
LOCAL INT T2_3_HiwinDriveHome,T2_3_EtherCATIndex,T2_3_InternalHmType
LOCAL REAL T2_3_ControlUnit
LOCAL INT T2_3_IsModeOfOperationInPDO
LOCAL REAL T2_3_HiwinDriveHmVel,T2_3_HiwinDriveIndVel,T2_3_HiwinDriveHmOffset,T2_3_HiwinDriveHmAcc
!!################ Basic Settings ######################################################################################################
T2_3_IOIndex = 18
T2_3_HmType = 1 								!the method of homing
           									!value 0 : Customized homing
           									!	   1 : find the left limit in negative direction,then find index in positive direction 
           									!      2 : find index in positive direction directly 
T2_3_HmOffset = 0 								! T2_3_HmOffset (unit)
T2_3_HmVel = 3000								! the velocity for homing 	
T2_3_IndVel = 500!1000 								! the velocity for finding index

T2_3_multi_indHm=0								! multi index structure
											! value 0 : nomal Homing
											!	    1 : find the left limit in negative direction,then slowing leave the limit in positive direction,
											!			then slowing find the left limit in negative direction,then slowing find index in positive direction
T2_3_multi_indVel = 0.1						! (Do not modify)homing velocity of multi index structure
!!*********************************** With Hiwin Drive homing support HmType 1&2************************************!!
T2_3_IsModeOfOperationInPDO = 0					! Check #ETHERCAT if include Mode of operation slect 1 else select 0
T2_3_HiwinDriveHome = 1						! 1 : With E1 internal homing ; 2 : With E1 Touch probe homing 
T2_3_EtherCATIndex = 14							! EtherCAT nod index
T2_3_ControlUnit = 360/5000							! E1 Control unit
!!**************** Configuration of 1D Error Compensation*****************************************************!!
T2_3_ErrCompensation = 0						! 0 : without compensation  ; 1 : turn on the compensation after homing completed 
T2_3_ErrCompIniPos = 0							! the initial position of error compensation
T2_3_ErrCompensationSpacing = 50				! setting the spacing for error compensation 
!!**********************************************************************************************************!!
!!######################################################################################################################################## 

!!**************************************************************************************************************************************!!
!!************************************************************ Main program ************************************************************!!
FCLEAR T2_3_axis
IF T2_3_HmType=0													! Customized homing
	CALL T2_3_HmType0	
ELSEIF T2_3_HiwinDriveHome=1										! E1 internal
	MFLAGS(T2_3_axis).#HOME=0	
	IF T2_3_HmType=1
		T2_3_InternalHmType = 1
	ELSEIF T2_3_HmType=2
		T2_3_InternalHmType = 34
	ELSE
		DISP"ERROR:The value of T2_3_HmType is invalid!!"
		STOP
	END
	CALL T2_3_HiwinDriveInternalHmType	
ELSEIF T2_3_HiwinDriveHome=2										! Touch probe
		MFLAGS(T2_3_axis).#HOME=0	
	IF T2_3_HmType=1
		CALL T2_3_HiwinDriveTouchProbeHmType1
	ELSEIF T2_3_HmType=2
		CALL T2_3_HiwinDriveTouchProbeHmType2
	ELSE
		DISP"ERROR:The value of T2_3_HmType is invalid!!"
		STOP
	END
ELSE
	DISP"ERROR:The value of T2_3_HmType or T2_3_HiwinDriveHome is invalid!!"
	STOP
END

IF T2_3_ErrCompensation = 1
	DISP "Enable the compensation mode."
	DISP "Execute the compensation prcoess......"
	CALL T2_3_ErrorCompensation	
ELSE
	DISP "Disable error compensation."
	ERRORUNMAP T2_3_axis, ZONE0
END 

IF (T2_3_HmType>=1&T2_3_HmType<=2)
	ENABLE T2_3_axis
	TILL MST(T2_3_axis).#ENABLED
	WAIT 500
	DISP"Go home......"	
	PTP/EV T2_3_axis,0,T2_3_HmVel	
	MFLAGS(T2_3_axis).#HOME=1
END	
FDEF(T2_3_axis).#LL = 1	 		
FDEF(T2_3_axis).#SRL = 1	 		
FDEF(T2_3_axis).#SLL = 1	 
DISP"Homing successful!!"	

STOP	

!!*************************************************************************************************************************************!!
!!************************************************************ Homing process	*******************************************************!!
T2_3_HmType0:
!Customized
RET
STOP
!------------------------------------------------------------------T2_3_HiwinDriveTouchProbeHmType1--------------------------------------------------------------------------------------
T2_3_HiwinDriveTouchProbeHmType1:

FCLEAR T2_3_axis
DISABLE T2_3_axis		
TILL ^MST(T2_3_axis).#ENABLED	
WAIT 500	
MFLAGS(T2_3_axis).#OPEN = 0								! Close loop control
ERRORMAPOFF T2_3_axis, -1									! Close all axis error compensation
MFLAGS(T2_3_axis).#GANTRY = 0								! turn off gantry mode (MFLAGS.25)	
FDEF(T2_3_axis).#SRL = 0	 								! disable software right limit response
FDEF(T2_3_axis).#SLL = 0	 								! disable software left limit response
FDEF(T2_3_axis).#LL = 0	 										! motor is not disable when left limit signal rising.

ENABLE	T2_3_axis	 
TILL MST(T2_3_axis).#ENABLED	 
WAIT 500	
DISP"Start to find the left limit......"
JOG/V T2_3_axis,-T2_3_HmVel									! find the left limit in negative direction
TILL (COEREAD/4 (T2_3_EtherCATIndex,0x60FD,0)& 1) = 1
HALT T2_3_axis 
TILL ^MST(T2_3_axis).#MOVE,1000							! if reach left limit , stop motion
DISP"Already found the left limit!!"

!!!!!!!!!!!!!!!!!!!!multi index Structure Homing Way!!!!!!!!!!!!!!!
IF(T2_3_multi_indHm = 1)	
	JOG/V T2_3_axis,T2_3_multi_indVel							! slowing to leave the limit in negative direction
	TILL (COEREAD/4 (T2_3_EtherCATIndex,0x60FD,0)& 1) = 0	! waiting to leave the limit
	HALT T2_3_axis
	TILL ^MST(T2_3_axis).#MOVE 
	T2_3_IndVel = T2_3_multi_indVel							! define slowing velocity to find index velocity
END
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
ECOUT(ECGETOFFSET("Touch probe function",T2_3_EtherCATIndex),T2_3_TouchProbFun)
WAIT 200
T2_3_TouchProbFun = 0										!Reset Touch probe
WAIT 200
T2_3_TouchProbFun = 17										! Start Touch probe
WAIT 200
DISP"Start to find the index in positive direction......"
JOG/V T2_3_axis,T2_3_IndVel									!find the index in positive direction
TILL (COEREAD/2 (T2_3_EtherCATIndex,0x60B9,0) = 3)			!if reach index	, stop motion
HALT T2_3_axis	
TILL ^MST(T2_3_axis).#MOVE 
DISP"Already found the index!!"
SET FPOS(T2_3_axis) = (COEREAD/4 (T2_3_EtherCATIndex,0x6064,0) - COEREAD/4 (T2_3_EtherCATIndex,0x60BA,0))*T2_3_ControlUnit - T2_3_HmOffset		!set index position as zero.
WAIT 500
ECUNMAPOUT (ECGETOFFSET("Touch probe function",T2_3_EtherCATIndex))	
RET	
STOP
!------------------------------------------------------------------T2_3_HiwinDriveTouchProbeHmType2--------------------------------------------------------------------------------------
T2_3_HiwinDriveTouchProbeHmType2:

FCLEAR T2_3_axis
DISABLE T2_3_axis		
TILL ^MST(T2_3_axis).#ENABLED	
WAIT 500	
MFLAGS(T2_3_axis).#OPEN = 0						! Close loop control
ERRORMAPOFF T2_3_axis, -1							! Close all axis error compensation
MFLAGS(T2_3_axis).#GANTRY = 0	 					! turn off gantry mode (MFLAGS.25)	
FDEF(T2_3_axis).#SRL = 0	 						! disable software right limit response
FDEF(T2_3_axis).#SLL = 0	 						! disable software left limit response
FDEF(T2_3_axis).#LL = 0	 										! motor is not disable when left limit signal rising.

ENABLE	T2_3_axis	 
!!!!!!!!!!!!!!!!!!!!multi index Structure Homing Way!!!!!!!!!!!!!!!
IF(T2_3_multi_indHm = 1)	
	T2_3_IndVel = T2_3_multi_indVel					! define slowing velocity to find index velocity
END
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
ECOUT(ECGETOFFSET("Touch probe function",T2_3_EtherCATIndex),T2_3_TouchProbFun)
WAIT 200
T2_3_TouchProbFun = 0								!Reset Touch probe
WAIT 200
T2_3_TouchProbFun = 17								! Start Touch probe
WAIT 200
DISP"Start to find the index in positive direction......"
JOG/V T2_3_axis,T2_3_IndVel							!find the index in positive direction
TILL (COEREAD/2 (T2_3_EtherCATIndex,0x60B9,0) = 3)	!if reach index	, stop motion
HALT T2_3_axis	
TILL ^MST(T2_3_axis).#MOVE 
DISP"Already found the index!!"
SET FPOS(T2_3_axis) = (COEREAD/4 (T2_3_EtherCATIndex,0x6064,0) - COEREAD/4 (T2_3_EtherCATIndex,0x60BA,0))*T2_3_ControlUnit - T2_3_HmOffset	!set index position as zero.
WAIT 500
ECUNMAPOUT (ECGETOFFSET("Touch probe function",T2_3_EtherCATIndex))		
RET	
STOP
!------------------------------------------------------------------T2_3_HiwinDriveInternalHmType--------------------------------------------------------------------------------------
T2_3_HiwinDriveInternalHmType:

FCLEAR T2_3_axis
FDEF(T2_3_axis).#LL = 0	 										! motor is not disable when left limit signal rising.
FDEF(T2_3_axis).#SRL = 0	 										! disable software right limit response
FDEF(T2_3_axis).#SLL = 0	 										! disable software left limit response
T2_3_HiwinDriveHmVel = T2_3_HmVel/T2_3_ControlUnit
T2_3_HiwinDriveIndVel = T2_3_IndVel/T2_3_ControlUnit
T2_3_HiwinDriveHmOffset = T2_3_HmOffset/T2_3_ControlUnit
T2_3_HiwinDriveHmAcc = ACC(T2_3_axis)/T2_3_ControlUnit

ECIN( ECGETOFFSET("Statusword",T2_3_EtherCATIndex),T2_3_StatusWord)  
ECOUT(ECGETOFFSET("Controlword",T2_3_EtherCATIndex),T2_3_ControlWord)
IF T2_3_IsModeOfOperationInPDO = 1
	ECOUT(ECGETOFFSET("Mode of operation",T2_3_EtherCATIndex),T2_3_ModeOfOperation)
	T2_3_ModeOfOperation = 6
ELSE
	COEWRITE/1 (T2_3_EtherCATIndex,0x6060,0,6) !6 is Homing mode  
END  


COEWRITE/1 (T2_3_EtherCATIndex,0x6098,0,T2_3_InternalHmType)	
COEWRITE/4 (T2_3_EtherCATIndex,0x6099,1,T2_3_HiwinDriveHmVel) 	
COEWRITE/4 (T2_3_EtherCATIndex,0x6099,2,T2_3_HiwinDriveIndVel)	
COEWRITE/4 (T2_3_EtherCATIndex,0x609A,0,T2_3_HiwinDriveHmAcc)	
COEWRITE/4 (T2_3_EtherCATIndex,0x607C,0,T2_3_HiwinDriveHmOffset) 	

T2_3_ControlWord=6  
TILL T2_3_StatusWord.0=1  
T2_3_ControlWord=7  
TILL T2_3_StatusWord.0=1 & T2_3_StatusWord.1=1

WAIT 200 

T2_3_ControlWord=15  
TILL T2_3_StatusWord.0=1 & T2_3_StatusWord.1=1 & T2_3_StatusWord.2=1	!Enabled
!Start Homing Procedure - Bit 4  
T2_3_ControlWord=31  											!Start Home
TILL T2_3_StatusWord.12=1 & T2_3_StatusWord.10=1 | T2_3_StatusWord.13=1				!Home Finished

IF T2_3_StatusWord.13=1
	CALL HomeFail
END


T2_3_ControlWord=0  

WAIT 100

IF T2_3_IsModeOfOperationInPDO = 1
	T2_3_ModeOfOperation = 8 
	WAIT 500 
	ECUNMAPOUT (ECGETOFFSET("Mode of operation",T2_3_EtherCATIndex))
ELSE
	COEWRITE/1 (T2_3_EtherCATIndex,0x6060,0,8)						!go back to CSP mode 
END  
WAIT 500 
ECUNMAPIN (ECGETOFFSET("Statusword",T2_3_EtherCATIndex))
ECUNMAPOUT (ECGETOFFSET("Controlword",T2_3_EtherCATIndex))

WAIT 500 
DISABLE T2_3_axis
TILL ^MST(T2_3_axis).#ENABLED 

RET
STOP
!!*************************************************************************************************************************************!!
!!****************************************************** Error Compensation Process ***************************************************!!
T2_3_ErrorCompensation:
!---------- T2_3_axis Error Compensation Table ------------!
T2_3_ErrTable(0) = 0	;     
T2_3_ErrTable(1) = 0	;
T2_3_ErrTable(2) = 0	;
T2_3_ErrTable(3) = 0	;
T2_3_ErrTable(4) = 0	;
T2_3_ErrTable(5) = 0	;
T2_3_ErrTable(6) = 0	;
T2_3_ErrTable(7) = 0	;
T2_3_ErrTable(8) = 0	;
T2_3_ErrTable(9) = 0	;
T2_3_ErrTable(10) = 0	;

!-------------------------------------------------------!
T2_3_ErrTableIndex = 0
WHILE T2_3_ErrTableIndex < SIZEOF(T2_3_ErrTable)
	T2_3_ErrTable(T2_3_ErrTableIndex) = -T2_3_ErrTable(T2_3_ErrTableIndex)
	T2_3_ErrTableIndex = T2_3_ErrTableIndex + 1
END
ERRORUNMAP T2_3_axis, ZONE0
ERRORMAP1D T2_3_axis, ZONE0, T2_3_ErrCompIniPos, T2_3_ErrCompensationSpacing, T2_3_ErrTable
ERRORMAPON T2_3_axis, ZONE0

WAIT 500	
DISP "Cmpensation Procces's completed!"

RET 
STOP
!!#############################################################################################################################

ON MFLAGS(T2_3_axis).#HOME=1 & TPOS(T2_3_axis) < SLLIMIT(T2_3_axis) 
	IF( FDEF(T2_3_axis).#SLL=1 & FMASK(T2_3_axis).#SLL=1 & ^(GMTYPE(T2_3_axis)=5))
		KILL T2_3_axis,5016	!Software Left Limit
		TPOS(T2_3_axis)=FPOS(T2_3_axis)
		DISP "TPOS(T2_3_axis) < SLLIMIT(T2_3_axis)"
	END
RET

ON MFLAGS(T2_3_axis).#HOME=1 & TPOS(T2_3_axis) > SRLIMIT(T2_3_axis) 
	IF(FDEF(T2_3_axis).#SRL=1 & FMASK(T2_3_axis).#SRL=1 & ^(GMTYPE(T2_3_axis)=5))
		KILL T2_3_axis,5015	!Software Right Limit
		TPOS(T2_3_axis)=FPOS(T2_3_axis)
		DISP "TPOS(T2_3_axis) > SRLIMIT(T2_3_axis)"
	END
RET


ON MFLAGS(T2_3_axis).#HOME=0 & RVEL(T2_3_axis) > XVEL(T2_3_axis)*0.5 & ^MST(T2_3_axis).#INPOS
	IMM VEL(T2_3_axis) = XVEL(T2_3_axis)*0.45 
RET

ON MFLAGS(T2_3_axis).#HOME=0 & RVEL(T2_3_axis) < -XVEL(T2_3_axis)*0.5 & ^MST(T2_3_axis).#INPOS
	IMM VEL(T2_3_axis) = -XVEL(T2_3_axis)*0.45 
RET

AUTOEXEC:
	T2_3_IOIndex = 18
	MFLAGS(T2_3_axis).#HOME=0
STOP

ON IN(T2_3_IOIndex).0 = 1
	SAFINI(T2_3_axis).#LL = 1
RET

ON IN(T2_3_IOIndex).0 = 0
	SAFINI(T2_3_axis).#LL = 0
RET

ON IN(T2_3_IOIndex).1 = 1
	SAFINI(T2_3_axis).#RL = 1
RET

ON IN(T2_3_IOIndex).1 = 0
	SAFINI(T2_3_axis).#RL = 0
RET

!ON MST(T2_3_axis).#ENABLED & (IN(T2_3_IOIndex).24 = 1 | IN(T2_3_IOIndex).25 = 1)
!	KILL T2_3_axis
!	TILL ^MST(T2_3_axis).#MOVE,500 
!	DISABLE T2_3_axis,5028		!Safe Torque Off
!	TILL ^MST(T2_3_axis).#ENABLED
!RET	

ON IN(T2_3_IOIndex).24 = 1 | IN(T2_3_IOIndex).25 = 1
    DISP"T2_3_Event Time : %d",TIME
 	DISP"T2_3_CHECK SF1 Value : %d",IN(T2_3_IOIndex).24
	DISP"T2_3_CHECK SF2 Value : %d",IN(T2_3_IOIndex).25
	WAIT 5
	DISP"T2_3_CHECK FAULT Value : %d", SAFIN(T2_3_axis).9
	DISP"T2_3_CHECK E1 FAULT : %d",AxisErrorCode29
RET	

HomeFail:
DISP" E1 homing fail "
IF T2_3_IsModeOfOperationInPDO = 1
	T2_3_ModeOfOperation = 8 
	WAIT 500 
	ECUNMAPOUT (ECGETOFFSET("Mode of operation",T2_3_EtherCATIndex))
ELSE
	COEWRITE/1 (T2_3_EtherCATIndex,0x6060,0,8)						!go back to CSP mode 
END  
WAIT 500 
ECUNMAPIN (ECGETOFFSET("Statusword",T2_3_EtherCATIndex))
ECUNMAPOUT (ECGETOFFSET("Controlword",T2_3_EtherCATIndex))

STOP
#20
!PNAME=
!PDESC=
! T2_4_axis Single-axis_Hiwin_Drive_Homing_Process_VER1.5
!!****** Setting Parameter ******!!
LOCAL REAL T2_4_HmType,T2_4_multi_indHm,T2_4_multi_indVel
LOCAL REAL T2_4_HmVel,T2_4_IndVel,T2_4_HmOffset	
LOCAL INT T2_4_ErrCompensation,T2_4_ErrCompensationSpacing,T2_4_ErrCompIniPos
LOCAL INT ZONE0,T2_4_ErrTableIndex
LOCAL INT T2_4_HiwinDriveHome,T2_4_EtherCATIndex,T2_4_InternalHmType
LOCAL REAL T2_4_ControlUnit
LOCAL INT T2_4_IsModeOfOperationInPDO
LOCAL REAL T2_4_HiwinDriveHmVel,T2_4_HiwinDriveIndVel,T2_4_HiwinDriveHmOffset,T2_4_HiwinDriveHmAcc
!!################ Basic Settings ######################################################################################################
T2_4_IOIndex = 19                           !2023.11.30
T2_4_HmType = 1 								!the method of homing
           									!value 0 : Customized homing
           									!	   1 : find the left limit in negative direction,then find index in positive direction 
           									!      2 : find index in positive direction directly 
T2_4_HmOffset = 0 								! T2_4_HmOffset (unit)
T2_4_HmVel = 3000								! the velocity for homing 	
T2_4_IndVel = 500!1000 								! the velocity for finding index

T2_4_multi_indHm=0								! multi index structure
											! value 0 : nomal Homing
											!	    1 : find the left limit in negative direction,then slowing leave the limit in positive direction,
											!			then slowing find the left limit in negative direction,then slowing find index in positive direction
T2_4_multi_indVel = 0.1						! (Do not modify)homing velocity of multi index structure
!!*********************************** With Hiwin Drive homing support HmType 1&2************************************!!
T2_4_IsModeOfOperationInPDO = 0					! Check #ETHERCAT if include Mode of operation slect 1 else select 0
T2_4_HiwinDriveHome = 1						! 1 : With E1 internal homing ; 2 : With E1 Touch probe homing 
T2_4_EtherCATIndex = 15							! EtherCAT nod index
T2_4_ControlUnit = 360/5000							! E1 Control unit
!!**************** Configuration of 1D Error Compensation*****************************************************!!
T2_4_ErrCompensation = 0						! 0 : without compensation  ; 1 : turn on the compensation after homing completed 
T2_4_ErrCompIniPos = 0							! the initial position of error compensation
T2_4_ErrCompensationSpacing = 50				! setting the spacing for error compensation 
!!**********************************************************************************************************!!
!!######################################################################################################################################## 

!!**************************************************************************************************************************************!!
!!************************************************************ Main program ************************************************************!!
FCLEAR T2_4_axis
IF T2_4_HmType=0													! Customized homing
	CALL T2_4_HmType0	
ELSEIF T2_4_HiwinDriveHome=1										! E1 internal
	MFLAGS(T2_4_axis).#HOME=0	
	IF T2_4_HmType=1
		T2_4_InternalHmType = 1
	ELSEIF T2_4_HmType=2
		T2_4_InternalHmType = 34
	ELSE
		DISP"ERROR:The value of T2_4_HmType is invalid!!"
		STOP
	END
	CALL T2_4_HiwinDriveInternalHmType	
ELSEIF T2_4_HiwinDriveHome=2										! Touch probe
		MFLAGS(T2_4_axis).#HOME=0	
	IF T2_4_HmType=1
		CALL T2_4_HiwinDriveTouchProbeHmType1
	ELSEIF T2_4_HmType=2
		CALL T2_4_HiwinDriveTouchProbeHmType2
	ELSE
		DISP"ERROR:The value of T2_4_HmType is invalid!!"
		STOP
	END
ELSE
	DISP"ERROR:The value of T2_4_HmType or T2_4_HiwinDriveHome is invalid!!"
	STOP
END

IF T2_4_ErrCompensation = 1
	DISP "Enable the compensation mode."
	DISP "Execute the compensation prcoess......"
	CALL T2_4_ErrorCompensation	
ELSE
	DISP "Disable error compensation."
	ERRORUNMAP T2_4_axis, ZONE0
END 

IF (T2_4_HmType>=1&T2_4_HmType<=2)
	ENABLE T2_4_axis
	TILL MST(T2_4_axis).#ENABLED
	WAIT 500
	DISP"Go home......"	
	PTP/EV T2_4_axis,0,T2_4_HmVel	
	MFLAGS(T2_4_axis).#HOME=1
END	
FDEF(T2_4_axis).#LL = 1	 		
FDEF(T2_4_axis).#SRL = 1	 		
FDEF(T2_4_axis).#SLL = 1	 
DISP"Homing successful!!"	

STOP	

!!*************************************************************************************************************************************!!
!!************************************************************ Homing process	*******************************************************!!
T2_4_HmType0:
!Customized
RET
STOP
!------------------------------------------------------------------T2_4_HiwinDriveTouchProbeHmType1--------------------------------------------------------------------------------------
T2_4_HiwinDriveTouchProbeHmType1:

FCLEAR T2_4_axis
DISABLE T2_4_axis		
TILL ^MST(T2_4_axis).#ENABLED	
WAIT 500	
MFLAGS(T2_4_axis).#OPEN = 0								! Close loop control
ERRORMAPOFF T2_4_axis, -1									! Close all axis error compensation
MFLAGS(T2_4_axis).#GANTRY = 0								! turn off gantry mode (MFLAGS.25)	
FDEF(T2_4_axis).#SRL = 0	 								! disable software right limit response
FDEF(T2_4_axis).#SLL = 0	 								! disable software left limit response
FDEF(T2_4_axis).#LL = 0	 										! motor is not disable when left limit signal rising.

ENABLE	T2_4_axis	 
TILL MST(T2_4_axis).#ENABLED	 
WAIT 500	
DISP"Start to find the left limit......"
JOG/V T2_4_axis,-T2_4_HmVel									! find the left limit in negative direction
TILL (COEREAD/4 (T2_4_EtherCATIndex,0x60FD,0)& 1) = 1
HALT T2_4_axis 
TILL ^MST(T2_4_axis).#MOVE,1000							! if reach left limit , stop motion
DISP"Already found the left limit!!"

!!!!!!!!!!!!!!!!!!!!multi index Structure Homing Way!!!!!!!!!!!!!!!
IF(T2_4_multi_indHm = 1)	
	JOG/V T2_4_axis,T2_4_multi_indVel							! slowing to leave the limit in negative direction
	TILL (COEREAD/4 (T2_4_EtherCATIndex,0x60FD,0)& 1) = 0	! waiting to leave the limit
	HALT T2_4_axis
	TILL ^MST(T2_4_axis).#MOVE 
	T2_4_IndVel = T2_4_multi_indVel							! define slowing velocity to find index velocity
END
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
ECOUT(ECGETOFFSET("Touch probe function",T2_4_EtherCATIndex),T2_4_TouchProbFun)
WAIT 200
T2_4_TouchProbFun = 0										!Reset Touch probe
WAIT 200
T2_4_TouchProbFun = 17										! Start Touch probe
WAIT 200
DISP"Start to find the index in positive direction......"
JOG/V T2_4_axis,T2_4_IndVel									!find the index in positive direction
TILL (COEREAD/2 (T2_4_EtherCATIndex,0x60B9,0) = 3)			!if reach index	, stop motion
HALT T2_4_axis	
TILL ^MST(T2_4_axis).#MOVE 
DISP"Already found the index!!"
SET FPOS(T2_4_axis) = (COEREAD/4 (T2_4_EtherCATIndex,0x6064,0) - COEREAD/4 (T2_4_EtherCATIndex,0x60BA,0))*T2_4_ControlUnit - T2_4_HmOffset		!set index position as zero.
WAIT 500
ECUNMAPOUT (ECGETOFFSET("Touch probe function",T2_4_EtherCATIndex))	
RET	
STOP
!------------------------------------------------------------------T2_4_HiwinDriveTouchProbeHmType2--------------------------------------------------------------------------------------
T2_4_HiwinDriveTouchProbeHmType2:

FCLEAR T2_4_axis
DISABLE T2_4_axis		
TILL ^MST(T2_4_axis).#ENABLED	
WAIT 500	
MFLAGS(T2_4_axis).#OPEN = 0						! Close loop control
ERRORMAPOFF T2_4_axis, -1							! Close all axis error compensation
MFLAGS(T2_4_axis).#GANTRY = 0	 					! turn off gantry mode (MFLAGS.25)	
FDEF(T2_4_axis).#SRL = 0	 						! disable software right limit response
FDEF(T2_4_axis).#SLL = 0	 						! disable software left limit response
FDEF(T2_4_axis).#LL = 0	 										! motor is not disable when left limit signal rising.

ENABLE	T2_4_axis	 
!!!!!!!!!!!!!!!!!!!!multi index Structure Homing Way!!!!!!!!!!!!!!!
IF(T2_4_multi_indHm = 1)	
	T2_4_IndVel = T2_4_multi_indVel					! define slowing velocity to find index velocity
END
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
ECOUT(ECGETOFFSET("Touch probe function",T2_4_EtherCATIndex),T2_4_TouchProbFun)
WAIT 200
T2_4_TouchProbFun = 0								!Reset Touch probe
WAIT 200
T2_4_TouchProbFun = 17								! Start Touch probe
WAIT 200
DISP"Start to find the index in positive direction......"
JOG/V T2_4_axis,T2_4_IndVel							!find the index in positive direction
TILL (COEREAD/2 (T2_4_EtherCATIndex,0x60B9,0) = 3)	!if reach index	, stop motion
HALT T2_4_axis	
TILL ^MST(T2_4_axis).#MOVE 
DISP"Already found the index!!"
SET FPOS(T2_4_axis) = (COEREAD/4 (T2_4_EtherCATIndex,0x6064,0) - COEREAD/4 (T2_4_EtherCATIndex,0x60BA,0))*T2_4_ControlUnit - T2_4_HmOffset	!set index position as zero.
WAIT 500
ECUNMAPOUT (ECGETOFFSET("Touch probe function",T2_4_EtherCATIndex))		
RET	
STOP
!------------------------------------------------------------------T2_4_HiwinDriveInternalHmType--------------------------------------------------------------------------------------
T2_4_HiwinDriveInternalHmType:

FCLEAR T2_4_axis
FDEF(T2_4_axis).#LL = 0	 										! motor is not disable when left limit signal rising.
FDEF(T2_4_axis).#SRL = 0	 										! disable software right limit response
FDEF(T2_4_axis).#SLL = 0	 										! disable software left limit response
T2_4_HiwinDriveHmVel = T2_4_HmVel/T2_4_ControlUnit
T2_4_HiwinDriveIndVel = T2_4_IndVel/T2_4_ControlUnit
T2_4_HiwinDriveHmOffset = T2_4_HmOffset/T2_4_ControlUnit
T2_4_HiwinDriveHmAcc = ACC(T2_4_axis)/T2_4_ControlUnit

ECIN( ECGETOFFSET("Statusword",T2_4_EtherCATIndex),T2_4_StatusWord)  
ECOUT(ECGETOFFSET("Controlword",T2_4_EtherCATIndex),T2_4_ControlWord)
IF T2_4_IsModeOfOperationInPDO = 1
	ECOUT(ECGETOFFSET("Mode of operation",T2_4_EtherCATIndex),T2_4_ModeOfOperation)
	T2_4_ModeOfOperation = 6
ELSE
	COEWRITE/1 (T2_4_EtherCATIndex,0x6060,0,6) !6 is Homing mode  
END  


COEWRITE/1 (T2_4_EtherCATIndex,0x6098,0,T2_4_InternalHmType)	
COEWRITE/4 (T2_4_EtherCATIndex,0x6099,1,T2_4_HiwinDriveHmVel) 	
COEWRITE/4 (T2_4_EtherCATIndex,0x6099,2,T2_4_HiwinDriveIndVel)	
COEWRITE/4 (T2_4_EtherCATIndex,0x609A,0,T2_4_HiwinDriveHmAcc)	
COEWRITE/4 (T2_4_EtherCATIndex,0x607C,0,T2_4_HiwinDriveHmOffset) 	

T2_4_ControlWord=6  
TILL T2_4_StatusWord.0=1  
T2_4_ControlWord=7  
TILL T2_4_StatusWord.0=1 & T2_4_StatusWord.1=1

WAIT 200 

T2_4_ControlWord=15  
TILL T2_4_StatusWord.0=1 & T2_4_StatusWord.1=1 & T2_4_StatusWord.2=1	!Enabled
!Start Homing Procedure - Bit 4  
T2_4_ControlWord=31  											!Start Home
TILL T2_4_StatusWord.12=1 & T2_4_StatusWord.10=1 | T2_4_StatusWord.13=1				!Home Finished

IF T2_4_StatusWord.13=1
	CALL HomeFail
END


T2_4_ControlWord=0  

WAIT 100

IF T2_4_IsModeOfOperationInPDO = 1
	T2_4_ModeOfOperation = 8 
	WAIT 500 
	ECUNMAPOUT (ECGETOFFSET("Mode of operation",T2_4_EtherCATIndex))
ELSE
	COEWRITE/1 (T2_4_EtherCATIndex,0x6060,0,8)						!go back to CSP mode 
END  
WAIT 500 
ECUNMAPIN (ECGETOFFSET("Statusword",T2_4_EtherCATIndex))
ECUNMAPOUT (ECGETOFFSET("Controlword",T2_4_EtherCATIndex))

WAIT 500 
DISABLE T2_4_axis
TILL ^MST(T2_4_axis).#ENABLED 

RET
STOP
!!*************************************************************************************************************************************!!
!!****************************************************** Error Compensation Process ***************************************************!!
T2_4_ErrorCompensation:
!---------- T2_4_axis Error Compensation Table ------------!
T2_4_ErrTable(0) = 0	;     
T2_4_ErrTable(1) = 0	;
T2_4_ErrTable(2) = 0	;
T2_4_ErrTable(3) = 0	;
T2_4_ErrTable(4) = 0	;
T2_4_ErrTable(5) = 0	;
T2_4_ErrTable(6) = 0	;
T2_4_ErrTable(7) = 0	;
T2_4_ErrTable(8) = 0	;
T2_4_ErrTable(9) = 0	;
T2_4_ErrTable(10) = 0	;

!-------------------------------------------------------!
T2_4_ErrTableIndex = 0
WHILE T2_4_ErrTableIndex < SIZEOF(T2_4_ErrTable)
	T2_4_ErrTable(T2_4_ErrTableIndex) = -T2_4_ErrTable(T2_4_ErrTableIndex)
	T2_4_ErrTableIndex = T2_4_ErrTableIndex + 1
END
ERRORUNMAP T2_4_axis, ZONE0
ERRORMAP1D T2_4_axis, ZONE0, T2_4_ErrCompIniPos, T2_4_ErrCompensationSpacing, T2_4_ErrTable
ERRORMAPON T2_4_axis, ZONE0

WAIT 500	
DISP "Cmpensation Procces's completed!"

RET 
STOP
!!#############################################################################################################################

ON MFLAGS(T2_4_axis).#HOME=1 & TPOS(T2_4_axis) < SLLIMIT(T2_4_axis) 
	IF( FDEF(T2_4_axis).#SLL=1 & FMASK(T2_4_axis).#SLL=1 & ^(GMTYPE(T2_4_axis)=5))
		KILL T2_4_axis,5016	!Software Left Limit
		TPOS(T2_4_axis)=FPOS(T2_4_axis)
		DISP "TPOS(T2_4_axis) < SLLIMIT(T2_4_axis)"
	END
RET

ON MFLAGS(T2_4_axis).#HOME=1 & TPOS(T2_4_axis) > SRLIMIT(T2_4_axis) 
	IF(FDEF(T2_4_axis).#SRL=1 & FMASK(T2_4_axis).#SRL=1 & ^(GMTYPE(T2_4_axis)=5))
		KILL T2_4_axis,5015	!Software Right Limit
		TPOS(T2_4_axis)=FPOS(T2_4_axis)
		DISP "TPOS(T2_4_axis) > SRLIMIT(T2_4_axis)"
	END
RET


ON MFLAGS(T2_4_axis).#HOME=0 & RVEL(T2_4_axis) > XVEL(T2_4_axis)*0.5 & ^MST(T2_4_axis).#INPOS
	IMM VEL(T2_4_axis) = XVEL(T2_4_axis)*0.45 
RET

ON MFLAGS(T2_4_axis).#HOME=0 & RVEL(T2_4_axis) < -XVEL(T2_4_axis)*0.5 & ^MST(T2_4_axis).#INPOS
	IMM VEL(T2_4_axis) = -XVEL(T2_4_axis)*0.45 
RET

AUTOEXEC:
	T2_4_IOIndex = 19
	MFLAGS(T2_4_axis).#HOME=0
STOP

ON IN(T2_4_IOIndex).0 = 1
	SAFINI(T2_4_axis).#LL = 1
RET

ON IN(T2_4_IOIndex).0 = 0
	SAFINI(T2_4_axis).#LL = 0
RET

ON IN(T2_4_IOIndex).1 = 1
	SAFINI(T2_4_axis).#RL = 1
RET

ON IN(T2_4_IOIndex).1 = 0
	SAFINI(T2_4_axis).#RL = 0
RET

!ON MST(T2_4_axis).#ENABLED & (IN(T2_4_IOIndex).24 = 1 | IN(T2_4_IOIndex).25 = 1)
!	KILL T2_4_axis
!	TILL ^MST(T2_4_axis).#MOVE,500 
!	DISABLE T2_4_axis,5028		!Safe Torque Off
!	TILL ^MST(T2_4_axis).#ENABLED
!RET	

ON IN(T2_4_IOIndex).24 = 1 | IN(T2_4_IOIndex).25 = 1
    DISP"T2_4_Event Time : %d",TIME
 	DISP"T2_4_CHECK SF1 Value : %d",IN(T2_4_IOIndex).24
	DISP"T2_4_CHECK SF2 Value : %d",IN(T2_4_IOIndex).25
	WAIT 5
	DISP"T2_4_CHECK FAULT Value : %d", SAFIN(T2_4_axis).9
	DISP"T2_4_CHECK E1 FAULT : %d",AxisErrorCode30
RET	

HomeFail:
DISP" E1 homing fail "
IF T2_4_IsModeOfOperationInPDO = 1
	T2_4_ModeOfOperation = 8 
	WAIT 500 
	ECUNMAPOUT (ECGETOFFSET("Mode of operation",T2_4_EtherCATIndex))
ELSE
	COEWRITE/1 (T2_4_EtherCATIndex,0x6060,0,8)						!go back to CSP mode 
END  
WAIT 500 
ECUNMAPIN (ECGETOFFSET("Statusword",T2_4_EtherCATIndex))
ECUNMAPOUT (ECGETOFFSET("Controlword",T2_4_EtherCATIndex))

STOP
#21
!PNAME=
!PDESC=
! Y3_1_axis Single-axis_Hiwin_Drive_Homing_Process_VER1.5
!!****** Setting Parameter ******!!
LOCAL REAL Y3_1_HmType,Y3_1_multi_indHm,Y3_1_multi_indVel
LOCAL REAL Y3_1_HmVel,Y3_1_IndVel,Y3_1_HmOffset	
LOCAL INT Y3_1_ErrCompensation,Y3_1_ErrCompensationSpacing,Y3_1_ErrCompIniPos
LOCAL INT ZONE0,Y3_1_ErrTableIndex
LOCAL INT Y3_1_HiwinDriveHome,Y3_1_EtherCATIndex,Y3_1_InternalHmType
LOCAL REAL Y3_1_ControlUnit
LOCAL INT Y3_1_IsModeOfOperationInPDO
LOCAL REAL Y3_1_HiwinDriveHmVel,Y3_1_HiwinDriveIndVel,Y3_1_HiwinDriveHmOffset,Y3_1_HiwinDriveHmAcc
!!################ Basic Settings ######################################################################################################
Y3_1_IOIndex = 20
Y3_1_HmType = 0 								!the method of homing
           									!value 0 : Customized homing
           									!	   1 : find the left limit in negative direction,then find index in positive direction 
           									!      2 : find index in positive direction directly 
Y3_1_HmOffset = 0 								! Y3_1_HmOffset (unit)
Y3_1_HmVel = 15000! 30000								! the velocity for homing 	
Y3_1_IndVel = 5000 !10000 								! the velocity for finding index

Y3_1_multi_indHm=0								! multi index structure
											! value 0 : nomal Homing
											!	    1 : find the left limit in negative direction,then slowing leave the limit in positive direction,
											!			then slowing find the left limit in negative direction,then slowing find index in positive direction
Y3_1_multi_indVel = 100						! (Do not modify)homing velocity of multi index structure
!!*********************************** With Hiwin Drive homing support HmType 1&2************************************!!
Y3_1_IsModeOfOperationInPDO = 0					! Check #ETHERCAT if include Mode of operation slect 1 else select 0
Y3_1_HiwinDriveHome = 1						! 1 : With E1 internal homing ; 2 : With E1 Touch probe homing 
Y3_1_EtherCATIndex = 18							! EtherCAT nod index
Y3_1_ControlUnit = 1/10							! E1 Control unit
!!**************** Configuration of 1D Error Compensation*****************************************************!!
Y3_1_ErrCompensation = 1						! 0 : without compensation  ; 1 : turn on the compensation after homing completed 
Y3_1_ErrCompIniPos = -1500000							! the initial position of error compensation
Y3_1_ErrCompensationSpacing = 75000				! setting the spacing for error compensation 
!!**********************************************************************************************************!!
!!######################################################################################################################################## 

!!**************************************************************************************************************************************!!
!!************************************************************ Main program ************************************************************!!
FCLEAR Y3_1_axis

IF Y3_1_HiwinDriveHome=1										! E1 internal
	MFLAGS(Y3_1_axis).#HOME=0
	IF Y3_1_HmType=0
		Y3_1_InternalHmType = 2	
	ELSEIF Y3_1_HmType=1
		Y3_1_InternalHmType = 1
	ELSEIF Y3_1_HmType=2
		Y3_1_InternalHmType = 34
	ELSE
		DISP"ERROR:The value of Y3_1_HmType is invalid!!"
		STOP
	END
	CALL Y3_1_HiwinDriveInternalHmType	
ELSEIF Y3_1_HiwinDriveHome=2										! Touch probe
		MFLAGS(Y3_1_axis).#HOME=0	
	IF Y3_1_HmType=1
		CALL Y3_1_HiwinDriveTouchProbeHmType1
	ELSEIF Y3_1_HmType=2
		CALL Y3_1_HiwinDriveTouchProbeHmType2
	ELSE
		DISP"ERROR:The value of Y3_1_HmType is invalid!!"
		STOP
	END
ELSE
	DISP"ERROR:The value of Y3_1_HmType or Y3_1_HiwinDriveHome is invalid!!"
	STOP
END

IF Y3_1_ErrCompensation = 1
	DISP "Enable the compensation mode."
	DISP "Execute the compensation prcoess......"
	CALL Y3_1_ErrorCompensation	
ELSE
	DISP "Disable error compensation."
	ERRORUNMAP Y3_1_axis, ZONE0
END 

IF (Y3_1_HmType>=1&Y3_1_HmType<=2|Y3_1_HmType=0)
	ENABLE Y3_1_axis
	TILL MST(Y3_1_axis).#ENABLED
	WAIT 500
	DISP"Go home......"	
	PTP/EV Y3_1_axis,0,Y3_1_HmVel	
	MFLAGS(Y3_1_axis).#HOME=1
END	
FDEF(Y3_1_axis).#RL = 1	
FDEF(Y3_1_axis).#LL = 1	 		
FDEF(Y3_1_axis).#SRL = 1	 		
FDEF(Y3_1_axis).#SLL = 1	 
DISP"Homing successful!!"	

STOP	

!!*************************************************************************************************************************************!!
!!************************************************************ Homing process	*******************************************************!!
Y3_1_HmType0:
!Customized
RET
STOP
!------------------------------------------------------------------Y3_1_HiwinDriveTouchProbeHmType1--------------------------------------------------------------------------------------
Y3_1_HiwinDriveTouchProbeHmType1:

FCLEAR Y3_1_axis
DISABLE Y3_1_axis		
TILL ^MST(Y3_1_axis).#ENABLED	
WAIT 500	
MFLAGS(Y3_1_axis).#OPEN = 0								! Close loop control
ERRORMAPOFF Y3_1_axis, -1									! Close all axis error compensation
MFLAGS(Y3_1_axis).#GANTRY = 0								! turn off gantry mode (MFLAGS.25)	
FDEF(Y3_1_axis).#SRL = 0	 								! disable software right limit response
FDEF(Y3_1_axis).#SLL = 0	 								! disable software left limit response
FDEF(Y3_1_axis).#LL = 0	 										! motor is not disable when left limit signal rising.

ENABLE	Y3_1_axis	 
TILL MST(Y3_1_axis).#ENABLED	 
WAIT 500	
DISP"Start to find the left limit......"
JOG/V Y3_1_axis,-Y3_1_HmVel									! find the left limit in negative direction
TILL (COEREAD/4 (Y3_1_EtherCATIndex,0x60FD,0)& 1) = 1
HALT Y3_1_axis 
TILL ^MST(Y3_1_axis).#MOVE,1000							! if reach left limit , stop motion
DISP"Already found the left limit!!"

!!!!!!!!!!!!!!!!!!!!multi index Structure Homing Way!!!!!!!!!!!!!!!
IF(Y3_1_multi_indHm = 1)	
	JOG/V Y3_1_axis,Y3_1_multi_indVel							! slowing to leave the limit in negative direction
	TILL (COEREAD/4 (Y3_1_EtherCATIndex,0x60FD,0)& 1) = 0	! waiting to leave the limit
	HALT Y3_1_axis
	TILL ^MST(Y3_1_axis).#MOVE 
	Y3_1_IndVel = Y3_1_multi_indVel							! define slowing velocity to find index velocity
END
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
ECOUT(ECGETOFFSET("Touch probe function",Y3_1_EtherCATIndex),Y3_1_TouchProbFun)
WAIT 200
Y3_1_TouchProbFun = 0										!Reset Touch probe
WAIT 200
Y3_1_TouchProbFun = 17										! Start Touch probe
WAIT 200
DISP"Start to find the index in positive direction......"
JOG/V Y3_1_axis,Y3_1_IndVel									!find the index in positive direction
TILL (COEREAD/2 (Y3_1_EtherCATIndex,0x60B9,0) = 3)			!if reach index	, stop motion
HALT Y3_1_axis	
TILL ^MST(Y3_1_axis).#MOVE 
DISP"Already found the index!!"
SET FPOS(Y3_1_axis) = (COEREAD/4 (Y3_1_EtherCATIndex,0x6064,0) - COEREAD/4 (Y3_1_EtherCATIndex,0x60BA,0))*Y3_1_ControlUnit - Y3_1_HmOffset		!set index position as zero.
WAIT 500
ECUNMAPOUT (ECGETOFFSET("Touch probe function",Y3_1_EtherCATIndex))	
RET	
STOP
!------------------------------------------------------------------Y3_1_HiwinDriveTouchProbeHmType2--------------------------------------------------------------------------------------
Y3_1_HiwinDriveTouchProbeHmType2:

FCLEAR Y3_1_axis
DISABLE Y3_1_axis		
TILL ^MST(Y3_1_axis).#ENABLED	
WAIT 500	
MFLAGS(Y3_1_axis).#OPEN = 0						! Close loop control
ERRORMAPOFF Y3_1_axis, -1							! Close all axis error compensation
MFLAGS(Y3_1_axis).#GANTRY = 0	 					! turn off gantry mode (MFLAGS.25)	
FDEF(Y3_1_axis).#SRL = 0	 						! disable software right limit response
FDEF(Y3_1_axis).#SLL = 0	 						! disable software left limit response
FDEF(Y3_1_axis).#LL = 0	 										! motor is not disable when left limit signal rising.

ENABLE	Y3_1_axis	 
!!!!!!!!!!!!!!!!!!!!multi index Structure Homing Way!!!!!!!!!!!!!!!
IF(Y3_1_multi_indHm = 1)	
	Y3_1_IndVel = Y3_1_multi_indVel					! define slowing velocity to find index velocity
END
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
ECOUT(ECGETOFFSET("Touch probe function",Y3_1_EtherCATIndex),Y3_1_TouchProbFun)
WAIT 200
Y3_1_TouchProbFun = 0								!Reset Touch probe
WAIT 200
Y3_1_TouchProbFun = 17								! Start Touch probe
WAIT 200
DISP"Start to find the index in positive direction......"
JOG/V Y3_1_axis,Y3_1_IndVel							!find the index in positive direction
TILL (COEREAD/2 (Y3_1_EtherCATIndex,0x60B9,0) = 3)	!if reach index	, stop motion
HALT Y3_1_axis	
TILL ^MST(Y3_1_axis).#MOVE 
DISP"Already found the index!!"
SET FPOS(Y3_1_axis) = (COEREAD/4 (Y3_1_EtherCATIndex,0x6064,0) - COEREAD/4 (Y3_1_EtherCATIndex,0x60BA,0))*Y3_1_ControlUnit - Y3_1_HmOffset	!set index position as zero.
WAIT 500
ECUNMAPOUT (ECGETOFFSET("Touch probe function",Y3_1_EtherCATIndex))		
RET	
STOP
!------------------------------------------------------------------Y3_1_HiwinDriveInternalHmType--------------------------------------------------------------------------------------
Y3_1_HiwinDriveInternalHmType:

FCLEAR Y3_1_axis
FDEF(Y3_1_axis).#RL = 0	 										! motor is not disable when right limit signal rising.
FDEF(Y3_1_axis).#LL = 0	 										! motor is not disable when left limit signal rising.
FDEF(Y3_1_axis).#SRL = 0	 										! disable software right limit response
FDEF(Y3_1_axis).#SLL = 0	 										! disable software left limit response
Y3_1_HiwinDriveHmVel = Y3_1_HmVel/Y3_1_ControlUnit
Y3_1_HiwinDriveIndVel = Y3_1_IndVel/Y3_1_ControlUnit
Y3_1_HiwinDriveHmOffset = Y3_1_HmOffset/Y3_1_ControlUnit
Y3_1_HiwinDriveHmAcc = ACC(Y3_1_axis)/Y3_1_ControlUnit

ECIN( ECGETOFFSET("Statusword",Y3_1_EtherCATIndex),Y3_1_StatusWord)  
ECOUT(ECGETOFFSET("Controlword",Y3_1_EtherCATIndex),Y3_1_ControlWord)
IF Y3_1_IsModeOfOperationInPDO = 1
	ECOUT(ECGETOFFSET("Mode of operation",Y3_1_EtherCATIndex),Y3_1_ModeOfOperation)
	Y3_1_ModeOfOperation = 6
ELSE
	COEWRITE/1 (Y3_1_EtherCATIndex,0x6060,0,6) !6 is Homing mode  
END  


COEWRITE/1 (Y3_1_EtherCATIndex,0x6098,0,Y3_1_InternalHmType)	!2 :home move positive limit switch <--- index
COEWRITE/4 (Y3_1_EtherCATIndex,0x6099,1,Y3_1_HiwinDriveHmVel) 	
COEWRITE/4 (Y3_1_EtherCATIndex,0x6099,2,Y3_1_HiwinDriveIndVel)	
COEWRITE/4 (Y3_1_EtherCATIndex,0x609A,0,Y3_1_HiwinDriveHmAcc)	
COEWRITE/4 (Y3_1_EtherCATIndex,0x607C,0,Y3_1_HiwinDriveHmOffset) 	

Y3_1_ControlWord=6         !home
TILL Y3_1_StatusWord.0=1   !Ready to Switch on 
Y3_1_ControlWord=7         !Switch on
TILL Y3_1_StatusWord.0=1 & Y3_1_StatusWord.1=1

WAIT 200 

Y3_1_ControlWord=15  
TILL Y3_1_StatusWord.0=1 & Y3_1_StatusWord.1=1 & Y3_1_StatusWord.2=1	!Enabled
!Start Homing Procedure - Bit 4  
Y3_1_ControlWord=31  											!Start Home
TILL Y3_1_StatusWord.12=1 & Y3_1_StatusWord.10=1 | Y3_1_StatusWord.13=1				!Home Finished
Disp "Y3_1 Home Finish-1"
!###########################################################################################################
!------------------------------------------------------------------------------------------------------------
IF Y3_1_StatusWord.13=1
	CALL HomeFail
	
ELSE

		Y3_1_HmVel =Y3_1_HmVel/6
		Y3_1_IndVel=Y3_1_IndVel/8
		Y3_1_HiwinDriveHmVel = Y3_1_HmVel/Y3_1_ControlUnit
		Y3_1_HiwinDriveIndVel = Y3_1_IndVel/Y3_1_ControlUnit
		
		IF Y3_1_IsModeOfOperationInPDO = 1
			ECOUT(ECGETOFFSET("Mode of operation",Y3_1_EtherCATIndex),Y3_1_ModeOfOperation)
			Y3_1_ModeOfOperation = 6
		ELSE
			COEWRITE/1 (Y3_1_EtherCATIndex,0x6060,0,6) !6 is Homing mode  
		END  

		
		COEWRITE/1 (Y3_1_EtherCATIndex,0x6098,0,Y3_1_InternalHmType)	!2 :home move positive limit switch <--- index
		COEWRITE/4 (Y3_1_EtherCATIndex,0x6099,1,Y3_1_HiwinDriveHmVel) 	
		COEWRITE/4 (Y3_1_EtherCATIndex,0x6099,2,Y3_1_HiwinDriveIndVel)	
		COEWRITE/4 (Y3_1_EtherCATIndex,0x609A,0,Y3_1_HiwinDriveHmAcc)	
		COEWRITE/4 (Y3_1_EtherCATIndex,0x607C,0,Y3_1_HiwinDriveHmOffset) 	
		
		Y3_1_ControlWord=6         !home
		TILL Y3_1_StatusWord.0=1   !Ready to Switch on 
		Y3_1_ControlWord=7         !Switch on
		TILL Y3_1_StatusWord.0=1 & Y3_1_StatusWord.1=1
		
		WAIT 200 
		
		Y3_1_ControlWord=15  
		TILL Y3_1_StatusWord.0=1 & Y3_1_StatusWord.1=1 & Y3_1_StatusWord.2=1	!Enabled
		!Start Homing Procedure - Bit 4  
		Y3_1_ControlWord=31  											!Start Home
		TILL Y3_1_StatusWord.12=1 & Y3_1_StatusWord.10=1 | Y3_1_StatusWord.13=1				!Home Finished
		Disp "Y3_1 Home Finish-2"
END
!#############################################################################################################
IF Y3_1_StatusWord.13=1
	CALL HomeFail
END

Y3_1_ControlWord=0  

WAIT 100

IF Y3_1_IsModeOfOperationInPDO = 1
	Y3_1_ModeOfOperation = 8 
	WAIT 500 
	ECUNMAPOUT (ECGETOFFSET("Mode of operation",Y3_1_EtherCATIndex))
ELSE
	COEWRITE/1 (Y3_1_EtherCATIndex,0x6060,0,8)						!go back to CSP mode 
END  
WAIT 500 
ECUNMAPIN (ECGETOFFSET("Statusword",Y3_1_EtherCATIndex))
ECUNMAPOUT (ECGETOFFSET("Controlword",Y3_1_EtherCATIndex))

WAIT 500 
SET FPOS(Y3_1_axis)=0
WAIT 500 
DISABLE Y3_1_axis
TILL ^MST(Y3_1_axis).#ENABLED 

RET
STOP
!!*************************************************************************************************************************************!!
!!****************************************************** Error Compensation Process ***************************************************!!
Y3_1_ErrorCompensation:
!---------- Y3_1_axis Error Compensation Table ------------!
Y3_1_ErrTable(0)=	0	;
Y3_1_ErrTable(1)=	-0.1	;
Y3_1_ErrTable(2)=	4.8	;
Y3_1_ErrTable(3)=	5.1	;
Y3_1_ErrTable(4)=	8.9	;
Y3_1_ErrTable(5)=	19.6	;
Y3_1_ErrTable(6)=	21.9	;
Y3_1_ErrTable(7)=	25.2	;
Y3_1_ErrTable(8)=	24	;
Y3_1_ErrTable(9)=	29.6	;
Y3_1_ErrTable(10)=	35.6	;
Y3_1_ErrTable(11)=	33	;
Y3_1_ErrTable(12)=	34.6	;
Y3_1_ErrTable(13)=	45.4	;
Y3_1_ErrTable(14)=	45.2	;
Y3_1_ErrTable(15)=	46.2	;
Y3_1_ErrTable(16)=	43.2	;
Y3_1_ErrTable(17)=	51.4	;
Y3_1_ErrTable(18)=	56.7	;
Y3_1_ErrTable(19)=	63.3	;
Y3_1_ErrTable(20)=	59.8	;
!Y3_1_ErrTable(0)=	106.6	;
!Y3_1_ErrTable(1)=	104.8	;
!Y3_1_ErrTable(2)=	96.9	;
!Y3_1_ErrTable(3)=	94.2	;
!Y3_1_ErrTable(4)=	88.6	;
!Y3_1_ErrTable(5)=	75.1	;
!Y3_1_ErrTable(6)=	69.8	;
!Y3_1_ErrTable(7)=	65.4	;
!Y3_1_ErrTable(8)=	64.2	;
!Y3_1_ErrTable(9)=	56.5	;
!Y3_1_ErrTable(10)=	47.3	;
!Y3_1_ErrTable(11)=	47.4	;
!Y3_1_ErrTable(12)=	44.5	;
!Y3_1_ErrTable(13)=	30.8	;
!Y3_1_ErrTable(14)=	28.9	;
!Y3_1_ErrTable(15)=	25.8	;
!Y3_1_ErrTable(16)=	26.2	;
!Y3_1_ErrTable(17)=	15.4	;
!Y3_1_ErrTable(18)=	7.1	;
!Y3_1_ErrTable(19)=	-0.9	;
!Y3_1_ErrTable(20)=	0	;



!-------------------------------------------------------!
Y3_1_ErrTableIndex = 0
WHILE Y3_1_ErrTableIndex < SIZEOF(Y3_1_ErrTable)
	Y3_1_ErrTable(Y3_1_ErrTableIndex) = -Y3_1_ErrTable(Y3_1_ErrTableIndex)
	Y3_1_ErrTableIndex = Y3_1_ErrTableIndex + 1
END
ERRORUNMAP Y3_1_axis, ZONE0
ERRORMAP1D Y3_1_axis, ZONE0, Y3_1_ErrCompIniPos, Y3_1_ErrCompensationSpacing, Y3_1_ErrTable
ERRORMAPON Y3_1_axis, ZONE0

WAIT 500	
DISP "Cmpensation Procces's completed!"

RET 
STOP
!!#############################################################################################################################

ON MFLAGS(Y3_1_axis).#HOME=1 & TPOS(Y3_1_axis) < SLLIMIT(Y3_1_axis) 
	IF( FDEF(Y3_1_axis).#SLL=1 & FMASK(Y3_1_axis).#SLL=1 & ^(GMTYPE(Y3_1_axis)=5))
		KILL Y3_1_axis,5016	!Software Left Limit
		TPOS(Y3_1_axis)=FPOS(Y3_1_axis)
		DISP "TPOS(Y3_1_axis) < SLLIMIT(Y3_1_axis)"
	END
RET

ON MFLAGS(Y3_1_axis).#HOME=1 & TPOS(Y3_1_axis) > SRLIMIT(Y3_1_axis) 
	IF(FDEF(Y3_1_axis).#SRL=1 & FMASK(Y3_1_axis).#SRL=1 & ^(GMTYPE(Y3_1_axis)=5))
		KILL Y3_1_axis,5015	!Software Right Limit
		TPOS(Y3_1_axis)=FPOS(Y3_1_axis)
		DISP "TPOS(Y3_1_axis) > SRLIMIT(Y3_1_axis)"
	END
RET


ON MFLAGS(Y3_1_axis).#HOME=0 & RVEL(Y3_1_axis) > XVEL(Y3_1_axis)*0.5 & ^MST(Y3_1_axis).#INPOS
	IMM VEL(Y3_1_axis) = XVEL(Y3_1_axis)*0.45 
RET

ON MFLAGS(Y3_1_axis).#HOME=0 & RVEL(Y3_1_axis) < -XVEL(Y3_1_axis)*0.5 & ^MST(Y3_1_axis).#INPOS
	IMM VEL(Y3_1_axis) = -XVEL(Y3_1_axis)*0.45 
RET

AUTOEXEC:
	Y3_1_IOIndex = 20
	MFLAGS(Y3_1_axis).#HOME=0
STOP

ON IN(Y3_1_IOIndex).0 = 1
	SAFINI(Y3_1_axis).#LL = 1
RET

ON IN(Y3_1_IOIndex).0 = 0
	SAFINI(Y3_1_axis).#LL = 0
RET

ON IN(Y3_1_IOIndex).1 = 1
	SAFINI(Y3_1_axis).#RL = 1
RET

ON IN(Y3_1_IOIndex).1 = 0
	SAFINI(Y3_1_axis).#RL = 0
RET

!ON MST(Y3_1_axis).#ENABLED & (IN(Y3_1_IOIndex).24 = 1 | IN(Y3_1_IOIndex).25 = 1)
!	KILL Y3_1_axis
!	TILL ^MST(Y3_1_axis).#MOVE,500 
!	DISABLE Y3_1_axis,5028		!Safe Torque Off
!	TILL ^MST(Y3_1_axis).#ENABLED
!RET	

ON IN(Y3_1_IOIndex).24 = 1 | IN(Y3_1_IOIndex).25 = 1
    DISP"Y3_1_Event Time : %d",TIME
 	DISP"Y3_1_CHECK SF1 Value : %d",IN(Y3_1_IOIndex).24
	DISP"Y3_1_CHECK SF2 Value : %d",IN(Y3_1_IOIndex).25
	WAIT 5
	DISP"Y3_1_CHECK FAULT Value : %d", SAFIN(Y3_1_axis).9
	DISP"Y3_1_CHECK E1 FAULT : %d",AxisErrorCode31
RET	

HomeFail:
DISP" E1 homing fail "
IF Y3_1_IsModeOfOperationInPDO = 1
	Y3_1_ModeOfOperation = 8 
	WAIT 500 
	ECUNMAPOUT (ECGETOFFSET("Mode of operation",Y3_1_EtherCATIndex))
ELSE
	COEWRITE/1 (Y3_1_EtherCATIndex,0x6060,0,8)						!go back to CSP mode 
END  
WAIT 500 
ECUNMAPIN (ECGETOFFSET("Statusword",Y3_1_EtherCATIndex))
ECUNMAPOUT (ECGETOFFSET("Controlword",Y3_1_EtherCATIndex))

STOP
#22
!PNAME=
!PDESC=
! Y3_2_axis Single-axis_Hiwin_Drive_Homing_Process_VER1.5
!!****** Setting Parameter ******!!
LOCAL REAL Y3_2_HmType,Y3_2_multi_indHm,Y3_2_multi_indVel
LOCAL REAL Y3_2_HmVel,Y3_2_IndVel,Y3_2_HmOffset	
LOCAL INT Y3_2_ErrCompensation,Y3_2_ErrCompensationSpacing,Y3_2_ErrCompIniPos
LOCAL INT ZONE0,Y3_2_ErrTableIndex
LOCAL INT Y3_2_HiwinDriveHome,Y3_2_EtherCATIndex,Y3_2_InternalHmType
LOCAL REAL Y3_2_ControlUnit
LOCAL INT Y3_2_IsModeOfOperationInPDO
LOCAL REAL Y3_2_HiwinDriveHmVel,Y3_2_HiwinDriveIndVel,Y3_2_HiwinDriveHmOffset,Y3_2_HiwinDriveHmAcc
!!################ Basic Settings ######################################################################################################
Y3_2_IOIndex = 21
Y3_2_HmType = 1 								!the method of homing
           									!value 0 : Customized homing
           									!	   1 : find the left limit in negative direction,then find index in positive direction 
           									!      2 : find index in positive direction directly 
Y3_2_HmOffset = 0 								! Y3_2_HmOffset (unit)
Y3_2_HmVel = 15000	!30000							! the velocity for homing 	
Y3_2_IndVel = 5000 ! 10000 								! the velocity for finding index

Y3_2_multi_indHm=0								! multi index structure
											! value 0 : nomal Homing
											!	    1 : find the left limit in negative direction,then slowing leave the limit in positive direction,
											!			then slowing find the left limit in negative direction,then slowing find index in positive direction
Y3_2_multi_indVel = 100						! (Do not modify)homing velocity of multi index structure
!!*********************************** With Hiwin Drive homing support HmType 1&2************************************!!
Y3_2_IsModeOfOperationInPDO = 0					! Check #ETHERCAT if include Mode of operation slect 1 else select 0
Y3_2_HiwinDriveHome = 1						! 1 : With E1 internal homing ; 2 : With E1 Touch probe homing 
Y3_2_EtherCATIndex = 19							! EtherCAT nod index
Y3_2_ControlUnit = 1/10						! E1 Control unit
!!**************** Configuration of 1D Error Compensation*****************************************************!!
Y3_2_ErrCompensation = 1						! 0 : without compensation  ; 1 : turn on the compensation after homing completed 
Y3_2_ErrCompIniPos = 0							! the initial position of error compensation
Y3_2_ErrCompensationSpacing = 75000				! setting the spacing for error compensation 
!!**********************************************************************************************************!!
!!######################################################################################################################################## 

!!**************************************************************************************************************************************!!
!!************************************************************ Main program ************************************************************!!
FCLEAR Y3_2_axis
IF Y3_2_HmType=0													! Customized homing
	CALL Y3_2_HmType0	
ELSEIF Y3_2_HiwinDriveHome=1										! E1 internal
	MFLAGS(Y3_2_axis).#HOME=0	
	IF Y3_2_HmType=1
		Y3_2_InternalHmType = 1
	ELSEIF Y3_2_HmType=2
		Y3_2_InternalHmType = 34
	ELSE
		DISP"ERROR:The value of Y3_2_HmType is invalid!!"
		STOP
	END
	CALL Y3_2_HiwinDriveInternalHmType	
ELSEIF Y3_2_HiwinDriveHome=2										! Touch probe
		MFLAGS(Y3_2_axis).#HOME=0	
	IF Y3_2_HmType=1
		CALL Y3_2_HiwinDriveTouchProbeHmType1
	ELSEIF Y3_2_HmType=2
		CALL Y3_2_HiwinDriveTouchProbeHmType2
	ELSE
		DISP"ERROR:The value of Y3_2_HmType is invalid!!"
		STOP
	END
ELSE
	DISP"ERROR:The value of Y3_2_HmType or Y3_2_HiwinDriveHome is invalid!!"
	STOP
END

IF Y3_2_ErrCompensation = 1
	DISP "Enable the compensation mode."
	DISP "Execute the compensation prcoess......"
	CALL Y3_2_ErrorCompensation	
ELSE
	DISP "Disable error compensation."
	ERRORUNMAP Y3_2_axis, ZONE0
END 

IF (Y3_2_HmType>=1&Y3_2_HmType<=2)
	ENABLE Y3_2_axis
	TILL MST(Y3_2_axis).#ENABLED
	WAIT 500
	DISP"Go home......"	
	PTP/EV Y3_2_axis,0,Y3_2_HmVel	
	MFLAGS(Y3_2_axis).#HOME=1
END	
FDEF(Y3_2_axis).#LL = 1	 		
FDEF(Y3_2_axis).#SRL = 1	 		
FDEF(Y3_2_axis).#SLL = 1	 
DISP"Homing successful!!"	

STOP	

!!*************************************************************************************************************************************!!
!!************************************************************ Homing process	*******************************************************!!
Y3_2_HmType0:
!Customized
RET
STOP
!------------------------------------------------------------------Y3_2_HiwinDriveTouchProbeHmType1--------------------------------------------------------------------------------------
Y3_2_HiwinDriveTouchProbeHmType1:

FCLEAR Y3_2_axis
DISABLE Y3_2_axis		
TILL ^MST(Y3_2_axis).#ENABLED	
WAIT 500	
MFLAGS(Y3_2_axis).#OPEN = 0								! Close loop control
ERRORMAPOFF Y3_2_axis, -1									! Close all axis error compensation
MFLAGS(Y3_2_axis).#GANTRY = 0								! turn off gantry mode (MFLAGS.25)	
FDEF(Y3_2_axis).#SRL = 0	 								! disable software right limit response
FDEF(Y3_2_axis).#SLL = 0	 								! disable software left limit response
FDEF(Y3_2_axis).#LL = 0	 										! motor is not disable when left limit signal rising.

ENABLE	Y3_2_axis	 
TILL MST(Y3_2_axis).#ENABLED	 
WAIT 500	
DISP"Start to find the left limit......"
JOG/V Y3_2_axis,-Y3_2_HmVel									! find the left limit in negative direction
TILL (COEREAD/4 (Y3_2_EtherCATIndex,0x60FD,0)& 1) = 1
HALT Y3_2_axis 
TILL ^MST(Y3_2_axis).#MOVE,1000							! if reach left limit , stop motion
DISP"Already found the left limit!!"

!!!!!!!!!!!!!!!!!!!!multi index Structure Homing Way!!!!!!!!!!!!!!!
IF(Y3_2_multi_indHm = 1)	
	JOG/V Y3_2_axis,Y3_2_multi_indVel							! slowing to leave the limit in negative direction
	TILL (COEREAD/4 (Y3_2_EtherCATIndex,0x60FD,0)& 1) = 0	! waiting to leave the limit
	HALT Y3_2_axis
	TILL ^MST(Y3_2_axis).#MOVE 
	Y3_2_IndVel = Y3_2_multi_indVel							! define slowing velocity to find index velocity
END
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
ECOUT(ECGETOFFSET("Touch probe function",Y3_2_EtherCATIndex),Y3_2_TouchProbFun)
WAIT 200
Y3_2_TouchProbFun = 0										!Reset Touch probe
WAIT 200
Y3_2_TouchProbFun = 17										! Start Touch probe
WAIT 200
DISP"Start to find the index in positive direction......"
JOG/V Y3_2_axis,Y3_2_IndVel									!find the index in positive direction
TILL (COEREAD/2 (Y3_2_EtherCATIndex,0x60B9,0) = 3)			!if reach index	, stop motion
HALT Y3_2_axis	
TILL ^MST(Y3_2_axis).#MOVE 
DISP"Already found the index!!"
SET FPOS(Y3_2_axis) = (COEREAD/4 (Y3_2_EtherCATIndex,0x6064,0) - COEREAD/4 (Y3_2_EtherCATIndex,0x60BA,0))*Y3_2_ControlUnit - Y3_2_HmOffset		!set index position as zero.
WAIT 500
ECUNMAPOUT (ECGETOFFSET("Touch probe function",Y3_2_EtherCATIndex))	
RET	
STOP
!------------------------------------------------------------------Y3_2_HiwinDriveTouchProbeHmType2--------------------------------------------------------------------------------------
Y3_2_HiwinDriveTouchProbeHmType2:

FCLEAR Y3_2_axis
DISABLE Y3_2_axis		
TILL ^MST(Y3_2_axis).#ENABLED	
WAIT 500	
MFLAGS(Y3_2_axis).#OPEN = 0						! Close loop control
ERRORMAPOFF Y3_2_axis, -1							! Close all axis error compensation
MFLAGS(Y3_2_axis).#GANTRY = 0	 					! turn off gantry mode (MFLAGS.25)	
FDEF(Y3_2_axis).#SRL = 0	 						! disable software right limit response
FDEF(Y3_2_axis).#SLL = 0	 						! disable software left limit response
FDEF(Y3_2_axis).#LL = 0	 										! motor is not disable when left limit signal rising.

ENABLE	Y3_2_axis	 
!!!!!!!!!!!!!!!!!!!!multi index Structure Homing Way!!!!!!!!!!!!!!!
IF(Y3_2_multi_indHm = 1)	
	Y3_2_IndVel = Y3_2_multi_indVel					! define slowing velocity to find index velocity
END
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
ECOUT(ECGETOFFSET("Touch probe function",Y3_2_EtherCATIndex),Y3_2_TouchProbFun)
WAIT 200
Y3_2_TouchProbFun = 0								!Reset Touch probe
WAIT 200
Y3_2_TouchProbFun = 17								! Start Touch probe
WAIT 200
DISP"Start to find the index in positive direction......"
JOG/V Y3_2_axis,Y3_2_IndVel							!find the index in positive direction
TILL (COEREAD/2 (Y3_2_EtherCATIndex,0x60B9,0) = 3)	!if reach index	, stop motion
HALT Y3_2_axis	
TILL ^MST(Y3_2_axis).#MOVE 
DISP"Already found the index!!"
SET FPOS(Y3_2_axis) = (COEREAD/4 (Y3_2_EtherCATIndex,0x6064,0) - COEREAD/4 (Y3_2_EtherCATIndex,0x60BA,0))*Y3_2_ControlUnit - Y3_2_HmOffset	!set index position as zero.
WAIT 500
ECUNMAPOUT (ECGETOFFSET("Touch probe function",Y3_2_EtherCATIndex))		
RET	
STOP
!------------------------------------------------------------------Y3_2_HiwinDriveInternalHmType--------------------------------------------------------------------------------------
Y3_2_HiwinDriveInternalHmType:

FCLEAR Y3_2_axis
FDEF(Y3_2_axis).#LL = 0	 										! motor is not disable when left limit signal rising.
FDEF(Y3_2_axis).#SRL = 0	 										! disable software right limit response
FDEF(Y3_2_axis).#SLL = 0	 										! disable software left limit response
Y3_2_HiwinDriveHmVel = Y3_2_HmVel/Y3_2_ControlUnit
Y3_2_HiwinDriveIndVel = Y3_2_IndVel/Y3_2_ControlUnit
Y3_2_HiwinDriveHmOffset = Y3_2_HmOffset/Y3_2_ControlUnit
Y3_2_HiwinDriveHmAcc = ACC(Y3_2_axis)/Y3_2_ControlUnit

ECIN( ECGETOFFSET("Statusword",Y3_2_EtherCATIndex),Y3_2_StatusWord)  
ECOUT(ECGETOFFSET("Controlword",Y3_2_EtherCATIndex),Y3_2_ControlWord)
IF Y3_2_IsModeOfOperationInPDO = 1
	ECOUT(ECGETOFFSET("Mode of operation",Y3_2_EtherCATIndex),Y3_2_ModeOfOperation)
	Y3_2_ModeOfOperation = 6
ELSE
	COEWRITE/1 (Y3_2_EtherCATIndex,0x6060,0,6) !6 is Homing mode  
END  


COEWRITE/1 (Y3_2_EtherCATIndex,0x6098,0,Y3_2_InternalHmType)	!negative limit switch?^ --> index
COEWRITE/4 (Y3_2_EtherCATIndex,0x6099,1,Y3_2_HiwinDriveHmVel) 	
COEWRITE/4 (Y3_2_EtherCATIndex,0x6099,2,Y3_2_HiwinDriveIndVel)	
COEWRITE/4 (Y3_2_EtherCATIndex,0x609A,0,Y3_2_HiwinDriveHmAcc)	
COEWRITE/4 (Y3_2_EtherCATIndex,0x607C,0,Y3_2_HiwinDriveHmOffset) 	

Y3_2_ControlWord=6  
TILL Y3_2_StatusWord.0=1  
Y3_2_ControlWord=7  
TILL Y3_2_StatusWord.0=1 & Y3_2_StatusWord.1=1

WAIT 200 

Y3_2_ControlWord=15  
TILL Y3_2_StatusWord.0=1 & Y3_2_StatusWord.1=1 & Y3_2_StatusWord.2=1	!Enabled
!Start Homing Procedure - Bit 4  
Y3_2_ControlWord=31  											!Start Home
TILL Y3_2_StatusWord.12=1 & Y3_2_StatusWord.10=1 | Y3_2_StatusWord.13=1				!Home Finished
Disp "Y3_2 Home Finish-1"
!#############################################################################################################
IF Y3_2_StatusWord.13=1
	CALL HomeFail
ELSE
		Y3_2_HmVel= Y3_2_HmVel/5
		Y3_2_IndVel= Y3_2_IndVel/5
		Y3_2_HiwinDriveHmVel = Y3_2_HmVel/Y3_2_ControlUnit
		Y3_2_HiwinDriveIndVel = Y3_2_IndVel/Y3_2_ControlUnit
		
		IF Y3_2_IsModeOfOperationInPDO = 1
			ECOUT(ECGETOFFSET("Mode of operation",Y3_2_EtherCATIndex),Y3_2_ModeOfOperation)
			Y3_2_ModeOfOperation = 6
		ELSE
			COEWRITE/1 (Y3_2_EtherCATIndex,0x6060,0,6) !6 is Homing mode  
		END  
		
		COEWRITE/1 (Y3_2_EtherCATIndex,0x6098,0,Y3_2_InternalHmType)	!negative limit switch?^ --> index
		COEWRITE/4 (Y3_2_EtherCATIndex,0x6099,1,Y3_2_HiwinDriveHmVel) 	
		COEWRITE/4 (Y3_2_EtherCATIndex,0x6099,2,Y3_2_HiwinDriveIndVel)	
		COEWRITE/4 (Y3_2_EtherCATIndex,0x609A,0,Y3_2_HiwinDriveHmAcc)	
		COEWRITE/4 (Y3_2_EtherCATIndex,0x607C,0,Y3_2_HiwinDriveHmOffset) 	
		
		Y3_2_ControlWord=6  
		TILL Y3_2_StatusWord.0=1  
		Y3_2_ControlWord=7  
		TILL Y3_2_StatusWord.0=1 & Y3_2_StatusWord.1=1
		
		WAIT 200 
		
		Y3_2_ControlWord=15  
		TILL Y3_2_StatusWord.0=1 & Y3_2_StatusWord.1=1 & Y3_2_StatusWord.2=1	!Enabled
		!Start Homing Procedure - Bit 4  
		Y3_2_ControlWord=31  											!Start Home
		TILL Y3_2_StatusWord.12=1 & Y3_2_StatusWord.10=1 | Y3_2_StatusWord.13=1				!Home Finished
		Disp "Y3_2 Home Finish-2"
END
!#############################################################################################################
IF Y3_2_StatusWord.13=1
	CALL HomeFail
END

Y3_2_ControlWord=0  

WAIT 100

IF Y3_2_IsModeOfOperationInPDO = 1
	Y3_2_ModeOfOperation = 8 
	WAIT 500 
	ECUNMAPOUT (ECGETOFFSET("Mode of operation",Y3_2_EtherCATIndex))
ELSE
	COEWRITE/1 (Y3_2_EtherCATIndex,0x6060,0,8)						!go back to CSP mode 
END  
WAIT 500 
ECUNMAPIN (ECGETOFFSET("Statusword",Y3_2_EtherCATIndex))
ECUNMAPOUT (ECGETOFFSET("Controlword",Y3_2_EtherCATIndex))

WAIT 500 
DISABLE Y3_2_axis
TILL ^MST(Y3_2_axis).#ENABLED 

RET
STOP
!!*************************************************************************************************************************************!!
!!****************************************************** Error Compensation Process ***************************************************!!
Y3_2_ErrorCompensation:
!---------- Y3_2_axis Error Compensation Table ------------!
Y3_2_ErrTable(0)=	0	;
Y3_2_ErrTable(1)=	3.4	;
Y3_2_ErrTable(2)=	12.2	;
Y3_2_ErrTable(3)=	22.5	;
Y3_2_ErrTable(4)=	24.2	;
Y3_2_ErrTable(5)=	23.7	;
Y3_2_ErrTable(6)=	28.5	;
Y3_2_ErrTable(7)=	41.9	;
Y3_2_ErrTable(8)=	55.2	;
Y3_2_ErrTable(9)=	47.2	;
Y3_2_ErrTable(10)=	53.7	;
Y3_2_ErrTable(11)=	65.1	;
Y3_2_ErrTable(12)=	68.2	;
Y3_2_ErrTable(13)=	73.5	;
Y3_2_ErrTable(14)=	67.9	;
Y3_2_ErrTable(15)=	89	;
Y3_2_ErrTable(16)=	92.2	;
Y3_2_ErrTable(17)=	91.5	;
Y3_2_ErrTable(18)=	91.3	;
Y3_2_ErrTable(19)=	104.2	;
Y3_2_ErrTable(20)=	112.6	;

!-------------------------------------------------------!
Y3_2_ErrTableIndex = 0
WHILE Y3_2_ErrTableIndex < SIZEOF(Y3_2_ErrTable)
	Y3_2_ErrTable(Y3_2_ErrTableIndex) = -Y3_2_ErrTable(Y3_2_ErrTableIndex)
	Y3_2_ErrTableIndex = Y3_2_ErrTableIndex + 1
END
ERRORUNMAP Y3_2_axis, ZONE0
ERRORMAP1D Y3_2_axis, ZONE0, Y3_2_ErrCompIniPos, Y3_2_ErrCompensationSpacing, Y3_2_ErrTable
ERRORMAPON Y3_2_axis, ZONE0

WAIT 500	
DISP "Cmpensation Procces's completed!"

RET 
STOP
!!#############################################################################################################################

ON MFLAGS(Y3_2_axis).#HOME=1 & TPOS(Y3_2_axis) < SLLIMIT(Y3_2_axis) 
	IF( FDEF(Y3_2_axis).#SLL=1 & FMASK(Y3_2_axis).#SLL=1 & ^(GMTYPE(Y3_2_axis)=5))
		KILL Y3_2_axis,5016	!Software Left Limit
		TPOS(Y3_2_axis)=FPOS(Y3_2_axis)
		DISP "TPOS(Y3_2_axis) < SLLIMIT(Y3_2_axis)"
	END
RET

ON MFLAGS(Y3_2_axis).#HOME=1 & TPOS(Y3_2_axis) > SRLIMIT(Y3_2_axis) 
	IF(FDEF(Y3_2_axis).#SRL=1 & FMASK(Y3_2_axis).#SRL=1 & ^(GMTYPE(Y3_2_axis)=5))
		KILL Y3_2_axis,5015	!Software Right Limit
		TPOS(Y3_2_axis)=FPOS(Y3_2_axis)
		DISP "TPOS(Y3_2_axis) > SRLIMIT(Y3_2_axis)"
	END
RET


ON MFLAGS(Y3_2_axis).#HOME=0 & RVEL(Y3_2_axis) > XVEL(Y3_2_axis)*0.5 & ^MST(Y3_2_axis).#INPOS
	IMM VEL(Y3_2_axis) = XVEL(Y3_2_axis)*0.45 
RET

ON MFLAGS(Y3_2_axis).#HOME=0 & RVEL(Y3_2_axis) < -XVEL(Y3_2_axis)*0.5 & ^MST(Y3_2_axis).#INPOS
	IMM VEL(Y3_2_axis) = -XVEL(Y3_2_axis)*0.45 
RET

AUTOEXEC:
	Y3_2_IOIndex = 21
	MFLAGS(Y3_2_axis).#HOME=0
STOP

ON IN(Y3_2_IOIndex).0 = 1
	SAFINI(Y3_2_axis).#LL = 1
RET

ON IN(Y3_2_IOIndex).0 = 0
	SAFINI(Y3_2_axis).#LL = 0
RET

ON IN(Y3_2_IOIndex).1 = 1
	SAFINI(Y3_2_axis).#RL = 1
RET

ON IN(Y3_2_IOIndex).1 = 0
	SAFINI(Y3_2_axis).#RL = 0
RET

!ON MST(Y3_2_axis).#ENABLED & (IN(Y3_2_IOIndex).24 = 1 | IN(Y3_2_IOIndex).25 = 1)
!	KILL Y3_2_axis
!	TILL ^MST(Y3_2_axis).#MOVE,500 
!	DISABLE Y3_2_axis,5028		!Safe Torque Off
!	TILL ^MST(Y3_2_axis).#ENABLED
!RET	

ON IN(Y3_2_IOIndex).24 = 1 | IN(Y3_2_IOIndex).25 = 1
    DISP"Y3_2_Event Time : %d",TIME
 	DISP"Y3_2_CHECK SF1 Value : %d",IN(Y3_2_IOIndex).24
	DISP"Y3_2_CHECK SF2 Value : %d",IN(Y3_2_IOIndex).25
	WAIT 5
	DISP"Y3_2_CHECK FAULT Value : %d", SAFIN(Y3_2_axis).9
	DISP"Y3_2_CHECK E1 FAULT : %d",AxisErrorCode32
RET	

HomeFail:
DISP " E1 homing fail "
IF Y3_2_IsModeOfOperationInPDO = 1
	Y3_2_ModeOfOperation = 8 
	WAIT 500 
	ECUNMAPOUT (ECGETOFFSET("Mode of operation",Y3_2_EtherCATIndex))
ELSE
	COEWRITE/1 (Y3_2_EtherCATIndex,0x6060,0,8)						!go back to CSP mode 
END  
WAIT 500 
ECUNMAPIN (ECGETOFFSET("Statusword",Y3_2_EtherCATIndex))
ECUNMAPOUT (ECGETOFFSET("Controlword",Y3_2_EtherCATIndex))
STOP
#23
!PNAME=
!PDESC=
! Z3_axis Single-axis_Hiwin_Drive_Homing_Process_VER1.5
!!****** Setting Parameter ******!!
LOCAL REAL Z3_HmType,Z3_multi_indHm,Z3_multi_indVel
LOCAL REAL Z3_HmVel,Z3_IndVel,Z3_HmOffset	
LOCAL INT Z3_ErrCompensation,Z3_ErrCompensationSpacing,Z3_ErrCompIniPos
LOCAL INT ZONE0,Z3_ErrTableIndex
LOCAL INT Z3_HiwinDriveHome,Z3_EtherCATIndex,Z3_InternalHmType
LOCAL REAL Z3_ControlUnit
LOCAL INT Z3_IsModeOfOperationInPDO
LOCAL REAL Z3_HiwinDriveHmVel,Z3_HiwinDriveIndVel,Z3_HiwinDriveHmOffset,Z3_HiwinDriveHmAcc
!!################ Basic Settings ######################################################################################################
Z3_IOIndex = 22                             !2023.11.30
Z3_HmType = 1 								!the method of homing
           									!value 0 : Customized homing
           									!	   1 : find the left limit in negative direction,then find index in positive direction 
           									!      2 : find index in positive direction directly 
Z3_HmOffset = 0 								! Z3_HmOffset (unit)
Z3_HmVel = 30000								! the velocity for homing 	
Z3_IndVel = 10000 								! the velocity for finding index

Z3_multi_indHm=0								! multi index structure
											! value 0 : nomal Homing
											!	    1 : find the left limit in negative direction,then slowing leave the limit in positive direction,
											!			then slowing find the left limit in negative direction,then slowing find index in positive direction
Z3_multi_indVel = 100						! (Do not modify)homing velocity of multi index structure
!!*********************************** With Hiwin Drive homing support HmType 1&2************************************!!
Z3_IsModeOfOperationInPDO = 0					! Check #ETHERCAT if include Mode of operation slect 1 else select 0
Z3_HiwinDriveHome = 1						! 1 : With E1 internal homing ; 2 : With E1 Touch probe homing 
Z3_EtherCATIndex = 20							! EtherCAT nod index
Z3_ControlUnit = 1/10							! E1 Control unit
!!**************** Configuration of 1D Error Compensation*****************************************************!!
Z3_ErrCompensation = 1						! 0 : without compensation  ; 1 : turn on the compensation after homing completed 
Z3_ErrCompIniPos = 0							! the initial position of error compensation
Z3_ErrCompensationSpacing = 10000				! setting the spacing for error compensation 
!!**********************************************************************************************************!!
!!######################################################################################################################################## 

!!**************************************************************************************************************************************!!
!!************************************************************ Main program ************************************************************!!

IF Z3_HmType=0													! Customized homing
	CALL Z3_HmType0	
ELSEIF Z3_HiwinDriveHome=1										! E1 internal
	MFLAGS(Z3_axis).#HOME=0	
	IF Z3_HmType=1
		Z3_InternalHmType = 1
	ELSEIF Z3_HmType=2
		Z3_InternalHmType = 34
	ELSE
		DISP"ERROR:The value of Z3_HmType is invalid!!"
		STOP
	END
	CALL Z3_HiwinDriveInternalHmType	
ELSEIF Z3_HiwinDriveHome=2										! Touch probe
		MFLAGS(Z3_axis).#HOME=0	
	IF Z3_HmType=1
		CALL Z3_HiwinDriveTouchProbeHmType1
	ELSEIF Z3_HmType=2
		CALL Z3_HiwinDriveTouchProbeHmType2
	ELSE
		DISP"ERROR:The value of Z3_HmType is invalid!!"
		STOP
	END
ELSE
	DISP"ERROR:The value of Z3_HmType or Z3_HiwinDriveHome is invalid!!"
	STOP
END

IF Z3_ErrCompensation = 1
	DISP "Enable the compensation mode."
	DISP "Execute the compensation prcoess......"
	CALL Z3_ErrorCompensation	
ELSE
	DISP "Disable error compensation."
	ERRORUNMAP Z3_axis, ZONE0
END 

IF (Z3_HmType>=1&Z3_HmType<=2)
	ENABLE Z3_axis
	TILL MST(Z3_axis).#ENABLED
	WAIT 500
	DISP"Go home......"	
	PTP/EV Z3_axis,0,Z3_HmVel	
	MFLAGS(Z3_axis).#HOME=1
END	
FDEF(Z3_axis).#LL = 1	 		
FDEF(Z3_axis).#SRL = 1	 		
FDEF(Z3_axis).#SLL = 1	 
DISP"Homing successful!!"	

STOP	

!!*************************************************************************************************************************************!!
!!************************************************************ Homing process	*******************************************************!!
Z3_HmType0:
!Customized
RET
STOP
!------------------------------------------------------------------Z3_HiwinDriveTouchProbeHmType1--------------------------------------------------------------------------------------
Z3_HiwinDriveTouchProbeHmType1:

FCLEAR Z3_axis
DISABLE Z3_axis		
TILL ^MST(Z3_axis).#ENABLED	
WAIT 500	
MFLAGS(Z3_axis).#OPEN = 0								! Close loop control
ERRORMAPOFF Z3_axis, -1									! Close all axis error compensation
MFLAGS(Z3_axis).#GANTRY = 0								! turn off gantry mode (MFLAGS.25)	
FDEF(Z3_axis).#SRL = 0	 								! disable software right limit response
FDEF(Z3_axis).#SLL = 0	 								! disable software left limit response
FDEF(Z3_axis).#LL = 0	 										! motor is not disable when left limit signal rising.

ENABLE	Z3_axis	 
TILL MST(Z3_axis).#ENABLED	 
WAIT 500	
DISP"Start to find the left limit......"
JOG/V Z3_axis,-Z3_HmVel									! find the left limit in negative direction
TILL (COEREAD/4 (Z3_EtherCATIndex,0x60FD,0)& 1) = 1
HALT Z3_axis 
TILL ^MST(Z3_axis).#MOVE,1000							! if reach left limit , stop motion
DISP"Already found the left limit!!"

!!!!!!!!!!!!!!!!!!!!multi index Structure Homing Way!!!!!!!!!!!!!!!
IF(Z3_multi_indHm = 1)	
	JOG/V Z3_axis,Z3_multi_indVel							! slowing to leave the limit in negative direction
	TILL (COEREAD/4 (Z3_EtherCATIndex,0x60FD,0)& 1) = 0	! waiting to leave the limit
	HALT Z3_axis
	TILL ^MST(Z3_axis).#MOVE 
	Z3_IndVel = Z3_multi_indVel							! define slowing velocity to find index velocity
END
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
ECOUT(ECGETOFFSET("Touch probe function",Z3_EtherCATIndex),Z3_TouchProbFun)
WAIT 200
Z3_TouchProbFun = 0										!Reset Touch probe
WAIT 200
Z3_TouchProbFun = 17										! Start Touch probe
WAIT 200
DISP"Start to find the index in positive direction......"
JOG/V Z3_axis,Z3_IndVel									!find the index in positive direction
TILL (COEREAD/2 (Z3_EtherCATIndex,0x60B9,0) = 3)			!if reach index	, stop motion
HALT Z3_axis	
TILL ^MST(Z3_axis).#MOVE 
DISP"Already found the index!!"
SET FPOS(Z3_axis) = (COEREAD/4 (Z3_EtherCATIndex,0x6064,0) - COEREAD/4 (Z3_EtherCATIndex,0x60BA,0))*Z3_ControlUnit - Z3_HmOffset		!set index position as zero.
WAIT 500
ECUNMAPOUT (ECGETOFFSET("Touch probe function",Z3_EtherCATIndex))	
RET	
STOP
!------------------------------------------------------------------Z3_HiwinDriveTouchProbeHmType2--------------------------------------------------------------------------------------
Z3_HiwinDriveTouchProbeHmType2:

FCLEAR Z3_axis
DISABLE Z3_axis		
TILL ^MST(Z3_axis).#ENABLED	
WAIT 500	
MFLAGS(Z3_axis).#OPEN = 0						! Close loop control
ERRORMAPOFF Z3_axis, -1							! Close all axis error compensation
MFLAGS(Z3_axis).#GANTRY = 0	 					! turn off gantry mode (MFLAGS.25)	
FDEF(Z3_axis).#SRL = 0	 						! disable software right limit response
FDEF(Z3_axis).#SLL = 0	 						! disable software left limit response
FDEF(Z3_axis).#LL = 0	 										! motor is not disable when left limit signal rising.

ENABLE	Z3_axis	 
!!!!!!!!!!!!!!!!!!!!multi index Structure Homing Way!!!!!!!!!!!!!!!
IF(Z3_multi_indHm = 1)	
	Z3_IndVel = Z3_multi_indVel					! define slowing velocity to find index velocity
END
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
ECOUT(ECGETOFFSET("Touch probe function",Z3_EtherCATIndex),Z3_TouchProbFun)
WAIT 200
Z3_TouchProbFun = 0								!Reset Touch probe
WAIT 200
Z3_TouchProbFun = 17								! Start Touch probe
WAIT 200
DISP"Start to find the index in positive direction......"
JOG/V Z3_axis,Z3_IndVel							!find the index in positive direction
TILL (COEREAD/2 (Z3_EtherCATIndex,0x60B9,0) = 3)	!if reach index	, stop motion
HALT Z3_axis	
TILL ^MST(Z3_axis).#MOVE 
DISP"Already found the index!!"
SET FPOS(Z3_axis) = (COEREAD/4 (Z3_EtherCATIndex,0x6064,0) - COEREAD/4 (Z3_EtherCATIndex,0x60BA,0))*Z3_ControlUnit - Z3_HmOffset	!set index position as zero.
WAIT 500
ECUNMAPOUT (ECGETOFFSET("Touch probe function",Z3_EtherCATIndex))		
RET	
STOP
!------------------------------------------------------------------Z3_HiwinDriveInternalHmType--------------------------------------------------------------------------------------
Z3_HiwinDriveInternalHmType:

FCLEAR Z3_axis
FDEF(Z3_axis).#LL = 0	 										! motor is not disable when left limit signal rising.
FDEF(Z3_axis).#SRL = 0	 										! disable software right limit response
FDEF(Z3_axis).#SLL = 0	 										! disable software left limit response
Z3_HiwinDriveHmVel = Z3_HmVel/Z3_ControlUnit
Z3_HiwinDriveIndVel = Z3_IndVel/Z3_ControlUnit
Z3_HiwinDriveHmOffset = Z3_HmOffset/Z3_ControlUnit
Z3_HiwinDriveHmAcc = ACC(Z3_axis)/Z3_ControlUnit

ECIN( ECGETOFFSET("Statusword",Z3_EtherCATIndex),Z3_StatusWord)  
ECOUT(ECGETOFFSET("Controlword",Z3_EtherCATIndex),Z3_ControlWord)
IF Z3_IsModeOfOperationInPDO = 1
	ECOUT(ECGETOFFSET("Mode of operation",Z3_EtherCATIndex),Z3_ModeOfOperation)
	Z3_ModeOfOperation = 6
ELSE
	COEWRITE/1 (Z3_EtherCATIndex,0x6060,0,6) !6 is Homing mode  
END  


COEWRITE/1 (Z3_EtherCATIndex,0x6098,0,Z3_InternalHmType)	
COEWRITE/4 (Z3_EtherCATIndex,0x6099,1,Z3_HiwinDriveHmVel) 	
COEWRITE/4 (Z3_EtherCATIndex,0x6099,2,Z3_HiwinDriveIndVel)	
COEWRITE/4 (Z3_EtherCATIndex,0x609A,0,Z3_HiwinDriveHmAcc)	
COEWRITE/4 (Z3_EtherCATIndex,0x607C,0,Z3_HiwinDriveHmOffset) 	

Z3_ControlWord=6  
TILL Z3_StatusWord.0=1  
Z3_ControlWord=7  
TILL Z3_StatusWord.0=1 & Z3_StatusWord.1=1

WAIT 200 

Z3_ControlWord=15  
TILL Z3_StatusWord.0=1 & Z3_StatusWord.1=1 & Z3_StatusWord.2=1	!Enabled
!Start Homing Procedure - Bit 4  
Z3_ControlWord=31  											!Start Home
TILL Z3_StatusWord.12=1 & Z3_StatusWord.10=1 | Z3_StatusWord.13=1				!Home Finished

IF Z3_StatusWord.13=1
	CALL HomeFail
END

Z3_ControlWord=0  

WAIT 100

IF Z3_IsModeOfOperationInPDO = 1
	Z3_ModeOfOperation = 8 
	WAIT 500 
	ECUNMAPOUT (ECGETOFFSET("Mode of operation",Z3_EtherCATIndex))
ELSE
	COEWRITE/1 (Z3_EtherCATIndex,0x6060,0,8)						!go back to CSP mode 
END  
WAIT 500 
ECUNMAPIN (ECGETOFFSET("Statusword",Z3_EtherCATIndex))
ECUNMAPOUT (ECGETOFFSET("Controlword",Z3_EtherCATIndex))

WAIT 500 
DISABLE Z3_axis
TILL ^MST(Z3_axis).#ENABLED 

RET
STOP
!!*************************************************************************************************************************************!!
!!****************************************************** Error Compensation Process ***************************************************!!
Z3_ErrorCompensation:
!---------- Z3_axis Error Compensation Table ------------!
Z3_ErrTable(0)=	0
Z3_ErrTable(1)=	-4.2
Z3_ErrTable(2)=	-4
Z3_ErrTable(3)=	-3.8
Z3_ErrTable(4)=	-3.3
Z3_ErrTable(5)=	-3
Z3_ErrTable(6)=	-3.7
Z3_ErrTable(7)=	-3.6
Z3_ErrTable(8)=	-3.2
Z3_ErrTable(9)=	-2.3
Z3_ErrTable(10)=	-5.9

!-------------------------------------------------------!
Z3_ErrTableIndex = 0
WHILE Z3_ErrTableIndex < SIZEOF(Z3_ErrTable)
	Z3_ErrTable(Z3_ErrTableIndex) = -Z3_ErrTable(Z3_ErrTableIndex)
	Z3_ErrTableIndex = Z3_ErrTableIndex + 1
END
ERRORUNMAP Z3_axis, ZONE0
ERRORMAP1D Z3_axis, ZONE0, Z3_ErrCompIniPos, Z3_ErrCompensationSpacing, Z3_ErrTable
ERRORMAPON Z3_axis, ZONE0

WAIT 500	
DISP "Cmpensation Procces's completed!"

RET 
STOP
!!#############################################################################################################################

ON MFLAGS(Z3_axis).#HOME=1 & TPOS(Z3_axis) < SLLIMIT(Z3_axis) 
	IF( FDEF(Z3_axis).#SLL=1 & FMASK(Z3_axis).#SLL=1 & ^(GMTYPE(Z3_axis)=5))
		KILL Z3_axis,5016	!Software Left Limit
		TPOS(Z3_axis)=FPOS(Z3_axis)
		DISP "TPOS(Z3_axis) < SLLIMIT(Z3_axis)"
	END
RET

ON MFLAGS(Z3_axis).#HOME=1 & TPOS(Z3_axis) > SRLIMIT(Z3_axis) 
	IF(FDEF(Z3_axis).#SRL=1 & FMASK(Z3_axis).#SRL=1 & ^(GMTYPE(Z3_axis)=5))
		KILL Z3_axis,5015	!Software Right Limit
		TPOS(Z3_axis)=FPOS(Z3_axis)
		DISP "TPOS(Z3_axis) > SRLIMIT(Z3_axis)"
	END
RET


ON MFLAGS(Z3_axis).#HOME=0 & RVEL(Z3_axis) > XVEL(Z3_axis)*0.5 & ^MST(Z3_axis).#INPOS
	IMM VEL(Z3_axis) = XVEL(Z3_axis)*0.45 
RET

ON MFLAGS(Z3_axis).#HOME=0 & RVEL(Z3_axis) < -XVEL(Z3_axis)*0.5 & ^MST(Z3_axis).#INPOS
	IMM VEL(Z3_axis) = -XVEL(Z3_axis)*0.45 
RET

AUTOEXEC:
	Z3_IOIndex = 22
	MFLAGS(Z3_axis).#HOME=0
STOP

ON IN(Z3_IOIndex).0 = 1
	SAFINI(Z3_axis).#LL = 1
RET

ON IN(Z3_IOIndex).0 = 0
	SAFINI(Z3_axis).#LL = 0
RET

ON IN(Z3_IOIndex).1 = 1
	SAFINI(Z3_axis).#RL = 1
RET

ON IN(Z3_IOIndex).1 = 0
	SAFINI(Z3_axis).#RL = 0
RET

!ON MST(Z3_axis).#ENABLED & (IN(Z3_IOIndex).24 = 1 | IN(Z3_IOIndex).25 = 1)
!	KILL Z3_axis
!	TILL ^MST(Z3_axis).#MOVE,500 
!	DISABLE Z3_axis,5028		!Safe Torque Off
!	TILL ^MST(Z3_axis).#ENABLED
!RET	

ON IN(Z3_IOIndex).24 = 1 | IN(Z3_IOIndex).25 = 1
    DISP"Z3_Event Time : %d",TIME
 	DISP"Z3_CHECK SF1 Value : %d",IN(Z3_IOIndex).24
	DISP"Z3_CHECK SF2 Value : %d",IN(Z3_IOIndex).25
	WAIT 5
	DISP"Z3_CHECK FAULT Value : %d", SAFIN(Z3_axis).9
	DISP"Z3_CHECK E1 FAULT : %d",AxisErrorCode33
RET	

HomeFail:
DISP" E1 homing fail "
IF Z3_IsModeOfOperationInPDO = 1
	Z3_ModeOfOperation = 8 
	WAIT 500 
	ECUNMAPOUT (ECGETOFFSET("Mode of operation",Z3_EtherCATIndex))
ELSE
	COEWRITE/1 (Z3_EtherCATIndex,0x6060,0,8)						!go back to CSP mode 
END  
WAIT 500 
ECUNMAPIN (ECGETOFFSET("Statusword",Z3_EtherCATIndex))
ECUNMAPOUT (ECGETOFFSET("Controlword",Z3_EtherCATIndex))

STOP
#24
!PNAME=
!PDESC=
! Z4_axis Single-axis_Hiwin_Drive_Homing_Process_VER1.5
!!****** Setting Parameter ******!!
LOCAL REAL Z4_HmType,Z4_multi_indHm,Z4_multi_indVel
LOCAL REAL Z4_HmVel,Z4_IndVel,Z4_HmOffset	
LOCAL INT Z4_ErrCompensation,Z4_ErrCompensationSpacing,Z4_ErrCompIniPos
LOCAL INT ZONE0,Z4_ErrTableIndex
LOCAL INT Z4_HiwinDriveHome,Z4_EtherCATIndex,Z4_InternalHmType
LOCAL REAL Z4_ControlUnit
LOCAL INT Z4_IsModeOfOperationInPDO
LOCAL REAL Z4_HiwinDriveHmVel,Z4_HiwinDriveIndVel,Z4_HiwinDriveHmOffset,Z4_HiwinDriveHmAcc
!!################ Basic Settings ######################################################################################################
Z4_IOIndex = 23                             !2023.11.30
Z4_HmType = 1 								!the method of homing
           									!value 0 : Customized homing
           									!	   1 : find the left limit in negative direction,then find index in positive direction 
           									!      2 : find index in positive direction directly 
Z4_HmOffset = 0 								! Z4_HmOffset (unit)
Z4_HmVel = 30000								! the velocity for homing 	
Z4_IndVel = 10000 								! the velocity for finding index

Z4_multi_indHm=0								! multi index structure
											! value 0 : nomal Homing
											!	    1 : find the left limit in negative direction,then slowing leave the limit in positive direction,
											!			then slowing find the left limit in negative direction,then slowing find index in positive direction
Z4_multi_indVel = 100						! (Do not modify)homing velocity of multi index structure
!!*********************************** With Hiwin Drive homing support HmType 1&2************************************!!
Z4_IsModeOfOperationInPDO = 0					! Check #ETHERCAT if include Mode of operation slect 1 else select 0
Z4_HiwinDriveHome = 1						! 1 : With E1 internal homing ; 2 : With E1 Touch probe homing 
Z4_EtherCATIndex = 21							! EtherCAT nod index
Z4_ControlUnit = 1/10							! E1 Control unit
!!**************** Configuration of 1D Error Compensation*****************************************************!!
Z4_ErrCompensation = 1						! 0 : without compensation  ; 1 : turn on the compensation after homing completed 
Z4_ErrCompIniPos = 0							! the initial position of error compensation
Z4_ErrCompensationSpacing = 10000				! setting the spacing for error compensation 
!!**********************************************************************************************************!!
!!######################################################################################################################################## 

!!**************************************************************************************************************************************!!
!!************************************************************ Main program ************************************************************!!

IF Z4_HmType=0													! Customized homing
	CALL Z4_HmType0	
ELSEIF Z4_HiwinDriveHome=1										! E1 internal
	MFLAGS(Z4_axis).#HOME=0	
	IF Z4_HmType=1
		Z4_InternalHmType = 1
	ELSEIF Z4_HmType=2
		Z4_InternalHmType = 34
	ELSE
		DISP"ERROR:The value of Z4_HmType is invalid!!"
		STOP
	END
	CALL Z4_HiwinDriveInternalHmType	
ELSEIF Z4_HiwinDriveHome=2										! Touch probe
		MFLAGS(Z4_axis).#HOME=0	
	IF Z4_HmType=1
		CALL Z4_HiwinDriveTouchProbeHmType1
	ELSEIF Z4_HmType=2
		CALL Z4_HiwinDriveTouchProbeHmType2
	ELSE
		DISP"ERROR:The value of Z4_HmType is invalid!!"
		STOP
	END
ELSE
	DISP"ERROR:The value of Z4_HmType or Z4_HiwinDriveHome is invalid!!"
	STOP
END

IF Z4_ErrCompensation = 1
	DISP "Enable the compensation mode."
	DISP "Execute the compensation prcoess......"
	CALL Z4_ErrorCompensation	
ELSE
	DISP "Disable error compensation."
	ERRORUNMAP Z4_axis, ZONE0
END 

IF (Z4_HmType>=1&Z4_HmType<=2)
	ENABLE Z4_axis
	TILL MST(Z4_axis).#ENABLED
	WAIT 500
	DISP"Go home......"	
	PTP/EV Z4_axis,0,Z4_HmVel	
	MFLAGS(Z4_axis).#HOME=1
END	
FDEF(Z4_axis).#LL = 1	 		
FDEF(Z4_axis).#SRL = 1	 		
FDEF(Z4_axis).#SLL = 1	 
DISP"Homing successful!!"	

STOP	

!!*************************************************************************************************************************************!!
!!************************************************************ Homing process	*******************************************************!!
Z4_HmType0:
!Customized
RET
STOP
!------------------------------------------------------------------Z4_HiwinDriveTouchProbeHmType1--------------------------------------------------------------------------------------
Z4_HiwinDriveTouchProbeHmType1:

FCLEAR Z4_axis
DISABLE Z4_axis		
TILL ^MST(Z4_axis).#ENABLED	
WAIT 500	
MFLAGS(Z4_axis).#OPEN = 0								! Close loop control
ERRORMAPOFF Z4_axis, -1									! Close all axis error compensation
MFLAGS(Z4_axis).#GANTRY = 0								! turn off gantry mode (MFLAGS.25)	
FDEF(Z4_axis).#SRL = 0	 								! disable software right limit response
FDEF(Z4_axis).#SLL = 0	 								! disable software left limit response
FDEF(Z4_axis).#LL = 0	 										! motor is not disable when left limit signal rising.

ENABLE	Z4_axis	 
TILL MST(Z4_axis).#ENABLED	 
WAIT 500	
DISP"Start to find the left limit......"
JOG/V Z4_axis,-Z4_HmVel									! find the left limit in negative direction
TILL (COEREAD/4 (Z4_EtherCATIndex,0x60FD,0)& 1) = 1
HALT Z4_axis 
TILL ^MST(Z4_axis).#MOVE,1000							! if reach left limit , stop motion
DISP"Already found the left limit!!"

!!!!!!!!!!!!!!!!!!!!multi index Structure Homing Way!!!!!!!!!!!!!!!
IF(Z4_multi_indHm = 1)	
	JOG/V Z4_axis,Z4_multi_indVel							! slowing to leave the limit in negative direction
	TILL (COEREAD/4 (Z4_EtherCATIndex,0x60FD,0)& 1) = 0	! waiting to leave the limit
	HALT Z4_axis
	TILL ^MST(Z4_axis).#MOVE 
	Z4_IndVel = Z4_multi_indVel							! define slowing velocity to find index velocity
END
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
ECOUT(ECGETOFFSET("Touch probe function",Z4_EtherCATIndex),Z4_TouchProbFun)
WAIT 200
Z4_TouchProbFun = 0										!Reset Touch probe
WAIT 200
Z4_TouchProbFun = 17										! Start Touch probe
WAIT 200
DISP"Start to find the index in positive direction......"
JOG/V Z4_axis,Z4_IndVel									!find the index in positive direction
TILL (COEREAD/2 (Z4_EtherCATIndex,0x60B9,0) = 3)			!if reach index	, stop motion
HALT Z4_axis	
TILL ^MST(Z4_axis).#MOVE 
DISP"Already found the index!!"
SET FPOS(Z4_axis) = (COEREAD/4 (Z4_EtherCATIndex,0x6064,0) - COEREAD/4 (Z4_EtherCATIndex,0x60BA,0))*Z4_ControlUnit - Z4_HmOffset		!set index position as zero.
WAIT 500
ECUNMAPOUT (ECGETOFFSET("Touch probe function",Z4_EtherCATIndex))	
RET	
STOP
!------------------------------------------------------------------Z4_HiwinDriveTouchProbeHmType2--------------------------------------------------------------------------------------
Z4_HiwinDriveTouchProbeHmType2:

FCLEAR Z4_axis
DISABLE Z4_axis		
TILL ^MST(Z4_axis).#ENABLED	
WAIT 500	
MFLAGS(Z4_axis).#OPEN = 0						! Close loop control
ERRORMAPOFF Z4_axis, -1							! Close all axis error compensation
MFLAGS(Z4_axis).#GANTRY = 0	 					! turn off gantry mode (MFLAGS.25)	
FDEF(Z4_axis).#SRL = 0	 						! disable software right limit response
FDEF(Z4_axis).#SLL = 0	 						! disable software left limit response
FDEF(Z4_axis).#LL = 0	 										! motor is not disable when left limit signal rising.

ENABLE	Z4_axis	 
!!!!!!!!!!!!!!!!!!!!multi index Structure Homing Way!!!!!!!!!!!!!!!
IF(Z4_multi_indHm = 1)	
	Z4_IndVel = Z4_multi_indVel					! define slowing velocity to find index velocity
END
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
ECOUT(ECGETOFFSET("Touch probe function",Z4_EtherCATIndex),Z4_TouchProbFun)
WAIT 200
Z4_TouchProbFun = 0								!Reset Touch probe
WAIT 200
Z4_TouchProbFun = 17								! Start Touch probe
WAIT 200
DISP"Start to find the index in positive direction......"
JOG/V Z4_axis,Z4_IndVel							!find the index in positive direction
TILL (COEREAD/2 (Z4_EtherCATIndex,0x60B9,0) = 3)	!if reach index	, stop motion
HALT Z4_axis	
TILL ^MST(Z4_axis).#MOVE 
DISP"Already found the index!!"
SET FPOS(Z4_axis) = (COEREAD/4 (Z4_EtherCATIndex,0x6064,0) - COEREAD/4 (Z4_EtherCATIndex,0x60BA,0))*Z4_ControlUnit - Z4_HmOffset	!set index position as zero.
WAIT 500
ECUNMAPOUT (ECGETOFFSET("Touch probe function",Z4_EtherCATIndex))		
RET	
STOP
!------------------------------------------------------------------Z4_HiwinDriveInternalHmType--------------------------------------------------------------------------------------
Z4_HiwinDriveInternalHmType:

FCLEAR Z4_axis
FDEF(Z4_axis).#LL = 0	 										! motor is not disable when left limit signal rising.
FDEF(Z4_axis).#SRL = 0	 										! disable software right limit response
FDEF(Z4_axis).#SLL = 0	 										! disable software left limit response
Z4_HiwinDriveHmVel = Z4_HmVel/Z4_ControlUnit
Z4_HiwinDriveIndVel = Z4_IndVel/Z4_ControlUnit
Z4_HiwinDriveHmOffset = Z4_HmOffset/Z4_ControlUnit
Z4_HiwinDriveHmAcc = ACC(Z4_axis)/Z4_ControlUnit

ECIN( ECGETOFFSET("Statusword",Z4_EtherCATIndex),Z4_StatusWord)  
ECOUT(ECGETOFFSET("Controlword",Z4_EtherCATIndex),Z4_ControlWord)
IF Z4_IsModeOfOperationInPDO = 1
	ECOUT(ECGETOFFSET("Mode of operation",Z4_EtherCATIndex),Z4_ModeOfOperation)
	Z4_ModeOfOperation = 6
ELSE
	COEWRITE/1 (Z4_EtherCATIndex,0x6060,0,6) !6 is Homing mode  
END  


COEWRITE/1 (Z4_EtherCATIndex,0x6098,0,Z4_InternalHmType)	
COEWRITE/4 (Z4_EtherCATIndex,0x6099,1,Z4_HiwinDriveHmVel) 	
COEWRITE/4 (Z4_EtherCATIndex,0x6099,2,Z4_HiwinDriveIndVel)	
COEWRITE/4 (Z4_EtherCATIndex,0x609A,0,Z4_HiwinDriveHmAcc)	
COEWRITE/4 (Z4_EtherCATIndex,0x607C,0,Z4_HiwinDriveHmOffset) 	

Z4_ControlWord=6  
TILL Z4_StatusWord.0=1  
Z4_ControlWord=7  
TILL Z4_StatusWord.0=1 & Z4_StatusWord.1=1

WAIT 200 

Z4_ControlWord=15  
TILL Z4_StatusWord.0=1 & Z4_StatusWord.1=1 & Z4_StatusWord.2=1	!Enabled
!Start Homing Procedure - Bit 4  
Z4_ControlWord=31  											!Start Home
TILL Z4_StatusWord.12=1 & Z4_StatusWord.10=1 | Z4_StatusWord.13=1				!Home Finished

IF Z4_StatusWord.13=1
	CALL HomeFail
END


Z4_ControlWord=0  

WAIT 100

IF Z4_IsModeOfOperationInPDO = 1
	Z4_ModeOfOperation = 8 
	WAIT 500 
	ECUNMAPOUT (ECGETOFFSET("Mode of operation",Z4_EtherCATIndex))
ELSE
	COEWRITE/1 (Z4_EtherCATIndex,0x6060,0,8)						!go back to CSP mode 
END  
WAIT 500 
ECUNMAPIN (ECGETOFFSET("Statusword",Z4_EtherCATIndex))
ECUNMAPOUT (ECGETOFFSET("Controlword",Z4_EtherCATIndex))

WAIT 500 
DISABLE Z4_axis
TILL ^MST(Z4_axis).#ENABLED 

RET
STOP
!!*************************************************************************************************************************************!!
!!****************************************************** Error Compensation Process ***************************************************!!
Z4_ErrorCompensation:
!---------- Z4_axis Error Compensation Table ------------!
Z4_ErrTable(0)=	0	;
Z4_ErrTable(1)=	-2.9	;
Z4_ErrTable(2)=	-1.8	;
Z4_ErrTable(3)=	-1.2	;
Z4_ErrTable(4)=	-0.3	;
Z4_ErrTable(5)=	1.3	;
Z4_ErrTable(6)=	3.3	;
Z4_ErrTable(7)=	4.6	;
Z4_ErrTable(8)=	6	;
Z4_ErrTable(9)=	5.2	;
Z4_ErrTable(10)=3.6	;


!-------------------------------------------------------!
Z4_ErrTableIndex = 0
WHILE Z4_ErrTableIndex < SIZEOF(Z4_ErrTable)
	Z4_ErrTable(Z4_ErrTableIndex) = -Z4_ErrTable(Z4_ErrTableIndex)
	Z4_ErrTableIndex = Z4_ErrTableIndex + 1
END
ERRORUNMAP Z4_axis, ZONE0
ERRORMAP1D Z4_axis, ZONE0, Z4_ErrCompIniPos, Z4_ErrCompensationSpacing, Z4_ErrTable
ERRORMAPON Z4_axis, ZONE0

WAIT 500	
DISP "Cmpensation Procces's completed!"

RET 
STOP
!!#############################################################################################################################

ON MFLAGS(Z4_axis).#HOME=1 & TPOS(Z4_axis) < SLLIMIT(Z4_axis) 
	IF( FDEF(Z4_axis).#SLL=1 & FMASK(Z4_axis).#SLL=1 & ^(GMTYPE(Z4_axis)=5))
		KILL Z4_axis,5016	!Software Left Limit
		TPOS(Z4_axis)=FPOS(Z4_axis)
		DISP "TPOS(Z4_axis) < SLLIMIT(Z4_axis)"
	END
RET

ON MFLAGS(Z4_axis).#HOME=1 & TPOS(Z4_axis) > SRLIMIT(Z4_axis) 
	IF(FDEF(Z4_axis).#SRL=1 & FMASK(Z4_axis).#SRL=1 & ^(GMTYPE(Z4_axis)=5))
		KILL Z4_axis,5015	!Software Right Limit
		TPOS(Z4_axis)=FPOS(Z4_axis)
		DISP "TPOS(Z4_axis) > SRLIMIT(Z4_axis)"
	END
RET


ON MFLAGS(Z4_axis).#HOME=0 & RVEL(Z4_axis) > XVEL(Z4_axis)*0.5 & ^MST(Z4_axis).#INPOS
	IMM VEL(Z4_axis) = XVEL(Z4_axis)*0.45 
RET

ON MFLAGS(Z4_axis).#HOME=0 & RVEL(Z4_axis) < -XVEL(Z4_axis)*0.5 & ^MST(Z4_axis).#INPOS
	IMM VEL(Z4_axis) = -XVEL(Z4_axis)*0.45 
RET

AUTOEXEC:
	Z4_IOIndex = 23
	MFLAGS(Z4_axis).#HOME=0
STOP

ON IN(Z4_IOIndex).0 = 1
	SAFINI(Z4_axis).#LL = 1
RET

ON IN(Z4_IOIndex).0 = 0
	SAFINI(Z4_axis).#LL = 0
RET

ON IN(Z4_IOIndex).1 = 1
	SAFINI(Z4_axis).#RL = 1
RET

ON IN(Z4_IOIndex).1 = 0
	SAFINI(Z4_axis).#RL = 0
RET

!ON MST(Z4_axis).#ENABLED & (IN(Z4_IOIndex).24 = 1 | IN(Z4_IOIndex).25 = 1)
!	KILL Z4_axis
!	TILL ^MST(Z4_axis).#MOVE,500 
!	DISABLE Z4_axis,5028		!Safe Torque Off
!	TILL ^MST(Z4_axis).#ENABLED
!RET	

ON IN(Z4_IOIndex).24 = 1 | IN(Z4_IOIndex).25 = 1
    DISP"Z4_Event Time : %d",TIME
 	DISP"Z4_CHECK SF1 Value : %d",IN(Z4_IOIndex).24
	DISP"Z4_CHECK SF2 Value : %d",IN(Z4_IOIndex).25
	WAIT 5
	DISP"Z4_CHECK FAULT Value : %d", SAFIN(Z4_axis).9
	DISP"Z4_CHECK E1 FAULT : %d",AxisErrorCode34
RET	

HomeFail:
DISP" E1 homing fail "
IF Z4_IsModeOfOperationInPDO = 1
	Z4_ModeOfOperation = 8 
	WAIT 500 
	ECUNMAPOUT (ECGETOFFSET("Mode of operation",Z4_EtherCATIndex))
ELSE
	COEWRITE/1 (Z4_EtherCATIndex,0x6060,0,8)						!go back to CSP mode 
END  
WAIT 500 
ECUNMAPIN (ECGETOFFSET("Statusword",Z4_EtherCATIndex))
ECUNMAPOUT (ECGETOFFSET("Controlword",Z4_EtherCATIndex))

STOP
#25
!PNAME=
!PDESC=
! Y4_1_axis Single-axis_Hiwin_Drive_Homing_Process_VER1.5
!!****** Setting Parameter ******!!
LOCAL REAL Y4_1_HmType,Y4_1_multi_indHm,Y4_1_multi_indVel
LOCAL REAL Y4_1_HmVel,Y4_1_IndVel,Y4_1_HmOffset	
LOCAL INT Y4_1_ErrCompensation,Y4_1_ErrCompensationSpacing,Y4_1_ErrCompIniPos
LOCAL INT ZONE0,Y4_1_ErrTableIndex
LOCAL INT Y4_1_HiwinDriveHome,Y4_1_EtherCATIndex,Y4_1_InternalHmType
LOCAL REAL Y4_1_ControlUnit
LOCAL INT Y4_1_IsModeOfOperationInPDO
LOCAL REAL Y4_1_HiwinDriveHmVel,Y4_1_HiwinDriveIndVel,Y4_1_HiwinDriveHmOffset,Y4_1_HiwinDriveHmAcc
LOCAL INT Y4_1_OffSet !2023.11.14
!!################ Basic Settings ######################################################################################################
Y4_1_IOIndex = 24                           !2023.11.30
Y4_1_HmType = 0 								!the method of homing
           									!value 0 : Customized homing
           									!	   1 : find the left limit in negative direction,then find index in positive direction 
           									!      2 : find index in positive direction directly 
Y4_1_HmOffset = 0 								! Y4_1_HmOffset (unit)
Y4_1_HmVel = 10000								! the velocity for homing 	
Y4_1_IndVel = 50 								! the velocity for finding index

Y4_1_multi_indHm=0								! multi index structure
											! value 0 : nomal Homing
											!	    1 : find the left limit in negative direction,then slowing leave the limit in positive direction,
											!			then slowing find the left limit in negative direction,then slowing find index in positive direction
Y4_1_multi_indVel = 100						! (Do not modify)homing velocity of multi index structure
Y4_1_OffSet = 0                             !2023.11.14
!!*********************************** With Hiwin Drive homing support HmType 1&2************************************!!
Y4_1_IsModeOfOperationInPDO = 0					! Check #ETHERCAT if include Mode of operation slect 1 else select 0
Y4_1_HiwinDriveHome = 1						! 1 : With E1 internal homing ; 2 : With E1 Touch probe homing 
Y4_1_EtherCATIndex = 22							! EtherCAT nod index
Y4_1_ControlUnit = 0.01/8388608							! E1 Control unit
Y4_1_IOIndex = 24
!!**************** Configuration of 1D Error Compensation*****************************************************!!
Y4_1_ErrCompensation =  0 !1						! 0 : without compensation  ; 1 : turn on the compensation after homing completed 
Y4_1_ErrCompIniPos = 0							! the initial position of error compensation
Y4_1_ErrCompensationSpacing = 75000				! setting the spacing for error compensation 
!!**********************************************************************************************************!!
!!######################################################################################################################################## 

!!**************************************************************************************************************************************!!
!!************************************************************ Main program ************************************************************!!
FCLEAR Y4_1_axis
IF Y4_1_HmType=0	
	MFLAGS(Y4_1_axis).#HOME=0												! Customized homing
	CALL Y4_1_HmType0	
ELSEIF Y4_1_HiwinDriveHome=1										! E1 internal
	MFLAGS(Y4_1_axis).#HOME=0	
	IF Y4_1_HmType=1
		Y4_1_InternalHmType = 1
	ELSEIF Y4_1_HmType=2
		Y4_1_InternalHmType = 34
	ELSE
		DISP"ERROR:The value of Y4_1_HmType is invalid!!"
		STOP
	END
	CALL Y4_1_HiwinDriveInternalHmType	
ELSEIF Y4_1_HiwinDriveHome=2										! Touch probe
		MFLAGS(Y4_1_axis).#HOME=0	
	IF Y4_1_HmType=1
		CALL Y4_1_HiwinDriveTouchProbeHmType1
	ELSEIF Y4_1_HmType=2
		CALL Y4_1_HiwinDriveTouchProbeHmType2
	ELSE
		DISP"ERROR:The value of Y4_1_HmType is invalid!!"
		STOP
	END
ELSE
	DISP"ERROR:The value of Y4_1_HmType or Y4_1_HiwinDriveHome is invalid!!"
	STOP
END

IF Y4_1_ErrCompensation = 1
	DISP "Enable the compensation mode."
	DISP "Execute the compensation prcoess......"
	CALL Y4_1_ErrorCompensation	
ELSE
	DISP "Disable error compensation."
	ERRORUNMAP Y4_1_axis, ZONE0
END 

IF (Y4_1_HmType>=0&Y4_1_HmType<=2)
	ENABLE Y4_1_axis
	TILL MST(Y4_1_axis).#ENABLED
	WAIT 500
	DISP"Go home......"	
	!PTP/EV Y4_1_axis,0,Y4_1_HmVel	
	PTP/ERV Y4_1_axis,1000,Y4_1_HmVel
	MFLAGS(Y4_1_axis).#HOME=1
END	
FDEF(Y4_1_axis).#LL = 1	 		
FDEF(Y4_1_axis).#SRL = 1	 		
FDEF(Y4_1_axis).#SLL = 1	 
DISP"Homing successful!!"	

STOP	

!!*************************************************************************************************************************************!!
!!************************************************************ Homing process	*******************************************************!!
!Y4_1_HmType0:
!Customized
!	ENABLE Y4_1_axis
!	TILL MST(Y4_1_axis).#ENABLED
!	WAIT 500
!	DISP"Go home......"	
!	PTP/EV Y4_1_axis,0,Y4_1_HmVel	
!	MFLAGS(Y4_1_axis).#HOME=1
!RET
!STOP
!!*************************************************************************************************************************************!!
Y4_1_HmType0:
DISABLE Y4_1_axis		
TILL ^MST(Y4_1_axis).#ENABLED	
WAIT 500	
ERRORMAPOFF Y4_1_axis, -1											! Close all Y1_axis error compensation
!MFLAGS(Y4_1_axis).#GANTRY = 0	 									! turn off gantry mode (MFLAGS.25)	
FDEF(Y4_1_axis).#LL = 0	 							     			! motor is not disable when left limit signal rising.
FDEF(Y4_1_axis).#SRL = 0	 										! disable software right limit response
FDEF(Y4_1_axis).#SLL = 0	 										! disable software left limit response

ENABLE	Y4_1_axis	 
TILL MST(Y4_1_axis).#ENABLED	 
WAIT 500	
DISP"Start to find the left limit......"
JOG/V Y4_1_axis,-Y4_1_HmVel											! find the left limit in negative direction
TILL FAULT(Y4_1_axis).#LL 
HALT Y4_1_axis 
TILL ^MST(Y4_1_axis).#MOVE											! if reach left limit , stop motion
DISP"Already found the left limit!!"

DISP"Y4_1_axis Start to leave the left limte with IndVel in positive direction......"
JOG/V Y4_1_axis,Y4_1_IndVel											!leave the left limit in positive direction
TILL ^FAULT(Y4_1_axis).#LL 										    !if leave the left limit, stop motion
HALT Y4_1_axis		
TILL ^MST(Y4_1_axis).#MOVE 
DISP"Y4_1_axis already leave the left limit!!"

RET	
STOP


!------------------------------------------------------------------Y4_1_HiwinDriveTouchProbeHmType1--------------------------------------------------------------------------------------
Y4_1_HiwinDriveTouchProbeHmType1:

FCLEAR Y4_1_axis
DISABLE Y4_1_axis		
TILL ^MST(Y4_1_axis).#ENABLED	
WAIT 500	
MFLAGS(Y4_1_axis).#OPEN = 0								! Close loop control
ERRORMAPOFF Y4_1_axis, -1									! Close all axis error compensation
MFLAGS(Y4_1_axis).#GANTRY = 0								! turn off gantry mode (MFLAGS.25)	
FDEF(Y4_1_axis).#SRL = 0	 								! disable software right limit response
FDEF(Y4_1_axis).#SLL = 0	 								! disable software left limit response
FDEF(Y4_1_axis).#LL = 0	 										! motor is not disable when left limit signal rising.

ENABLE	Y4_1_axis	 
TILL MST(Y4_1_axis).#ENABLED	 
WAIT 500	
DISP"Start to find the left limit......"
JOG/V Y4_1_axis,-Y4_1_HmVel									! find the left limit in negative direction
TILL (COEREAD/4 (Y4_1_EtherCATIndex,0x60FD,0)& 1) = 1
HALT Y4_1_axis 
TILL ^MST(Y4_1_axis).#MOVE,1000							! if reach left limit , stop motion
DISP"Already found the left limit!!"

!!!!!!!!!!!!!!!!!!!!multi index Structure Homing Way!!!!!!!!!!!!!!!
IF(Y4_1_multi_indHm = 1)	
	JOG/V Y4_1_axis,Y4_1_multi_indVel							! slowing to leave the limit in negative direction
	TILL (COEREAD/4 (Y4_1_EtherCATIndex,0x60FD,0)& 1) = 0	! waiting to leave the limit
	HALT Y4_1_axis
	TILL ^MST(Y4_1_axis).#MOVE 
	Y4_1_IndVel = Y4_1_multi_indVel							! define slowing velocity to find index velocity
END
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
ECOUT(ECGETOFFSET("Touch probe function",Y4_1_EtherCATIndex),Y4_1_TouchProbFun)
WAIT 200
Y4_1_TouchProbFun = 0										!Reset Touch probe
WAIT 200
Y4_1_TouchProbFun = 17										! Start Touch probe
WAIT 200
DISP"Start to find the index in positive direction......"
JOG/V Y4_1_axis,Y4_1_IndVel									!find the index in positive direction
TILL (COEREAD/2 (Y4_1_EtherCATIndex,0x60B9,0) = 3)			!if reach index	, stop motion
HALT Y4_1_axis	
TILL ^MST(Y4_1_axis).#MOVE 
DISP"Already found the index!!"
SET FPOS(Y4_1_axis) = (COEREAD/4 (Y4_1_EtherCATIndex,0x6064,0) - COEREAD/4 (Y4_1_EtherCATIndex,0x60BA,0))*Y4_1_ControlUnit - Y4_1_HmOffset		!set index position as zero.
WAIT 500
ECUNMAPOUT (ECGETOFFSET("Touch probe function",Y4_1_EtherCATIndex))	
RET	
STOP
!------------------------------------------------------------------Y4_1_HiwinDriveTouchProbeHmType2--------------------------------------------------------------------------------------
Y4_1_HiwinDriveTouchProbeHmType2:

FCLEAR Y4_1_axis
DISABLE Y4_1_axis		
TILL ^MST(Y4_1_axis).#ENABLED	
WAIT 500	
MFLAGS(Y4_1_axis).#OPEN = 0						! Close loop control
ERRORMAPOFF Y4_1_axis, -1							! Close all axis error compensation
MFLAGS(Y4_1_axis).#GANTRY = 0	 					! turn off gantry mode (MFLAGS.25)	
FDEF(Y4_1_axis).#SRL = 0	 						! disable software right limit response
FDEF(Y4_1_axis).#SLL = 0	 						! disable software left limit response
FDEF(Y4_1_axis).#LL = 0	 										! motor is not disable when left limit signal rising.

ENABLE	Y4_1_axis	 
!!!!!!!!!!!!!!!!!!!!multi index Structure Homing Way!!!!!!!!!!!!!!!
IF(Y4_1_multi_indHm = 1)	
	Y4_1_IndVel = Y4_1_multi_indVel					! define slowing velocity to find index velocity
END
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
ECOUT(ECGETOFFSET("Touch probe function",Y4_1_EtherCATIndex),Y4_1_TouchProbFun)
WAIT 200
Y4_1_TouchProbFun = 0								!Reset Touch probe
WAIT 200
Y4_1_TouchProbFun = 17								! Start Touch probe
WAIT 200
DISP"Start to find the index in positive direction......"
JOG/V Y4_1_axis,Y4_1_IndVel							!find the index in positive direction
TILL (COEREAD/2 (Y4_1_EtherCATIndex,0x60B9,0) = 3)	!if reach index	, stop motion
HALT Y4_1_axis	
TILL ^MST(Y4_1_axis).#MOVE 
DISP"Already found the index!!"
SET FPOS(Y4_1_axis) = (COEREAD/4 (Y4_1_EtherCATIndex,0x6064,0) - COEREAD/4 (Y4_1_EtherCATIndex,0x60BA,0))*Y4_1_ControlUnit - Y4_1_HmOffset	!set index position as zero.
WAIT 500
ECUNMAPOUT (ECGETOFFSET("Touch probe function",Y4_1_EtherCATIndex))		
RET	
STOP
!------------------------------------------------------------------Y4_1_HiwinDriveInternalHmType--------------------------------------------------------------------------------------
Y4_1_HiwinDriveInternalHmType:

FCLEAR Y4_1_axis
FDEF(Y4_1_axis).#LL = 0	 										! motor is not disable when left limit signal rising.
FDEF(Y4_1_axis).#SRL = 0	 										! disable software right limit response
FDEF(Y4_1_axis).#SLL = 0	 										! disable software left limit response
Y4_1_HiwinDriveHmVel = Y4_1_HmVel/Y4_1_ControlUnit
Y4_1_HiwinDriveIndVel = Y4_1_IndVel/Y4_1_ControlUnit
Y4_1_HiwinDriveHmOffset = Y4_1_HmOffset/Y4_1_ControlUnit
Y4_1_HiwinDriveHmAcc = ACC(Y4_1_axis)/Y4_1_ControlUnit

ECIN( ECGETOFFSET("Statusword",Y4_1_EtherCATIndex),Y4_1_StatusWord)  
ECOUT(ECGETOFFSET("Controlword",Y4_1_EtherCATIndex),Y4_1_ControlWord)
IF Y4_1_IsModeOfOperationInPDO = 1
	ECOUT(ECGETOFFSET("Mode of operation",Y4_1_EtherCATIndex),Y4_1_ModeOfOperation)
	Y4_1_ModeOfOperation = 6
ELSE
	COEWRITE/1 (Y4_1_EtherCATIndex,0x6060,0,6) !6 is Homing mode  
END  


COEWRITE/1 (Y4_1_EtherCATIndex,0x6098,0,Y4_1_InternalHmType)	
COEWRITE/4 (Y4_1_EtherCATIndex,0x6099,1,Y4_1_HiwinDriveHmVel) 	
COEWRITE/4 (Y4_1_EtherCATIndex,0x6099,2,Y4_1_HiwinDriveIndVel)	
COEWRITE/4 (Y4_1_EtherCATIndex,0x609A,0,Y4_1_HiwinDriveHmAcc)	
COEWRITE/4 (Y4_1_EtherCATIndex,0x607C,0,Y4_1_HiwinDriveHmOffset) 	

Y4_1_ControlWord=6  
TILL Y4_1_StatusWord.0=1  
Y4_1_ControlWord=7  
TILL Y4_1_StatusWord.0=1 & Y4_1_StatusWord.1=1

WAIT 200 

Y4_1_ControlWord=15  
TILL Y4_1_StatusWord.0=1 & Y4_1_StatusWord.1=1 & Y4_1_StatusWord.2=1	!Enabled
!Start Homing Procedure - Bit 4  
Y4_1_ControlWord=31  											!Start Home
TILL Y4_1_StatusWord.12=1 & Y4_1_StatusWord.10=1 | Y4_1_StatusWord.13=1				!Home Finished

IF Y4_1_StatusWord.13=1
	CALL HomeFail
END


Y4_1_ControlWord=0  

WAIT 100

IF Y4_1_IsModeOfOperationInPDO = 1
	Y4_1_ModeOfOperation = 8 
	WAIT 500 
	ECUNMAPOUT (ECGETOFFSET("Mode of operation",Y4_1_EtherCATIndex))
ELSE
	COEWRITE/1 (Y4_1_EtherCATIndex,0x6060,0,8)						!go back to CSP mode 
END  
WAIT 500 
ECUNMAPIN (ECGETOFFSET("Statusword",Y4_1_EtherCATIndex))
ECUNMAPOUT (ECGETOFFSET("Controlword",Y4_1_EtherCATIndex))

WAIT 500 
DISABLE Y4_1_axis
TILL ^MST(Y4_1_axis).#ENABLED 

RET
STOP
!!*************************************************************************************************************************************!!
!!****************************************************** Error Compensation Process ***************************************************!!
Y4_1_ErrorCompensation:
!---------- Y4_1_axis Error Compensation Table ------------!
Y4_1_ErrTable(0)=	0	;
Y4_1_ErrTable(1)=	0	;
Y4_1_ErrTable(2)=	0	;
Y4_1_ErrTable(3)=	0	;
Y4_1_ErrTable(4)=	0	;
Y4_1_ErrTable(5)=	0	;
Y4_1_ErrTable(6)=	0	;
Y4_1_ErrTable(7)=	0	;
Y4_1_ErrTable(8)=	0	;
Y4_1_ErrTable(9)=	0	;
Y4_1_ErrTable(10)=	0	;


!-------------------------------------------------------!
Y4_1_ErrTableIndex = 0
WHILE Y4_1_ErrTableIndex < SIZEOF(Y4_1_ErrTable)
	Y4_1_ErrTable(Y4_1_ErrTableIndex) = -Y4_1_ErrTable(Y4_1_ErrTableIndex)
	Y4_1_ErrTableIndex = Y4_1_ErrTableIndex + 1
END
ERRORUNMAP Y4_1_axis, ZONE0
ERRORMAP1D Y4_1_axis, ZONE0, Y4_1_ErrCompIniPos, Y4_1_ErrCompensationSpacing, Y4_1_ErrTable
ERRORMAPON Y4_1_axis, ZONE0

WAIT 500	
DISP "Cmpensation Procces's completed!"

RET 
STOP
!!#############################################################################################################################

ON MFLAGS(Y4_1_axis).#HOME=1 & TPOS(Y4_1_axis) < SLLIMIT(Y4_1_axis) 
	IF( FDEF(Y4_1_axis).#SLL=1 & FMASK(Y4_1_axis).#SLL=1 & ^(GMTYPE(Y4_1_axis)=5))
		KILL Y4_1_axis,5016	!Software Left Limit
		TPOS(Y4_1_axis)=FPOS(Y4_1_axis)
		DISP "TPOS(Y4_1_axis) < SLLIMIT(Y4_1_axis)"
	END
RET

ON MFLAGS(Y4_1_axis).#HOME=1 & TPOS(Y4_1_axis) > SRLIMIT(Y4_1_axis) 
	IF(FDEF(Y4_1_axis).#SRL=1 & FMASK(Y4_1_axis).#SRL=1 & ^(GMTYPE(Y4_1_axis)=5))
		KILL Y4_1_axis,5015	!Software Right Limit
		TPOS(Y4_1_axis)=FPOS(Y4_1_axis)
		DISP "TPOS(Y4_1_axis) > SRLIMIT(Y4_1_axis)"
	END
RET


ON MFLAGS(Y4_1_axis).#HOME=0 & RVEL(Y4_1_axis) > XVEL(Y4_1_axis)*0.5 & ^MST(Y4_1_axis).#INPOS
	IMM VEL(Y4_1_axis) = XVEL(Y4_1_axis)*0.45 
RET

ON MFLAGS(Y4_1_axis).#HOME=0 & RVEL(Y4_1_axis) < -XVEL(Y4_1_axis)*0.5 & ^MST(Y4_1_axis).#INPOS
	IMM VEL(Y4_1_axis) = -XVEL(Y4_1_axis)*0.45 
RET

AUTOEXEC:
	Y4_1_IOIndex = 24
	MFLAGS(Y4_1_axis).#HOME=0
STOP

ON IN(Y4_1_IOIndex).0 = 1
	SAFINI(Y4_1_axis).#LL = 1
RET

ON IN(Y4_1_IOIndex).0 = 0
	SAFINI(Y4_1_axis).#LL = 0
RET

ON IN(Y4_1_IOIndex).1 = 1
	SAFINI(Y4_1_axis).#RL = 1
RET

ON IN(Y4_1_IOIndex).1 = 0
	SAFINI(Y4_1_axis).#RL = 0
RET

!ON MST(Y4_1_axis).#ENABLED & (IN(Y4_1_IOIndex).24 = 1 | IN(Y4_1_IOIndex).25 = 1)
!	KILL Y4_1_axis
!	TILL ^MST(Y4_1_axis).#MOVE,500 
!	DISABLE Y4_1_axis,5028		!Safe Torque Off
!	TILL ^MST(Y4_1_axis).#ENABLED
!RET	

ON IN(Y4_1_IOIndex).24 = 1 | IN(Y4_1_IOIndex).25 = 1
    DISP"Y4_1_Event Time : %d",TIME
 	DISP"Y4_1_CHECK SF1 Value : %d",IN(Y4_1_IOIndex).24
	DISP"Y4_1_CHECK SF2 Value : %d",IN(Y4_1_IOIndex).25
	WAIT 5
	DISP"Y4_1_CHECK FAULT Value : %d", SAFIN(Y4_1_axis).9
	DISP"Y4_1_CHECK E1 FAULT : %d",AxisErrorCode35
RET	

HomeFail:
DISP" E1 homing fail "
IF Y4_1_IsModeOfOperationInPDO = 1
	Y4_1_ModeOfOperation = 8 
	WAIT 500 
	ECUNMAPOUT (ECGETOFFSET("Mode of operation",Y4_1_EtherCATIndex))
ELSE
	COEWRITE/1 (Y4_1_EtherCATIndex,0x6060,0,8)						!go back to CSP mode 
END  
WAIT 500 
ECUNMAPIN (ECGETOFFSET("Statusword",Y4_1_EtherCATIndex))
ECUNMAPOUT (ECGETOFFSET("Controlword",Y4_1_EtherCATIndex))

STOP
#26
!PNAME=
!PDESC=
! Y4_2_axis Single-axis_Hiwin_Drive_Homing_Process_VER1.5
!!****** Setting Parameter ******!!
LOCAL REAL Y4_2_HmType,Y4_2_multi_indHm,Y4_2_multi_indVel
LOCAL REAL Y4_2_HmVel,Y4_2_IndVel,Y4_2_HmOffset	
LOCAL INT Y4_2_ErrCompensation,Y4_2_ErrCompensationSpacing,Y4_2_ErrCompIniPos
LOCAL INT ZONE0,Y4_2_ErrTableIndex
LOCAL INT Y4_2_HiwinDriveHome,Y4_2_EtherCATIndex,Y4_2_InternalHmType
LOCAL REAL Y4_2_ControlUnit
LOCAL INT Y4_2_IsModeOfOperationInPDO
LOCAL REAL Y4_2_HiwinDriveHmVel,Y4_2_HiwinDriveIndVel,Y4_2_HiwinDriveHmOffset,Y4_2_HiwinDriveHmAcc
LOCAL INT Y4_2_OffSet !2023.11.14
!!################ Basic Settings ######################################################################################################
Y4_2_IOIndex = 25                           !2023.11.30
Y4_2_HmType = 0 								!the method of homing
           									!value 0 : Customized homing
           									!	   1 : find the left limit in negative direction,then find index in positive direction 
           									!      2 : find index in positive direction directly 
Y4_2_HmOffset = 0 								! Y4_2_HmOffset (unit)
Y4_2_HmVel = 10000								! the velocity for homing 	
Y4_2_IndVel = 50 								! the velocity for finding index

Y4_2_multi_indHm=0								! multi index structure
											! value 0 : nomal Homing
											!	    1 : find the left limit in negative direction,then slowing leave the limit in positive direction,
											!			then slowing find the left limit in negative direction,then slowing find index in positive direction
Y4_2_multi_indVel = 100						! (Do not modify)homing velocity of multi index structure
Y4_2_OffSet = 0                             !2023.11.14
!!*********************************** With Hiwin Drive homing support HmType 1&2************************************!!
Y4_2_IsModeOfOperationInPDO = 0					! Check #ETHERCAT if include Mode of operation slect 1 else select 0
Y4_2_HiwinDriveHome = 1						! 1 : With E1 internal homing ; 2 : With E1 Touch probe homing 
Y4_2_EtherCATIndex = 23							! EtherCAT nod index
Y4_2_ControlUnit = 0.01/8388608							! E1 Control unit
Y4_2_IOIndex = 25
!!**************** Configuration of 1D Error Compensation*****************************************************!!
Y4_2_ErrCompensation =  0 !1						! 0 : without compensation  ; 1 : turn on the compensation after homing completed 
Y4_2_ErrCompIniPos = 0							! the initial position of error compensation
Y4_2_ErrCompensationSpacing = 75000				! setting the spacing for error compensation 
!!**********************************************************************************************************!!
!!######################################################################################################################################## 

!!**************************************************************************************************************************************!!
!!************************************************************ Main program ************************************************************!!
FCLEAR Y4_2_axis
IF Y4_2_HmType=0	
	MFLAGS(Y4_2_axis).#HOME=0												! Customized homing
	CALL Y4_2_HmType0	
ELSEIF Y4_2_HiwinDriveHome=1										! E1 internal
	MFLAGS(Y4_2_axis).#HOME=0	
	IF Y4_2_HmType=1
		Y4_2_InternalHmType = 1
	ELSEIF Y4_2_HmType=2
		Y4_2_InternalHmType = 34
	ELSE
		DISP"ERROR:The value of Y4_2_HmType is invalid!!"
		STOP
	END
	CALL Y4_2_HiwinDriveInternalHmType	
ELSEIF Y4_2_HiwinDriveHome=2										! Touch probe
		MFLAGS(Y4_2_axis).#HOME=0	
	IF Y4_2_HmType=1
		CALL Y4_2_HiwinDriveTouchProbeHmType1
	ELSEIF Y4_2_HmType=2
		CALL Y4_2_HiwinDriveTouchProbeHmType2
	ELSE
		DISP"ERROR:The value of Y4_2_HmType is invalid!!"
		STOP
	END
ELSE
	DISP"ERROR:The value of Y4_2_HmType or Y4_2_HiwinDriveHome is invalid!!"
	STOP
END

IF Y4_2_ErrCompensation = 1
	DISP "Enable the compensation mode."
	DISP "Execute the compensation prcoess......"
	CALL Y4_2_ErrorCompensation	
ELSE
	DISP "Disable error compensation."
	ERRORUNMAP Y4_2_axis, ZONE0
END 

IF (Y4_2_HmType>=0&Y4_2_HmType<=2)
	ENABLE Y4_2_axis
	TILL MST(Y4_2_axis).#ENABLED
	WAIT 500
	DISP"Go home......"	
	!PTP/EV Y4_2_axis,0,Y4_2_HmVel	
	PTP/ERV Y4_2_axis,1000,Y4_2_HmVel
	MFLAGS(Y4_2_axis).#HOME=1
END	
FDEF(Y4_2_axis).#LL = 1	 		
FDEF(Y4_2_axis).#SRL = 1	 		
FDEF(Y4_2_axis).#SLL = 1	 
DISP"Homing successful!!"	

STOP	

!!*************************************************************************************************************************************!!
!!************************************************************ Homing process	*******************************************************!!
!Y4_2_HmType0:
!Customized
!	ENABLE Y4_2_axis
!	TILL MST(Y4_2_axis).#ENABLED
!	WAIT 500
!	DISP"Go home......"	
!	PTP/EV Y4_2_axis,0,Y4_2_HmVel	
!	MFLAGS(Y4_2_axis).#HOME=1
!RET
!STOP
!!*************************************************************************************************************************************!!
Y4_2_HmType0:
DISABLE Y4_2_axis		
TILL ^MST(Y4_2_axis).#ENABLED	
WAIT 500	
ERRORMAPOFF Y4_2_axis, -1											! Close all Y1_axis error compensation
!MFLAGS(Y4_2_axis).#GANTRY = 0	 									! turn off gantry mode (MFLAGS.25)	
FDEF(Y4_2_axis).#LL = 0	 							     			! motor is not disable when left limit signal rising.
FDEF(Y4_2_axis).#SRL = 0	 										! disable software right limit response
FDEF(Y4_2_axis).#SLL = 0	 										! disable software left limit response

ENABLE	Y4_2_axis	 
TILL MST(Y4_2_axis).#ENABLED	 
WAIT 500	
DISP"Start to find the left limit......"
JOG/V Y4_2_axis,-Y4_2_HmVel											! find the left limit in negative direction
TILL FAULT(Y4_2_axis).#LL 
HALT Y4_2_axis 
TILL ^MST(Y4_2_axis).#MOVE											! if reach left limit , stop motion
DISP"Already found the left limit!!"

DISP"Y4_2_axis Start to leave the left limte with IndVel in positive direction......"
JOG/V Y4_2_axis,Y4_2_IndVel											!leave the left limit in positive direction
TILL ^FAULT(Y4_2_axis).#LL 										    !if leave the left limit, stop motion
HALT Y4_2_axis		
TILL ^MST(Y4_2_axis).#MOVE 
DISP"Y4_2_axis already leave the left limit!!"

RET	
STOP


!------------------------------------------------------------------Y4_2_HiwinDriveTouchProbeHmType1--------------------------------------------------------------------------------------
Y4_2_HiwinDriveTouchProbeHmType1:

FCLEAR Y4_2_axis
DISABLE Y4_2_axis		
TILL ^MST(Y4_2_axis).#ENABLED	
WAIT 500	
MFLAGS(Y4_2_axis).#OPEN = 0								! Close loop control
ERRORMAPOFF Y4_2_axis, -1									! Close all axis error compensation
MFLAGS(Y4_2_axis).#GANTRY = 0								! turn off gantry mode (MFLAGS.25)	
FDEF(Y4_2_axis).#SRL = 0	 								! disable software right limit response
FDEF(Y4_2_axis).#SLL = 0	 								! disable software left limit response
FDEF(Y4_2_axis).#LL = 0	 										! motor is not disable when left limit signal rising.

ENABLE	Y4_2_axis	 
TILL MST(Y4_2_axis).#ENABLED	 
WAIT 500	
DISP"Start to find the left limit......"
JOG/V Y4_2_axis,-Y4_2_HmVel									! find the left limit in negative direction
TILL (COEREAD/4 (Y4_2_EtherCATIndex,0x60FD,0)& 1) = 1
HALT Y4_2_axis 
TILL ^MST(Y4_2_axis).#MOVE,1000							! if reach left limit , stop motion
DISP"Already found the left limit!!"

!!!!!!!!!!!!!!!!!!!!multi index Structure Homing Way!!!!!!!!!!!!!!!
IF(Y4_2_multi_indHm = 1)	
	JOG/V Y4_2_axis,Y4_2_multi_indVel							! slowing to leave the limit in negative direction
	TILL (COEREAD/4 (Y4_2_EtherCATIndex,0x60FD,0)& 1) = 0	! waiting to leave the limit
	HALT Y4_2_axis
	TILL ^MST(Y4_2_axis).#MOVE 
	Y4_2_IndVel = Y4_2_multi_indVel							! define slowing velocity to find index velocity
END
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
ECOUT(ECGETOFFSET("Touch probe function",Y4_2_EtherCATIndex),Y4_2_TouchProbFun)
WAIT 200
Y4_2_TouchProbFun = 0										!Reset Touch probe
WAIT 200
Y4_2_TouchProbFun = 17										! Start Touch probe
WAIT 200
DISP"Start to find the index in positive direction......"
JOG/V Y4_2_axis,Y4_2_IndVel									!find the index in positive direction
TILL (COEREAD/2 (Y4_2_EtherCATIndex,0x60B9,0) = 3)			!if reach index	, stop motion
HALT Y4_2_axis	
TILL ^MST(Y4_2_axis).#MOVE 
DISP"Already found the index!!"
SET FPOS(Y4_2_axis) = (COEREAD/4 (Y4_2_EtherCATIndex,0x6064,0) - COEREAD/4 (Y4_2_EtherCATIndex,0x60BA,0))*Y4_2_ControlUnit - Y4_2_HmOffset		!set index position as zero.
WAIT 500
ECUNMAPOUT (ECGETOFFSET("Touch probe function",Y4_2_EtherCATIndex))	
RET	
STOP
!------------------------------------------------------------------Y4_2_HiwinDriveTouchProbeHmType2--------------------------------------------------------------------------------------
Y4_2_HiwinDriveTouchProbeHmType2:

FCLEAR Y4_2_axis
DISABLE Y4_2_axis		
TILL ^MST(Y4_2_axis).#ENABLED	
WAIT 500	
MFLAGS(Y4_2_axis).#OPEN = 0						! Close loop control
ERRORMAPOFF Y4_2_axis, -1							! Close all axis error compensation
MFLAGS(Y4_2_axis).#GANTRY = 0	 					! turn off gantry mode (MFLAGS.25)	
FDEF(Y4_2_axis).#SRL = 0	 						! disable software right limit response
FDEF(Y4_2_axis).#SLL = 0	 						! disable software left limit response
FDEF(Y4_2_axis).#LL = 0	 										! motor is not disable when left limit signal rising.

ENABLE	Y4_2_axis	 
!!!!!!!!!!!!!!!!!!!!multi index Structure Homing Way!!!!!!!!!!!!!!!
IF(Y4_2_multi_indHm = 1)	
	Y4_2_IndVel = Y4_2_multi_indVel					! define slowing velocity to find index velocity
END
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
ECOUT(ECGETOFFSET("Touch probe function",Y4_2_EtherCATIndex),Y4_2_TouchProbFun)
WAIT 200
Y4_2_TouchProbFun = 0								!Reset Touch probe
WAIT 200
Y4_2_TouchProbFun = 17								! Start Touch probe
WAIT 200
DISP"Start to find the index in positive direction......"
JOG/V Y4_2_axis,Y4_2_IndVel							!find the index in positive direction
TILL (COEREAD/2 (Y4_2_EtherCATIndex,0x60B9,0) = 3)	!if reach index	, stop motion
HALT Y4_2_axis	
TILL ^MST(Y4_2_axis).#MOVE 
DISP"Already found the index!!"
SET FPOS(Y4_2_axis) = (COEREAD/4 (Y4_2_EtherCATIndex,0x6064,0) - COEREAD/4 (Y4_2_EtherCATIndex,0x60BA,0))*Y4_2_ControlUnit - Y4_2_HmOffset	!set index position as zero.
WAIT 500
ECUNMAPOUT (ECGETOFFSET("Touch probe function",Y4_2_EtherCATIndex))		
RET	
STOP
!------------------------------------------------------------------Y4_2_HiwinDriveInternalHmType--------------------------------------------------------------------------------------
Y4_2_HiwinDriveInternalHmType:

FCLEAR Y4_2_axis
FDEF(Y4_2_axis).#LL = 0	 										! motor is not disable when left limit signal rising.
FDEF(Y4_2_axis).#SRL = 0	 										! disable software right limit response
FDEF(Y4_2_axis).#SLL = 0	 										! disable software left limit response
Y4_2_HiwinDriveHmVel = Y4_2_HmVel/Y4_2_ControlUnit
Y4_2_HiwinDriveIndVel = Y4_2_IndVel/Y4_2_ControlUnit
Y4_2_HiwinDriveHmOffset = Y4_2_HmOffset/Y4_2_ControlUnit
Y4_2_HiwinDriveHmAcc = ACC(Y4_2_axis)/Y4_2_ControlUnit

ECIN( ECGETOFFSET("Statusword",Y4_2_EtherCATIndex),Y4_2_StatusWord)  
ECOUT(ECGETOFFSET("Controlword",Y4_2_EtherCATIndex),Y4_2_ControlWord)
IF Y4_2_IsModeOfOperationInPDO = 1
	ECOUT(ECGETOFFSET("Mode of operation",Y4_2_EtherCATIndex),Y4_2_ModeOfOperation)
	Y4_2_ModeOfOperation = 6
ELSE
	COEWRITE/1 (Y4_2_EtherCATIndex,0x6060,0,6) !6 is Homing mode  
END  


COEWRITE/1 (Y4_2_EtherCATIndex,0x6098,0,Y4_2_InternalHmType)	
COEWRITE/4 (Y4_2_EtherCATIndex,0x6099,1,Y4_2_HiwinDriveHmVel) 	
COEWRITE/4 (Y4_2_EtherCATIndex,0x6099,2,Y4_2_HiwinDriveIndVel)	
COEWRITE/4 (Y4_2_EtherCATIndex,0x609A,0,Y4_2_HiwinDriveHmAcc)	
COEWRITE/4 (Y4_2_EtherCATIndex,0x607C,0,Y4_2_HiwinDriveHmOffset) 	

Y4_2_ControlWord=6  
TILL Y4_2_StatusWord.0=1  
Y4_2_ControlWord=7  
TILL Y4_2_StatusWord.0=1 & Y4_2_StatusWord.1=1

WAIT 200 

Y4_2_ControlWord=15  
TILL Y4_2_StatusWord.0=1 & Y4_2_StatusWord.1=1 & Y4_2_StatusWord.2=1	!Enabled
!Start Homing Procedure - Bit 4  
Y4_2_ControlWord=31  											!Start Home
TILL Y4_2_StatusWord.12=1 & Y4_2_StatusWord.10=1 | Y4_2_StatusWord.13=1				!Home Finished

IF Y4_2_StatusWord.13=1
	CALL HomeFail
END


Y4_2_ControlWord=0  

WAIT 100

IF Y4_2_IsModeOfOperationInPDO = 1
	Y4_2_ModeOfOperation = 8 
	WAIT 500 
	ECUNMAPOUT (ECGETOFFSET("Mode of operation",Y4_2_EtherCATIndex))
ELSE
	COEWRITE/1 (Y4_2_EtherCATIndex,0x6060,0,8)						!go back to CSP mode 
END  
WAIT 500 
ECUNMAPIN (ECGETOFFSET("Statusword",Y4_2_EtherCATIndex))
ECUNMAPOUT (ECGETOFFSET("Controlword",Y4_2_EtherCATIndex))

WAIT 500 
DISABLE Y4_2_axis
TILL ^MST(Y4_2_axis).#ENABLED 

RET
STOP
!!*************************************************************************************************************************************!!
!!****************************************************** Error Compensation Process ***************************************************!!
Y4_2_ErrorCompensation:
!---------- Y4_2_axis Error Compensation Table ------------!
Y4_2_ErrTable(0)=	0	;
Y4_2_ErrTable(1)=	0	;
Y4_2_ErrTable(2)=	0	;
Y4_2_ErrTable(3)=	0	;
Y4_2_ErrTable(4)=	0	;
Y4_2_ErrTable(5)=	0	;
Y4_2_ErrTable(6)=	0	;
Y4_2_ErrTable(7)=	0	;
Y4_2_ErrTable(8)=	0	;
Y4_2_ErrTable(9)=	0	;
Y4_2_ErrTable(10)=	0	;


!-------------------------------------------------------!
Y4_2_ErrTableIndex = 0
WHILE Y4_2_ErrTableIndex < SIZEOF(Y4_2_ErrTable)
	Y4_2_ErrTable(Y4_2_ErrTableIndex) = -Y4_2_ErrTable(Y4_2_ErrTableIndex)
	Y4_2_ErrTableIndex = Y4_2_ErrTableIndex + 1
END
ERRORUNMAP Y4_2_axis, ZONE0
ERRORMAP1D Y4_2_axis, ZONE0, Y4_2_ErrCompIniPos, Y4_2_ErrCompensationSpacing, Y4_2_ErrTable
ERRORMAPON Y4_2_axis, ZONE0

WAIT 500	
DISP "Cmpensation Procces's completed!"

RET 
STOP
!!#############################################################################################################################

ON MFLAGS(Y4_2_axis).#HOME=1 & TPOS(Y4_2_axis) < SLLIMIT(Y4_2_axis) 
	IF( FDEF(Y4_2_axis).#SLL=1 & FMASK(Y4_2_axis).#SLL=1 & ^(GMTYPE(Y4_2_axis)=5))
		KILL Y4_2_axis,5016	!Software Left Limit
		TPOS(Y4_2_axis)=FPOS(Y4_2_axis)
		DISP "TPOS(Y4_2_axis) < SLLIMIT(Y4_2_axis)"
	END
RET

ON MFLAGS(Y4_2_axis).#HOME=1 & TPOS(Y4_2_axis) > SRLIMIT(Y4_2_axis) 
	IF(FDEF(Y4_2_axis).#SRL=1 & FMASK(Y4_2_axis).#SRL=1 & ^(GMTYPE(Y4_2_axis)=5))
		KILL Y4_2_axis,5015	!Software Right Limit
		TPOS(Y4_2_axis)=FPOS(Y4_2_axis)
		DISP "TPOS(Y4_2_axis) > SRLIMIT(Y4_2_axis)"
	END
RET


ON MFLAGS(Y4_2_axis).#HOME=0 & RVEL(Y4_2_axis) > XVEL(Y4_2_axis)*0.5 & ^MST(Y4_2_axis).#INPOS
	IMM VEL(Y4_2_axis) = XVEL(Y4_2_axis)*0.45 
RET

ON MFLAGS(Y4_2_axis).#HOME=0 & RVEL(Y4_2_axis) < -XVEL(Y4_2_axis)*0.5 & ^MST(Y4_2_axis).#INPOS
	IMM VEL(Y4_2_axis) = -XVEL(Y4_2_axis)*0.45 
RET

AUTOEXEC:
	Y4_2_IOIndex = 25
	MFLAGS(Y4_2_axis).#HOME=0
STOP

ON IN(Y4_2_IOIndex).0 = 1
	SAFINI(Y4_2_axis).#LL = 1
RET

ON IN(Y4_2_IOIndex).0 = 0
	SAFINI(Y4_2_axis).#LL = 0
RET

ON IN(Y4_2_IOIndex).1 = 1
	SAFINI(Y4_2_axis).#RL = 1
RET

ON IN(Y4_2_IOIndex).1 = 0
	SAFINI(Y4_2_axis).#RL = 0
RET

!ON MST(Y4_2_axis).#ENABLED & (IN(Y4_2_IOIndex).24 = 1 | IN(Y4_2_IOIndex).25 = 1)
!	KILL Y4_2_axis
!	TILL ^MST(Y4_2_axis).#MOVE,500 
!	DISABLE Y4_2_axis,5028		!Safe Torque Off
!	TILL ^MST(Y4_2_axis).#ENABLED
!RET	

ON IN(Y4_2_IOIndex).24 = 1 | IN(Y4_2_IOIndex).25 = 1
    DISP"Y4_2_Event Time : %d",TIME
 	DISP"Y4_2_CHECK SF1 Value : %d",IN(Y4_2_IOIndex).24
	DISP"Y4_2_CHECK SF2 Value : %d",IN(Y4_2_IOIndex).25
	WAIT 5
	DISP"Y4_2_CHECK FAULT Value : %d", SAFIN(Y4_2_axis).9
	DISP"Y4_2_CHECK E1 FAULT : %d",AxisErrorCode36
RET	

HomeFail:
DISP" E1 homing fail "
IF Y4_2_IsModeOfOperationInPDO = 1
	Y4_2_ModeOfOperation = 8 
	WAIT 500 
	ECUNMAPOUT (ECGETOFFSET("Mode of operation",Y4_2_EtherCATIndex))
ELSE
	COEWRITE/1 (Y4_2_EtherCATIndex,0x6060,0,8)						!go back to CSP mode 
END  
WAIT 500 
ECUNMAPIN (ECGETOFFSET("Statusword",Y4_2_EtherCATIndex))
ECUNMAPOUT (ECGETOFFSET("Controlword",Y4_2_EtherCATIndex))

STOP
#27
!PNAME=
!PDESC=
! X4_1_axis Single-axis_Hiwin_Drive_Homing_Process_VER1.5
!!****** Setting Parameter ******!!
LOCAL REAL X4_1_HmType,X4_1_multi_indHm,X4_1_multi_indVel
LOCAL REAL X4_1_HmVel,X4_1_IndVel,X4_1_HmOffset	
LOCAL INT X4_1_ErrCompensation,X4_1_ErrCompensationSpacing,X4_1_ErrCompIniPos
LOCAL INT ZONE0,X4_1_ErrTableIndex
LOCAL INT X4_1_HiwinDriveHome,X4_1_EtherCATIndex,X4_1_InternalHmType
LOCAL REAL X4_1_ControlUnit
LOCAL INT X4_1_IsModeOfOperationInPDO
LOCAL REAL X4_1_HiwinDriveHmVel,X4_1_HiwinDriveIndVel,X4_1_HiwinDriveHmOffset,X4_1_HiwinDriveHmAcc
!!################ Basic Settings ######################################################################################################
X4_1_IOIndex = 26                           !2023.11.30
X4_1_HmType = 0 								!the method of homing
           									!value 0 : Customized homing
           									!	   1 : find the left limit in negative direction,then find index in positive direction 
           									!      2 : find index in positive direction directly 
X4_1_HmOffset = 0 								! X4_1_HmOffset (unit)
X4_1_HmVel = 10000								! the velocity for homing 	
X4_1_IndVel = 50 								! the velocity for finding index

X4_1_multi_indHm=0								! multi index structure
											! value 0 : nomal Homing
											!	    1 : find the left limit in negative direction,then slowing leave the limit in positive direction,
											!			then slowing find the left limit in negative direction,then slowing find index in positive direction
X4_1_multi_indVel = 100						! (Do not modify)homing velocity of multi index structure
!!*********************************** With Hiwin Drive homing support HmType 1&2************************************!!
X4_1_IsModeOfOperationInPDO = 0					! Check #ETHERCAT if include Mode of operation slect 1 else select 0
X4_1_HiwinDriveHome = 1						! 1 : With E1 internal homing ; 2 : With E1 Touch probe homing 
X4_1_EtherCATIndex = 24							! EtherCAT nod index
X4_1_ControlUnit = 0.01/8388608							! E1 Control unit
X4_1_IOIndex = 26
!!**************** Configuration of 1D Error Compensation*****************************************************!!
X4_1_ErrCompensation = 0						! 0 : without compensation  ; 1 : turn on the compensation after homing completed 
X4_1_ErrCompIniPos = 0							! the initial position of error compensation
X4_1_ErrCompensationSpacing = 75000				! setting the spacing for error compensation 
!!**********************************************************************************************************!!
!!######################################################################################################################################## 

!!**************************************************************************************************************************************!!
!!************************************************************ Main program ************************************************************!!
FCLEAR X4_1_axis
IF X4_1_HmType=0													! Customized homing
	MFLAGS(X4_1_axis).#HOME=0
	CALL X4_1_HmType0	
ELSEIF X4_1_HiwinDriveHome=1										! E1 internal
	MFLAGS(X4_1_axis).#HOME=0	
	IF X4_1_HmType=1
		X4_1_InternalHmType = 1
	ELSEIF X4_1_HmType=2
		X4_1_InternalHmType = 34
	ELSE
		DISP"ERROR:The value of X4_1_HmType is invalid!!"
		STOP
	END
	CALL X4_1_HiwinDriveInternalHmType	
ELSEIF X4_1_HiwinDriveHome=2										! Touch probe
		MFLAGS(X4_1_axis).#HOME=0	
	IF X4_1_HmType=1
		CALL X4_1_HiwinDriveTouchProbeHmType1
	ELSEIF X4_1_HmType=2
		CALL X4_1_HiwinDriveTouchProbeHmType2
	ELSE
		DISP"ERROR:The value of X4_1_HmType is invalid!!"
		STOP
	END
ELSE
	DISP"ERROR:The value of X4_1_HmType or X4_1_HiwinDriveHome is invalid!!"
	STOP
END

IF X4_1_ErrCompensation = 1
	DISP "Enable the compensation mode."
	DISP "Execute the compensation prcoess......"
	CALL X4_1_ErrorCompensation	
ELSE
	DISP "Disable error compensation."
	ERRORUNMAP X4_1_axis, ZONE0
END 

IF (X4_1_HmType>=0&X4_1_HmType<=2)
	ENABLE X4_1_axis
	TILL MST(X4_1_axis).#ENABLED
	WAIT 500
	DISP"Go home......"	
	PTP/ERV X4_1_axis,1000,X4_1_HmVel	
	MFLAGS(X4_1_axis).#HOME=1
END	
FDEF(X4_1_axis).#LL = 1	 		
FDEF(X4_1_axis).#SRL = 1	 		
FDEF(X4_1_axis).#SLL = 1	 
DISP"Homing successful!!"	

STOP	

!!*************************************************************************************************************************************!!
!!************************************************************ Homing process	*******************************************************!!
!X4_1_HmType0:
!Customized
!	ENABLE X4_1_axis
!	TILL MST(X4_1_axis).#ENABLED
!	WAIT 500
!	DISP"Go home......"	
!	PTP/EV X4_1_axis,0,X4_1_HmVel	
!	MFLAGS(X4_1_axis).#HOME=1
!RET
!STOP
!!*************************************************************************************************************************************!!
X4_1_HmType0:
DISABLE X4_1_axis		
TILL ^MST(X4_1_axis).#ENABLED	
WAIT 500	
ERRORMAPOFF X4_1_axis, -1											! Close all Y1_axis error compensation
!MFLAGS(X4_1_axis).#GANTRY = 0	 									! turn off gantry mode (MFLAGS.25)	
FDEF(X4_1_axis).#LL = 0	 							     			! motor is not disable when left limit signal rising.
FDEF(X4_1_axis).#SRL = 0	 										! disable software right limit response
FDEF(X4_1_axis).#SLL = 0	 										! disable software left limit response

ENABLE	X4_1_axis	 
TILL MST(X4_1_axis).#ENABLED	 
WAIT 500	
DISP"Start to find the left limit......"
JOG/V X4_1_axis,-X4_1_HmVel											! find the left limit in negative direction
TILL FAULT(X4_1_axis).#LL 
HALT X4_1_axis 
TILL ^MST(X4_1_axis).#MOVE											! if reach left limit , stop motion
DISP"Already found the left limit!!"

DISP"X4_1_axis Start to leave the left limte with IndVel in positive direction......"
JOG/V X4_1_axis,X4_1_IndVel											!leave the left limit in positive direction
TILL ^FAULT(X4_1_axis).#LL 										    !if leave the left limit, stop motion
HALT X4_1_axis		
TILL ^MST(X4_1_axis).#MOVE 
DISP"X4_1_axis already leave the left limit!!"

RET	
STOP

!------------------------------------------------------------------X4_1_HiwinDriveTouchProbeHmType1--------------------------------------------------------------------------------------
X4_1_HiwinDriveTouchProbeHmType1:

FCLEAR X4_1_axis
DISABLE X4_1_axis		
TILL ^MST(X4_1_axis).#ENABLED	
WAIT 500	
MFLAGS(X4_1_axis).#OPEN = 0								! Close loop control
ERRORMAPOFF X4_1_axis, -1									! Close all axis error compensation
MFLAGS(X4_1_axis).#GANTRY = 0								! turn off gantry mode (MFLAGS.25)	
FDEF(X4_1_axis).#SRL = 0	 								! disable software right limit response
FDEF(X4_1_axis).#SLL = 0	 								! disable software left limit response
FDEF(X4_1_axis).#LL = 0	 										! motor is not disable when left limit signal rising.

ENABLE	X4_1_axis	 
TILL MST(X4_1_axis).#ENABLED	 
WAIT 500	
DISP"Start to find the left limit......"
JOG/V X4_1_axis,-X4_1_HmVel									! find the left limit in negative direction
TILL (COEREAD/4 (X4_1_EtherCATIndex,0x60FD,0)& 1) = 1
HALT X4_1_axis 
TILL ^MST(X4_1_axis).#MOVE,1000							! if reach left limit , stop motion
DISP"Already found the left limit!!"

!!!!!!!!!!!!!!!!!!!!multi index Structure Homing Way!!!!!!!!!!!!!!!
IF(X4_1_multi_indHm = 1)	
	JOG/V X4_1_axis,X4_1_multi_indVel							! slowing to leave the limit in negative direction
	TILL (COEREAD/4 (X4_1_EtherCATIndex,0x60FD,0)& 1) = 0	! waiting to leave the limit
	HALT X4_1_axis
	TILL ^MST(X4_1_axis).#MOVE 
	X4_1_IndVel = X4_1_multi_indVel							! define slowing velocity to find index velocity
END
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
ECOUT(ECGETOFFSET("Touch probe function",X4_1_EtherCATIndex),X4_1_TouchProbFun)
WAIT 200
X4_1_TouchProbFun = 0										!Reset Touch probe
WAIT 200
X4_1_TouchProbFun = 17										! Start Touch probe
WAIT 200
DISP"Start to find the index in positive direction......"
JOG/V X4_1_axis,X4_1_IndVel									!find the index in positive direction
TILL (COEREAD/2 (X4_1_EtherCATIndex,0x60B9,0) = 3)			!if reach index	, stop motion
HALT X4_1_axis	
TILL ^MST(X4_1_axis).#MOVE 
DISP"Already found the index!!"
SET FPOS(X4_1_axis) = (COEREAD/4 (X4_1_EtherCATIndex,0x6064,0) - COEREAD/4 (X4_1_EtherCATIndex,0x60BA,0))*X4_1_ControlUnit - X4_1_HmOffset		!set index position as zero.
WAIT 500
ECUNMAPOUT (ECGETOFFSET("Touch probe function",X4_1_EtherCATIndex))	
RET	
STOP
!------------------------------------------------------------------X4_1_HiwinDriveTouchProbeHmType2--------------------------------------------------------------------------------------
X4_1_HiwinDriveTouchProbeHmType2:

FCLEAR X4_1_axis
DISABLE X4_1_axis		
TILL ^MST(X4_1_axis).#ENABLED	
WAIT 500	
MFLAGS(X4_1_axis).#OPEN = 0						! Close loop control
ERRORMAPOFF X4_1_axis, -1							! Close all axis error compensation
MFLAGS(X4_1_axis).#GANTRY = 0	 					! turn off gantry mode (MFLAGS.25)	
FDEF(X4_1_axis).#SRL = 0	 						! disable software right limit response
FDEF(X4_1_axis).#SLL = 0	 						! disable software left limit response
FDEF(X4_1_axis).#LL = 0	 										! motor is not disable when left limit signal rising.

ENABLE	X4_1_axis	 
!!!!!!!!!!!!!!!!!!!!multi index Structure Homing Way!!!!!!!!!!!!!!!
IF(X4_1_multi_indHm = 1)	
	X4_1_IndVel = X4_1_multi_indVel					! define slowing velocity to find index velocity
END
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
ECOUT(ECGETOFFSET("Touch probe function",X4_1_EtherCATIndex),X4_1_TouchProbFun)
WAIT 200
X4_1_TouchProbFun = 0								!Reset Touch probe
WAIT 200
X4_1_TouchProbFun = 17								! Start Touch probe
WAIT 200
DISP"Start to find the index in positive direction......"
JOG/V X4_1_axis,X4_1_IndVel							!find the index in positive direction
TILL (COEREAD/2 (X4_1_EtherCATIndex,0x60B9,0) = 3)	!if reach index	, stop motion
HALT X4_1_axis	
TILL ^MST(X4_1_axis).#MOVE 
DISP"Already found the index!!"
SET FPOS(X4_1_axis) = (COEREAD/4 (X4_1_EtherCATIndex,0x6064,0) - COEREAD/4 (X4_1_EtherCATIndex,0x60BA,0))*X4_1_ControlUnit - X4_1_HmOffset	!set index position as zero.
WAIT 500
ECUNMAPOUT (ECGETOFFSET("Touch probe function",X4_1_EtherCATIndex))		
RET	
STOP
!------------------------------------------------------------------X4_1_HiwinDriveInternalHmType--------------------------------------------------------------------------------------
X4_1_HiwinDriveInternalHmType:

FCLEAR X4_1_axis
FDEF(X4_1_axis).#LL = 0	 										! motor is not disable when left limit signal rising.
FDEF(X4_1_axis).#SRL = 0	 										! disable software right limit response
FDEF(X4_1_axis).#SLL = 0	 										! disable software left limit response
X4_1_HiwinDriveHmVel = X4_1_HmVel/X4_1_ControlUnit
X4_1_HiwinDriveIndVel = X4_1_IndVel/X4_1_ControlUnit
X4_1_HiwinDriveHmOffset = X4_1_HmOffset/X4_1_ControlUnit
X4_1_HiwinDriveHmAcc = ACC(X4_1_axis)/X4_1_ControlUnit

ECIN( ECGETOFFSET("Statusword",X4_1_EtherCATIndex),X4_1_StatusWord)  
ECOUT(ECGETOFFSET("Controlword",X4_1_EtherCATIndex),X4_1_ControlWord)
IF X4_1_IsModeOfOperationInPDO = 1
	ECOUT(ECGETOFFSET("Mode of operation",X4_1_EtherCATIndex),X4_1_ModeOfOperation)
	X4_1_ModeOfOperation = 6
ELSE
	COEWRITE/1 (X4_1_EtherCATIndex,0x6060,0,6) !6 is Homing mode  
END  


COEWRITE/1 (X4_1_EtherCATIndex,0x6098,0,X4_1_InternalHmType)	
COEWRITE/4 (X4_1_EtherCATIndex,0x6099,1,X4_1_HiwinDriveHmVel) 	
COEWRITE/4 (X4_1_EtherCATIndex,0x6099,2,X4_1_HiwinDriveIndVel)	
COEWRITE/4 (X4_1_EtherCATIndex,0x609A,0,X4_1_HiwinDriveHmAcc)	
COEWRITE/4 (X4_1_EtherCATIndex,0x607C,0,X4_1_HiwinDriveHmOffset) 	

X4_1_ControlWord=6  
TILL X4_1_StatusWord.0=1  
X4_1_ControlWord=7  
TILL X4_1_StatusWord.0=1 & X4_1_StatusWord.1=1

WAIT 200 

X4_1_ControlWord=15  
TILL X4_1_StatusWord.0=1 & X4_1_StatusWord.1=1 & X4_1_StatusWord.2=1	!Enabled
!Start Homing Procedure - Bit 4  
X4_1_ControlWord=31  											!Start Home
TILL X4_1_StatusWord.12=1 &X4_1_StatusWord.10=1 | X4_1_StatusWord.13=1				!Home Finished

IF X4_1_StatusWord.13=1
	CALL HomeFail
END

X4_1_ControlWord=0  

WAIT 100

IF X4_1_IsModeOfOperationInPDO = 1
	X4_1_ModeOfOperation = 8 
	WAIT 500 
	ECUNMAPOUT (ECGETOFFSET("Mode of operation",X4_1_EtherCATIndex))
ELSE
	COEWRITE/1 (X4_1_EtherCATIndex,0x6060,0,8)						!go back to CSP mode 
END  
WAIT 500 
ECUNMAPIN (ECGETOFFSET("Statusword",X4_1_EtherCATIndex))
ECUNMAPOUT (ECGETOFFSET("Controlword",X4_1_EtherCATIndex))

WAIT 500 
DISABLE X4_1_axis
TILL ^MST(X4_1_axis).#ENABLED 

RET
STOP
!!*************************************************************************************************************************************!!
!!****************************************************** Error Compensation Process ***************************************************!!
X4_1_ErrorCompensation:
!---------- X4_1_axis Error Compensation Table ------------!
X4_1_ErrTable(0)=	0	;
X4_1_ErrTable(1)=	0	;
X4_1_ErrTable(2)=	0	;
X4_1_ErrTable(3)=	0	;
X4_1_ErrTable(4)=	0	;
X4_1_ErrTable(5)=	0	;
X4_1_ErrTable(6)=	0	;
X4_1_ErrTable(7)=	0	;
X4_1_ErrTable(8)=	0	;
X4_1_ErrTable(9)=	0	;
X4_1_ErrTable(10)=	0	;


!-------------------------------------------------------!
X4_1_ErrTableIndex = 0
WHILE X4_1_ErrTableIndex < SIZEOF(X4_1_ErrTable)
	X4_1_ErrTable(X4_1_ErrTableIndex) = -X4_1_ErrTable(X4_1_ErrTableIndex)
	X4_1_ErrTableIndex = X4_1_ErrTableIndex + 1
END
ERRORUNMAP X4_1_axis, ZONE0
ERRORMAP1D X4_1_axis, ZONE0, X4_1_ErrCompIniPos, X4_1_ErrCompensationSpacing, X4_1_ErrTable
ERRORMAPON X4_1_axis, ZONE0

WAIT 500	
DISP "Cmpensation Procces's completed!"

RET 
STOP
!!#############################################################################################################################

ON MFLAGS(X4_1_axis).#HOME=1 & TPOS(X4_1_axis) < SLLIMIT(X4_1_axis) 
	IF( FDEF(X4_1_axis).#SLL=1 & FMASK(X4_1_axis).#SLL=1 & ^(GMTYPE(X4_1_axis)=5))
		KILL X4_1_axis,5016	!Software Left Limit
		TPOS(X4_1_axis)=FPOS(X4_1_axis)
		DISP "TPOS(X4_1_axis) < SLLIMIT(X4_1_axis)"
	END
RET

ON MFLAGS(X4_1_axis).#HOME=1 & TPOS(X4_1_axis) > SRLIMIT(X4_1_axis) 
	IF(FDEF(X4_1_axis).#SRL=1 & FMASK(X4_1_axis).#SRL=1 & ^(GMTYPE(X4_1_axis)=5))
		KILL X4_1_axis,5015	!Software Right Limit
		TPOS(X4_1_axis)=FPOS(X4_1_axis)
		DISP "TPOS(X4_1_axis) > SRLIMIT(X4_1_axis)"
	END
RET


ON MFLAGS(X4_1_axis).#HOME=0 & RVEL(X4_1_axis) > XVEL(X4_1_axis)*0.5 & ^MST(X4_1_axis).#INPOS
	IMM VEL(X4_1_axis) = XVEL(X4_1_axis)*0.45 
RET

ON MFLAGS(X4_1_axis).#HOME=0 & RVEL(X4_1_axis) < -XVEL(X4_1_axis)*0.5 & ^MST(X4_1_axis).#INPOS
	IMM VEL(X4_1_axis) = -XVEL(X4_1_axis)*0.45 
RET

AUTOEXEC:
	X4_1_IOIndex = 26
	MFLAGS(X4_1_axis).#HOME=0
STOP

ON IN(X4_1_IOIndex).0 = 1
	SAFINI(X4_1_axis).#LL = 1
RET

ON IN(X4_1_IOIndex).0 = 0
	SAFINI(X4_1_axis).#LL = 0
RET

ON IN(X4_1_IOIndex).1 = 1
	SAFINI(X4_1_axis).#RL = 1
RET

ON IN(X4_1_IOIndex).1 = 0
	SAFINI(X4_1_axis).#RL = 0
RET

!ON MST(X4_1_axis).#ENABLED & (IN(X4_1_IOIndex).24 = 1 | IN(X4_1_IOIndex).25 = 1)
!	KILL X4_1_axis
!	TILL ^MST(X4_1_axis).#MOVE,500 
!	DISABLE X4_1_axis,5028		!Safe Torque Off
!	TILL ^MST(X4_1_axis).#ENABLED
!RET	

ON IN(X4_1_IOIndex).24 = 1 | IN(X4_1_IOIndex).25 = 1
    DISP"X4_1_Event Time : %d",TIME
 	DISP"X4_1_CHECK SF1 Value : %d",IN(X4_1_IOIndex).24
	DISP"X4_1_CHECK SF2 Value : %d",IN(X4_1_IOIndex).25
	WAIT 5
	DISP"X4_1_CHECK FAULT Value : %d", SAFIN(X4_1_axis).9
	DISP"X4_1_CHECK E1 FAULT : %d",AxisErrorCode37
RET	

HomeFail:
DISP" E1 homing fail "
IF X4_1_IsModeOfOperationInPDO = 1
	X4_1_ModeOfOperation = 8 
	WAIT 500 
	ECUNMAPOUT (ECGETOFFSET("Mode of operation",X4_1_EtherCATIndex))
ELSE
	COEWRITE/1 (X4_1_EtherCATIndex,0x6060,0,8)						!go back to CSP mode 
END  
WAIT 500 
ECUNMAPIN (ECGETOFFSET("Statusword",X4_1_EtherCATIndex))
ECUNMAPOUT (ECGETOFFSET("Controlword",X4_1_EtherCATIndex))

STOP
#28
!PNAME=
!PDESC=
! X4_2_axis Single-axis_Hiwin_Drive_Homing_Process_VER1.5
!!****** Setting Parameter ******!!
LOCAL REAL X4_2_HmType,X4_2_multi_indHm,X4_2_multi_indVel
LOCAL REAL X4_2_HmVel,X4_2_IndVel,X4_2_HmOffset	
LOCAL INT X4_2_ErrCompensation,X4_2_ErrCompensationSpacing,X4_2_ErrCompIniPos
LOCAL INT ZONE0,X4_2_ErrTableIndex
LOCAL INT X4_2_HiwinDriveHome,X4_2_EtherCATIndex,X4_2_InternalHmType
LOCAL REAL X4_2_ControlUnit
LOCAL INT X4_2_IsModeOfOperationInPDO
LOCAL REAL X4_2_HiwinDriveHmVel,X4_2_HiwinDriveIndVel,X4_2_HiwinDriveHmOffset,X4_2_HiwinDriveHmAcc
!!################ Basic Settings ######################################################################################################
X4_2_IOIndex = 27                           !2023.11.30
X4_2_HmType = 0 								!the method of homing
           									!value 0 : Customized homing
           									!	   1 : find the left limit in negative direction,then find index in positive direction 
           									!      2 : find index in positive direction directly 
X4_2_HmOffset = 0 								! X4_2_HmOffset (unit)
X4_2_HmVel = 10000								! the velocity for homing 	
X4_2_IndVel = 50 								! the velocity for finding index

X4_2_multi_indHm=0								! multi index structure
											! value 0 : nomal Homing
											!	    1 : find the left limit in negative direction,then slowing leave the limit in positive direction,
											!			then slowing find the left limit in negative direction,then slowing find index in positive direction
X4_2_multi_indVel = 100						! (Do not modify)homing velocity of multi index structure
!!*********************************** With Hiwin Drive homing support HmType 1&2************************************!!
X4_2_IsModeOfOperationInPDO = 0					! Check #ETHERCAT if include Mode of operation slect 1 else select 0
X4_2_HiwinDriveHome = 1						! 1 : With E1 internal homing ; 2 : With E1 Touch probe homing 
X4_2_EtherCATIndex = 25							! EtherCAT nod index
X4_2_ControlUnit = 0.01/8388608							! E1 Control unit
X4_2_IOIndex = 27
!!**************** Configuration of 1D Error Compensation*****************************************************!!
X4_2_ErrCompensation = 0						! 0 : without compensation  ; 1 : turn on the compensation after homing completed 
X4_2_ErrCompIniPos = 0							! the initial position of error compensation
X4_2_ErrCompensationSpacing = 75000				! setting the spacing for error compensation 
!!**********************************************************************************************************!!
!!######################################################################################################################################## 

!!**************************************************************************************************************************************!!
!!************************************************************ Main program ************************************************************!!
FCLEAR X4_2_axis
IF X4_2_HmType=0													! Customized homing
	MFLAGS(X4_2_axis).#HOME=0
	CALL X4_2_HmType0	
ELSEIF X4_2_HiwinDriveHome=1										! E1 internal
	MFLAGS(X4_2_axis).#HOME=0	
	IF X4_2_HmType=1
		X4_2_InternalHmType = 1
	ELSEIF X4_2_HmType=2
		X4_2_InternalHmType = 34
	ELSE
		DISP"ERROR:The value of X4_2_HmType is invalid!!"
		STOP
	END
	CALL X4_2_HiwinDriveInternalHmType	
ELSEIF X4_2_HiwinDriveHome=2										! Touch probe
		MFLAGS(X4_2_axis).#HOME=0	
	IF X4_2_HmType=1
		CALL X4_2_HiwinDriveTouchProbeHmType1
	ELSEIF X4_2_HmType=2
		CALL X4_2_HiwinDriveTouchProbeHmType2
	ELSE
		DISP"ERROR:The value of X4_2_HmType is invalid!!"
		STOP
	END
ELSE
	DISP"ERROR:The value of X4_2_HmType or X4_2_HiwinDriveHome is invalid!!"
	STOP
END

IF X4_2_ErrCompensation = 1
	DISP "Enable the compensation mode."
	DISP "Execute the compensation prcoess......"
	CALL X4_2_ErrorCompensation	
ELSE
	DISP "Disable error compensation."
	ERRORUNMAP X4_2_axis, ZONE0
END 

IF (X4_2_HmType>=0&X4_2_HmType<=2)
	ENABLE X4_2_axis
	TILL MST(X4_2_axis).#ENABLED
	WAIT 500
	DISP"Go home......"	
	PTP/ERV X4_2_axis,1000,X4_2_HmVel	
	MFLAGS(X4_2_axis).#HOME=1
END	
FDEF(X4_2_axis).#LL = 1	 		
FDEF(X4_2_axis).#SRL = 1	 		
FDEF(X4_2_axis).#SLL = 1	 
DISP"Homing successful!!"	

STOP	

!!*************************************************************************************************************************************!!
!!************************************************************ Homing process	*******************************************************!!
!X4_2_HmType0:
!Customized
!	ENABLE X4_2_axis
!	TILL MST(X4_2_axis).#ENABLED
!	WAIT 500
!	DISP"Go home......"	
!	PTP/EV X4_2_axis,0,X4_2_HmVel	
!	MFLAGS(X4_2_axis).#HOME=1
!RET
!STOP
!!*************************************************************************************************************************************!!
X4_2_HmType0:
DISABLE X4_2_axis		
TILL ^MST(X4_2_axis).#ENABLED	
WAIT 500	
ERRORMAPOFF X4_2_axis, -1											! Close all Y1_axis error compensation
!MFLAGS(X4_2_axis).#GANTRY = 0	 									! turn off gantry mode (MFLAGS.25)	
FDEF(X4_2_axis).#LL = 0	 							     			! motor is not disable when left limit signal rising.
FDEF(X4_2_axis).#SRL = 0	 										! disable software right limit response
FDEF(X4_2_axis).#SLL = 0	 										! disable software left limit response

ENABLE	X4_2_axis	 
TILL MST(X4_2_axis).#ENABLED	 
WAIT 500	
DISP"Start to find the left limit......"
JOG/V X4_2_axis,-X4_2_HmVel											! find the left limit in negative direction
TILL FAULT(X4_2_axis).#LL 
HALT X4_2_axis 
TILL ^MST(X4_2_axis).#MOVE											! if reach left limit , stop motion
DISP"Already found the left limit!!"

DISP"X4_2_axis Start to leave the left limte with IndVel in positive direction......"
JOG/V X4_2_axis,X4_2_IndVel											!leave the left limit in positive direction
TILL ^FAULT(X4_2_axis).#LL 										    !if leave the left limit, stop motion
HALT X4_2_axis		
TILL ^MST(X4_2_axis).#MOVE 
DISP"X4_2_axis already leave the left limit!!"

RET	
STOP

!------------------------------------------------------------------X4_2_HiwinDriveTouchProbeHmType1--------------------------------------------------------------------------------------
X4_2_HiwinDriveTouchProbeHmType1:

FCLEAR X4_2_axis
DISABLE X4_2_axis		
TILL ^MST(X4_2_axis).#ENABLED	
WAIT 500	
MFLAGS(X4_2_axis).#OPEN = 0								! Close loop control
ERRORMAPOFF X4_2_axis, -1									! Close all axis error compensation
MFLAGS(X4_2_axis).#GANTRY = 0								! turn off gantry mode (MFLAGS.25)	
FDEF(X4_2_axis).#SRL = 0	 								! disable software right limit response
FDEF(X4_2_axis).#SLL = 0	 								! disable software left limit response
FDEF(X4_2_axis).#LL = 0	 										! motor is not disable when left limit signal rising.

ENABLE	X4_2_axis	 
TILL MST(X4_2_axis).#ENABLED	 
WAIT 500	
DISP"Start to find the left limit......"
JOG/V X4_2_axis,-X4_2_HmVel									! find the left limit in negative direction
TILL (COEREAD/4 (X4_2_EtherCATIndex,0x60FD,0)& 1) = 1
HALT X4_2_axis 
TILL ^MST(X4_2_axis).#MOVE,1000							! if reach left limit , stop motion
DISP"Already found the left limit!!"

!!!!!!!!!!!!!!!!!!!!multi index Structure Homing Way!!!!!!!!!!!!!!!
IF(X4_2_multi_indHm = 1)	
	JOG/V X4_2_axis,X4_2_multi_indVel							! slowing to leave the limit in negative direction
	TILL (COEREAD/4 (X4_2_EtherCATIndex,0x60FD,0)& 1) = 0	! waiting to leave the limit
	HALT X4_2_axis
	TILL ^MST(X4_2_axis).#MOVE 
	X4_2_IndVel = X4_2_multi_indVel							! define slowing velocity to find index velocity
END
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
ECOUT(ECGETOFFSET("Touch probe function",X4_2_EtherCATIndex),X4_2_TouchProbFun)
WAIT 200
X4_2_TouchProbFun = 0										!Reset Touch probe
WAIT 200
X4_2_TouchProbFun = 17										! Start Touch probe
WAIT 200
DISP"Start to find the index in positive direction......"
JOG/V X4_2_axis,X4_2_IndVel									!find the index in positive direction
TILL (COEREAD/2 (X4_2_EtherCATIndex,0x60B9,0) = 3)			!if reach index	, stop motion
HALT X4_2_axis	
TILL ^MST(X4_2_axis).#MOVE 
DISP"Already found the index!!"
SET FPOS(X4_2_axis) = (COEREAD/4 (X4_2_EtherCATIndex,0x6064,0) - COEREAD/4 (X4_2_EtherCATIndex,0x60BA,0))*X4_2_ControlUnit - X4_2_HmOffset		!set index position as zero.
WAIT 500
ECUNMAPOUT (ECGETOFFSET("Touch probe function",X4_2_EtherCATIndex))	
RET	
STOP
!------------------------------------------------------------------X4_2_HiwinDriveTouchProbeHmType2--------------------------------------------------------------------------------------
X4_2_HiwinDriveTouchProbeHmType2:

FCLEAR X4_2_axis
DISABLE X4_2_axis		
TILL ^MST(X4_2_axis).#ENABLED	
WAIT 500	
MFLAGS(X4_2_axis).#OPEN = 0						! Close loop control
ERRORMAPOFF X4_2_axis, -1							! Close all axis error compensation
MFLAGS(X4_2_axis).#GANTRY = 0	 					! turn off gantry mode (MFLAGS.25)	
FDEF(X4_2_axis).#SRL = 0	 						! disable software right limit response
FDEF(X4_2_axis).#SLL = 0	 						! disable software left limit response
FDEF(X4_2_axis).#LL = 0	 										! motor is not disable when left limit signal rising.

ENABLE	X4_2_axis	 
!!!!!!!!!!!!!!!!!!!!multi index Structure Homing Way!!!!!!!!!!!!!!!
IF(X4_2_multi_indHm = 1)	
	X4_2_IndVel = X4_2_multi_indVel					! define slowing velocity to find index velocity
END
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
ECOUT(ECGETOFFSET("Touch probe function",X4_2_EtherCATIndex),X4_2_TouchProbFun)
WAIT 200
X4_2_TouchProbFun = 0								!Reset Touch probe
WAIT 200
X4_2_TouchProbFun = 17								! Start Touch probe
WAIT 200
DISP"Start to find the index in positive direction......"
JOG/V X4_2_axis,X4_2_IndVel							!find the index in positive direction
TILL (COEREAD/2 (X4_2_EtherCATIndex,0x60B9,0) = 3)	!if reach index	, stop motion
HALT X4_2_axis	
TILL ^MST(X4_2_axis).#MOVE 
DISP"Already found the index!!"
SET FPOS(X4_2_axis) = (COEREAD/4 (X4_2_EtherCATIndex,0x6064,0) - COEREAD/4 (X4_2_EtherCATIndex,0x60BA,0))*X4_2_ControlUnit - X4_2_HmOffset	!set index position as zero.
WAIT 500
ECUNMAPOUT (ECGETOFFSET("Touch probe function",X4_2_EtherCATIndex))		
RET	
STOP
!------------------------------------------------------------------X4_2_HiwinDriveInternalHmType--------------------------------------------------------------------------------------
X4_2_HiwinDriveInternalHmType:

FCLEAR X4_2_axis
FDEF(X4_2_axis).#LL = 0	 										! motor is not disable when left limit signal rising.
FDEF(X4_2_axis).#SRL = 0	 										! disable software right limit response
FDEF(X4_2_axis).#SLL = 0	 										! disable software left limit response
X4_2_HiwinDriveHmVel = X4_2_HmVel/X4_2_ControlUnit
X4_2_HiwinDriveIndVel = X4_2_IndVel/X4_2_ControlUnit
X4_2_HiwinDriveHmOffset = X4_2_HmOffset/X4_2_ControlUnit
X4_2_HiwinDriveHmAcc = ACC(X4_2_axis)/X4_2_ControlUnit

ECIN( ECGETOFFSET("Statusword",X4_2_EtherCATIndex),X4_2_StatusWord)  
ECOUT(ECGETOFFSET("Controlword",X4_2_EtherCATIndex),X4_2_ControlWord)
IF X4_2_IsModeOfOperationInPDO = 1
	ECOUT(ECGETOFFSET("Mode of operation",X4_2_EtherCATIndex),X4_2_ModeOfOperation)
	X4_2_ModeOfOperation = 6
ELSE
	COEWRITE/1 (X4_2_EtherCATIndex,0x6060,0,6) !6 is Homing mode  
END  


COEWRITE/1 (X4_2_EtherCATIndex,0x6098,0,X4_2_InternalHmType)	
COEWRITE/4 (X4_2_EtherCATIndex,0x6099,1,X4_2_HiwinDriveHmVel) 	
COEWRITE/4 (X4_2_EtherCATIndex,0x6099,2,X4_2_HiwinDriveIndVel)	
COEWRITE/4 (X4_2_EtherCATIndex,0x609A,0,X4_2_HiwinDriveHmAcc)	
COEWRITE/4 (X4_2_EtherCATIndex,0x607C,0,X4_2_HiwinDriveHmOffset) 	

X4_2_ControlWord=6  
TILL X4_2_StatusWord.0=1  
X4_2_ControlWord=7  
TILL X4_2_StatusWord.0=1 & X4_2_StatusWord.1=1

WAIT 200 

X4_2_ControlWord=15  
TILL X4_2_StatusWord.0=1 & X4_2_StatusWord.1=1 & X4_2_StatusWord.2=1	!Enabled
!Start Homing Procedure - Bit 4  
X4_2_ControlWord=31  											!Start Home
TILL X4_2_StatusWord.12=1 &X4_2_StatusWord.10=1 | X4_2_StatusWord.13=1				!Home Finished

IF X4_2_StatusWord.13=1
	CALL HomeFail
END

X4_2_ControlWord=0  

WAIT 100

IF X4_2_IsModeOfOperationInPDO = 1
	X4_2_ModeOfOperation = 8 
	WAIT 500 
	ECUNMAPOUT (ECGETOFFSET("Mode of operation",X4_2_EtherCATIndex))
ELSE
	COEWRITE/1 (X4_2_EtherCATIndex,0x6060,0,8)						!go back to CSP mode 
END  
WAIT 500 
ECUNMAPIN (ECGETOFFSET("Statusword",X4_2_EtherCATIndex))
ECUNMAPOUT (ECGETOFFSET("Controlword",X4_2_EtherCATIndex))

WAIT 500 
DISABLE X4_2_axis
TILL ^MST(X4_2_axis).#ENABLED 

RET
STOP
!!*************************************************************************************************************************************!!
!!****************************************************** Error Compensation Process ***************************************************!!
X4_2_ErrorCompensation:
!---------- X4_2_axis Error Compensation Table ------------!
X4_2_ErrTable(0)=	0	;
X4_2_ErrTable(1)=	0	;
X4_2_ErrTable(2)=	0	;
X4_2_ErrTable(3)=	0	;
X4_2_ErrTable(4)=	0	;
X4_2_ErrTable(5)=	0	;
X4_2_ErrTable(6)=	0	;
X4_2_ErrTable(7)=	0	;
X4_2_ErrTable(8)=	0	;
X4_2_ErrTable(9)=	0	;
X4_2_ErrTable(10)=	0	;


!-------------------------------------------------------!
X4_2_ErrTableIndex = 0
WHILE X4_2_ErrTableIndex < SIZEOF(X4_2_ErrTable)
	X4_2_ErrTable(X4_2_ErrTableIndex) = -X4_2_ErrTable(X4_2_ErrTableIndex)
	X4_2_ErrTableIndex = X4_2_ErrTableIndex + 1
END
ERRORUNMAP X4_2_axis, ZONE0
ERRORMAP1D X4_2_axis, ZONE0, X4_2_ErrCompIniPos, X4_2_ErrCompensationSpacing, X4_2_ErrTable
ERRORMAPON X4_2_axis, ZONE0

WAIT 500	
DISP "Cmpensation Procces's completed!"

RET 
STOP
!!#############################################################################################################################

ON MFLAGS(X4_2_axis).#HOME=1 & TPOS(X4_2_axis) < SLLIMIT(X4_2_axis) 
	IF( FDEF(X4_2_axis).#SLL=1 & FMASK(X4_2_axis).#SLL=1 & ^(GMTYPE(X4_2_axis)=5))
		KILL X4_2_axis,5016	!Software Left Limit
		TPOS(X4_2_axis)=FPOS(X4_2_axis)
		DISP "TPOS(X4_2_axis) < SLLIMIT(X4_2_axis)"
	END
RET

ON MFLAGS(X4_2_axis).#HOME=1 & TPOS(X4_2_axis) > SRLIMIT(X4_2_axis) 
	IF(FDEF(X4_2_axis).#SRL=1 & FMASK(X4_2_axis).#SRL=1 & ^(GMTYPE(X4_2_axis)=5))
		KILL X4_2_axis,5015	!Software Right Limit
		TPOS(X4_2_axis)=FPOS(X4_2_axis)
		DISP "TPOS(X4_2_axis) > SRLIMIT(X4_2_axis)"
	END
RET


ON MFLAGS(X4_2_axis).#HOME=0 & RVEL(X4_2_axis) > XVEL(X4_2_axis)*0.5 & ^MST(X4_2_axis).#INPOS
	IMM VEL(X4_2_axis) = XVEL(X4_2_axis)*0.45 
RET

ON MFLAGS(X4_2_axis).#HOME=0 & RVEL(X4_2_axis) < -XVEL(X4_2_axis)*0.5 & ^MST(X4_2_axis).#INPOS
	IMM VEL(X4_2_axis) = -XVEL(X4_2_axis)*0.45 
RET

AUTOEXEC:
	X4_2_IOIndex = 27
	MFLAGS(X4_2_axis).#HOME=0
STOP

ON IN(X4_2_IOIndex).0 = 1
	SAFINI(X4_2_axis).#LL = 1
RET

ON IN(X4_2_IOIndex).0 = 0
	SAFINI(X4_2_axis).#LL = 0
RET

ON IN(X4_2_IOIndex).1 = 1
	SAFINI(X4_2_axis).#RL = 1
RET

ON IN(X4_2_IOIndex).1 = 0
	SAFINI(X4_2_axis).#RL = 0
RET

!ON MST(X4_2_axis).#ENABLED & (IN(X4_2_IOIndex).24 = 1 | IN(X4_2_IOIndex).25 = 1)
!	KILL X4_2_axis
!	TILL ^MST(X4_2_axis).#MOVE,500 
!	DISABLE X4_2_axis,5028		!Safe Torque Off
!	TILL ^MST(X4_2_axis).#ENABLED
!RET	

ON IN(X4_2_IOIndex).24 = 1 | IN(X4_2_IOIndex).25 = 1
    DISP"X4_2_Event Time : %d",TIME
 	DISP"X4_2_CHECK SF1 Value : %d",IN(X4_2_IOIndex).24
	DISP"X4_2_CHECK SF2 Value : %d",IN(X4_2_IOIndex).25
	WAIT 5
	DISP"X4_2_CHECK FAULT Value : %d", SAFIN(X4_2_axis).9
	DISP"X4_2_CHECK E1 FAULT : %d",AxisErrorCode38
RET	

HomeFail:
DISP" E1 homing fail "
IF X4_2_IsModeOfOperationInPDO = 1
	X4_2_ModeOfOperation = 8 
	WAIT 500 
	ECUNMAPOUT (ECGETOFFSET("Mode of operation",X4_2_EtherCATIndex))
ELSE
	COEWRITE/1 (X4_2_EtherCATIndex,0x6060,0,8)						!go back to CSP mode 
END  
WAIT 500 
ECUNMAPIN (ECGETOFFSET("Statusword",X4_2_EtherCATIndex))
ECUNMAPOUT (ECGETOFFSET("Controlword",X4_2_EtherCATIndex))

STOP
#29
!PNAME=
!PDESC=
! Z5_1_axis Single-axis_Hiwin_Drive_Homing_Process_VER1.5
!!****** Setting Parameter ******!!
LOCAL REAL Z5_1_HmType,Z5_1_multi_indHm,Z5_1_multi_indVel
LOCAL REAL Z5_1_HmVel,Z5_1_IndVel,Z5_1_HmOffset	
LOCAL INT Z5_1_ErrCompensation,Z5_1_ErrCompensationSpacing,Z5_1_ErrCompIniPos
LOCAL INT ZONE0,Z5_1_ErrTableIndex
LOCAL INT Z5_1_HiwinDriveHome,Z5_1_EtherCATIndex,Z5_1_InternalHmType
LOCAL REAL Z5_1_ControlUnit
LOCAL INT Z5_1_IsModeOfOperationInPDO
LOCAL REAL Z5_1_HiwinDriveHmVel,Z5_1_HiwinDriveIndVel,Z5_1_HiwinDriveHmOffset,Z5_1_HiwinDriveHmAcc
!!################ Basic Settings ######################################################################################################
Z5_1_IOIndex = 28                           !2023.11.30
Z5_1_HmType = 0 								!the method of homing
           									!value 0 : Customized homing
           									!	   1 : find the left limit in negative direction,then find index in positive direction 
           									!      2 : find index in positive direction directly 
Z5_1_HmOffset = 0 								! Z5_1_HmOffset (unit)
Z5_1_HmVel = 10000								! the velocity for homing 	
Z5_1_IndVel = 50 								! the velocity for finding index

Z5_1_multi_indHm=0								! multi index structure
											! value 0 : nomal Homing
											!	    1 : find the left limit in negative direction,then slowing leave the limit in positive direction,
											!			then slowing find the left limit in negative direction,then slowing find index in positive direction
Z5_1_multi_indVel = 100						! (Do not modify)homing velocity of multi index structure
!!*********************************** With Hiwin Drive homing support HmType 1&2************************************!!
Z5_1_IsModeOfOperationInPDO = 0					! Check #ETHERCAT if include Mode of operation slect 1 else select 0
Z5_1_HiwinDriveHome = 1						! 1 : With E1 internal homing ; 2 : With E1 Touch probe homing 
Z5_1_EtherCATIndex = 26							! EtherCAT nod index
Z5_1_ControlUnit = 0.01/8388608							! E1 Control unit
Z5_1_IOIndex = 28
!!**************** Configuration of 1D Error Compensation*****************************************************!!
Z5_1_ErrCompensation = 0    !1						! 0 : without compensation  ; 1 : turn on the compensation after homing completed 
Z5_1_ErrCompIniPos = 0							! the initial position of error compensation
Z5_1_ErrCompensationSpacing = 75000				! setting the spacing for error compensation 
!!**********************************************************************************************************!!
!!######################################################################################################################################## 

!!**************************************************************************************************************************************!!
!!************************************************************ Main program ************************************************************!!
FCLEAR Z5_1_axis
IF Z5_1_HmType=0													! Customized homing
	MFLAGS(Z5_1_axis).#HOME=0
	CALL Z5_1_HmType0	
ELSEIF Z5_1_HiwinDriveHome=1										! E1 internal
	MFLAGS(Z5_1_axis).#HOME=0	
	IF Z5_1_HmType=1
		Z5_1_InternalHmType = 1
	ELSEIF Z5_1_HmType=2
		Z5_1_InternalHmType = 34
	ELSE
		DISP"ERROR:The value of Z5_1_HmType is invalid!!"
		STOP
	END
	CALL Z5_1_HiwinDriveInternalHmType	
ELSEIF Z5_1_HiwinDriveHome=2										! Touch probe
		MFLAGS(Z5_1_axis).#HOME=0	
	IF Z5_1_HmType=1
		CALL Z5_1_HiwinDriveTouchProbeHmType1
	ELSEIF Z5_1_HmType=2
		CALL Z5_1_HiwinDriveTouchProbeHmType2
	ELSE
		DISP"ERROR:The value of Z5_1_HmType is invalid!!"
		STOP
	END
ELSE
	DISP"ERROR:The value of Z5_1_HmType or Z5_1_HiwinDriveHome is invalid!!"
	STOP
END

IF Z5_1_ErrCompensation = 1
	DISP "Enable the compensation mode."
	DISP "Execute the compensation prcoess......"
	CALL Z5_1_ErrorCompensation	
ELSE
	DISP "Disable error compensation."
	ERRORUNMAP Z5_1_axis, ZONE0
END 

IF (Z5_1_HmType>=0&Z5_1_HmType<=2)
	ENABLE Z5_1_axis
	TILL MST(Z5_1_axis).#ENABLED
	WAIT 500
	DISP"Go home......"	
	!PTP/EV Z5_1_axis,0,Z5_1_HmVel	
	PTP/ERV Z5_1_axis,1000,Z5_1_HmVel
	MFLAGS(Z5_1_axis).#HOME=1
END	
FDEF(Z5_1_axis).#LL = 1	 		
FDEF(Z5_1_axis).#SRL = 1	 		
FDEF(Z5_1_axis).#SLL = 1	 
DISP"Homing successful!!"	

STOP	

!!*************************************************************************************************************************************!!
!!************************************************************ Homing process	*******************************************************!!
!Z5_1_HmType0:
!Customized
!	ENABLE Z5_1_axis
!	TILL MST(Z5_1_axis).#ENABLED
!	WAIT 500
!	DISP"Go home......"	
!	PTP/EV Z5_1_axis,0,Z5_1_HmVel	
!	MFLAGS(Z5_1_axis).#HOME=1
!RET
!STOP
!!*************************************************************************************************************************************!!
Z5_1_HmType0:
DISABLE Z5_1_axis		
TILL ^MST(Z5_1_axis).#ENABLED	
WAIT 500	
ERRORMAPOFF Z5_1_axis, -1											! Close all Y1_axis error compensation
!MFLAGS(Z5_1_axis).#GANTRY = 0	 									! turn off gantry mode (MFLAGS.25)	
FDEF(Z5_1_axis).#LL = 0	 							     			! motor is not disable when left limit signal rising.
FDEF(Z5_1_axis).#SRL = 0	 										! disable software right limit response
FDEF(Z5_1_axis).#SLL = 0	 										! disable software left limit response

ENABLE	Z5_1_axis	 
TILL MST(Z5_1_axis).#ENABLED	 
WAIT 500	
DISP"Start to find the left limit......"
JOG/V Z5_1_axis,-Z5_1_HmVel											! find the left limit in negative direction
TILL FAULT(Z5_1_axis).#LL 
HALT Z5_1_axis 
TILL ^MST(Z5_1_axis).#MOVE											! if reach left limit , stop motion
DISP"Already found the left limit!!"

DISP"Z5_1_axis Start to leave the left limte with IndVel in positive direction......"
JOG/V Z5_1_axis,Z5_1_IndVel											!leave the left limit in positive direction
TILL ^FAULT(Z5_1_axis).#LL 										    !if leave the left limit, stop motion
HALT Z5_1_axis		
TILL ^MST(Z5_1_axis).#MOVE 
DISP"Z5_1_axis already leave the left limit!!"

RET	
STOP


!------------------------------------------------------------------Z5_1_HiwinDriveTouchProbeHmType1--------------------------------------------------------------------------------------
Z5_1_HiwinDriveTouchProbeHmType1:

FCLEAR Z5_1_axis
DISABLE Z5_1_axis		
TILL ^MST(Z5_1_axis).#ENABLED	
WAIT 500	
MFLAGS(Z5_1_axis).#OPEN = 0								! Close loop control
ERRORMAPOFF Z5_1_axis, -1									! Close all axis error compensation
MFLAGS(Z5_1_axis).#GANTRY = 0								! turn off gantry mode (MFLAGS.25)	
FDEF(Z5_1_axis).#SRL = 0	 								! disable software right limit response
FDEF(Z5_1_axis).#SLL = 0	 								! disable software left limit response
FDEF(Z5_1_axis).#LL = 0	 										! motor is not disable when left limit signal rising.

ENABLE	Z5_1_axis	 
TILL MST(Z5_1_axis).#ENABLED	 
WAIT 500	
DISP"Start to find the left limit......"
JOG/V Z5_1_axis,-Z5_1_HmVel									! find the left limit in negative direction
TILL (COEREAD/4 (Z5_1_EtherCATIndex,0x60FD,0)& 1) = 1
HALT Z5_1_axis 
TILL ^MST(Z5_1_axis).#MOVE,1000							! if reach left limit , stop motion
DISP"Already found the left limit!!"

!!!!!!!!!!!!!!!!!!!!multi index Structure Homing Way!!!!!!!!!!!!!!!
IF(Z5_1_multi_indHm = 1)	
	JOG/V Z5_1_axis,Z5_1_multi_indVel							! slowing to leave the limit in negative direction
	TILL (COEREAD/4 (Z5_1_EtherCATIndex,0x60FD,0)& 1) = 0	! waiting to leave the limit
	HALT Z5_1_axis
	TILL ^MST(Z5_1_axis).#MOVE 
	Z5_1_IndVel = Z5_1_multi_indVel							! define slowing velocity to find index velocity
END
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
ECOUT(ECGETOFFSET("Touch probe function",Z5_1_EtherCATIndex),Z5_1_TouchProbFun)
WAIT 200
Z5_1_TouchProbFun = 0										!Reset Touch probe
WAIT 200
Z5_1_TouchProbFun = 17										! Start Touch probe
WAIT 200
DISP"Start to find the index in positive direction......"
JOG/V Z5_1_axis,Z5_1_IndVel									!find the index in positive direction
TILL (COEREAD/2 (Z5_1_EtherCATIndex,0x60B9,0) = 3)			!if reach index	, stop motion
HALT Z5_1_axis	
TILL ^MST(Z5_1_axis).#MOVE 
DISP"Already found the index!!"
SET FPOS(Z5_1_axis) = (COEREAD/4 (Z5_1_EtherCATIndex,0x6064,0) - COEREAD/4 (Z5_1_EtherCATIndex,0x60BA,0))*Z5_1_ControlUnit - Z5_1_HmOffset		!set index position as zero.
WAIT 500
ECUNMAPOUT (ECGETOFFSET("Touch probe function",Z5_1_EtherCATIndex))	
RET	
STOP
!------------------------------------------------------------------Z5_1_HiwinDriveTouchProbeHmType2--------------------------------------------------------------------------------------
Z5_1_HiwinDriveTouchProbeHmType2:

FCLEAR Z5_1_axis
DISABLE Z5_1_axis		
TILL ^MST(Z5_1_axis).#ENABLED	
WAIT 500	
MFLAGS(Z5_1_axis).#OPEN = 0						! Close loop control
ERRORMAPOFF Z5_1_axis, -1							! Close all axis error compensation
MFLAGS(Z5_1_axis).#GANTRY = 0	 					! turn off gantry mode (MFLAGS.25)	
FDEF(Z5_1_axis).#SRL = 0	 						! disable software right limit response
FDEF(Z5_1_axis).#SLL = 0	 						! disable software left limit response
FDEF(Z5_1_axis).#LL = 0	 										! motor is not disable when left limit signal rising.

ENABLE	Z5_1_axis	 
!!!!!!!!!!!!!!!!!!!!multi index Structure Homing Way!!!!!!!!!!!!!!!
IF(Z5_1_multi_indHm = 1)	
	Z5_1_IndVel = Z5_1_multi_indVel					! define slowing velocity to find index velocity
END
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
ECOUT(ECGETOFFSET("Touch probe function",Z5_1_EtherCATIndex),Z5_1_TouchProbFun)
WAIT 200
Z5_1_TouchProbFun = 0								!Reset Touch probe
WAIT 200
Z5_1_TouchProbFun = 17								! Start Touch probe
WAIT 200
DISP"Start to find the index in positive direction......"
JOG/V Z5_1_axis,Z5_1_IndVel							!find the index in positive direction
TILL (COEREAD/2 (Z5_1_EtherCATIndex,0x60B9,0) = 3)	!if reach index	, stop motion
HALT Z5_1_axis	
TILL ^MST(Z5_1_axis).#MOVE 
DISP"Already found the index!!"
SET FPOS(Z5_1_axis) = (COEREAD/4 (Z5_1_EtherCATIndex,0x6064,0) - COEREAD/4 (Z5_1_EtherCATIndex,0x60BA,0))*Z5_1_ControlUnit - Z5_1_HmOffset	!set index position as zero.
WAIT 500
ECUNMAPOUT (ECGETOFFSET("Touch probe function",Z5_1_EtherCATIndex))		
RET	
STOP
!------------------------------------------------------------------Z5_1_HiwinDriveInternalHmType--------------------------------------------------------------------------------------
Z5_1_HiwinDriveInternalHmType:

FCLEAR Z5_1_axis
FDEF(Z5_1_axis).#LL = 0	 										! motor is not disable when left limit signal rising.
FDEF(Z5_1_axis).#SRL = 0	 										! disable software right limit response
FDEF(Z5_1_axis).#SLL = 0	 										! disable software left limit response
Z5_1_HiwinDriveHmVel = Z5_1_HmVel/Z5_1_ControlUnit
Z5_1_HiwinDriveIndVel = Z5_1_IndVel/Z5_1_ControlUnit
Z5_1_HiwinDriveHmOffset = Z5_1_HmOffset/Z5_1_ControlUnit
Z5_1_HiwinDriveHmAcc = ACC(Z5_1_axis)/Z5_1_ControlUnit

ECIN( ECGETOFFSET("Statusword",Z5_1_EtherCATIndex),Z5_1_StatusWord)  
ECOUT(ECGETOFFSET("Controlword",Z5_1_EtherCATIndex),Z5_1_ControlWord)
IF Z5_1_IsModeOfOperationInPDO = 1
	ECOUT(ECGETOFFSET("Mode of operation",Z5_1_EtherCATIndex),Z5_1_ModeOfOperation)
	Z5_1_ModeOfOperation = 6
ELSE
	COEWRITE/1 (Z5_1_EtherCATIndex,0x6060,0,6) !6 is Homing mode  
END  


COEWRITE/1 (Z5_1_EtherCATIndex,0x6098,0,Z5_1_InternalHmType)	
COEWRITE/4 (Z5_1_EtherCATIndex,0x6099,1,Z5_1_HiwinDriveHmVel) 	
COEWRITE/4 (Z5_1_EtherCATIndex,0x6099,2,Z5_1_HiwinDriveIndVel)	
COEWRITE/4 (Z5_1_EtherCATIndex,0x609A,0,Z5_1_HiwinDriveHmAcc)	
COEWRITE/4 (Z5_1_EtherCATIndex,0x607C,0,Z5_1_HiwinDriveHmOffset) 	

Z5_1_ControlWord=6  
TILL Z5_1_StatusWord.0=1  
Z5_1_ControlWord=7  
TILL Z5_1_StatusWord.0=1 & Z5_1_StatusWord.1=1

WAIT 200 

Z5_1_ControlWord=15  
TILL Z5_1_StatusWord.0=1 & Z5_1_StatusWord.1=1 & Z5_1_StatusWord.2=1	!Enabled
!Start Homing Procedure - Bit 4  
Z5_1_ControlWord=31  											!Start Home
TILL Z5_1_StatusWord.12=1 & Z5_1_StatusWord.10=1 | Z5_1_StatusWord.13=1				!Home Finished

IF Z5_1_StatusWord.13=1
	CALL HomeFail
END

Z5_1_ControlWord=0  

WAIT 100

IF Z5_1_IsModeOfOperationInPDO = 1
	Z5_1_ModeOfOperation = 8 
	WAIT 500 
	ECUNMAPOUT (ECGETOFFSET("Mode of operation",Z5_1_EtherCATIndex))
ELSE
	COEWRITE/1 (Z5_1_EtherCATIndex,0x6060,0,8)						!go back to CSP mode 
END  
WAIT 500 
ECUNMAPIN (ECGETOFFSET("Statusword",Z5_1_EtherCATIndex))
ECUNMAPOUT (ECGETOFFSET("Controlword",Z5_1_EtherCATIndex))

WAIT 500 
DISABLE Z5_1_axis
TILL ^MST(Z5_1_axis).#ENABLED 

RET
STOP
!!*************************************************************************************************************************************!!
!!****************************************************** Error Compensation Process ***************************************************!!
Z5_1_ErrorCompensation:
!---------- Z5_1_axis Error Compensation Table ------------!
Z5_1_ErrTable(0)=	0	;
Z5_1_ErrTable(1)=	0	;
Z5_1_ErrTable(2)=	0	;
Z5_1_ErrTable(3)=	0	;
Z5_1_ErrTable(4)=	0	;
Z5_1_ErrTable(5)=	0	;
Z5_1_ErrTable(6)=	0	;
Z5_1_ErrTable(7)=	0	;
Z5_1_ErrTable(8)=	0	;
Z5_1_ErrTable(9)=	0	;
Z5_1_ErrTable(10)=	0	;


!-------------------------------------------------------!
Z5_1_ErrTableIndex = 0
WHILE Z5_1_ErrTableIndex < SIZEOF(Z5_1_ErrTable)
	Z5_1_ErrTable(Z5_1_ErrTableIndex) = -Z5_1_ErrTable(Z5_1_ErrTableIndex)
	Z5_1_ErrTableIndex = Z5_1_ErrTableIndex + 1
END
ERRORUNMAP Z5_1_axis, ZONE0
ERRORMAP1D Z5_1_axis, ZONE0, Z5_1_ErrCompIniPos, Z5_1_ErrCompensationSpacing, Z5_1_ErrTable
ERRORMAPON Z5_1_axis, ZONE0

WAIT 500	
DISP "Cmpensation Procces's completed!"

RET 
STOP
!!#############################################################################################################################

ON MFLAGS(Z5_1_axis).#HOME=1 & TPOS(Z5_1_axis) < SLLIMIT(Z5_1_axis) 
	IF( FDEF(Z5_1_axis).#SLL=1 & FMASK(Z5_1_axis).#SLL=1 & ^(GMTYPE(Z5_1_axis)=5))
		KILL Z5_1_axis,5016	!Software Left Limit
		TPOS(Z5_1_axis)=FPOS(Z5_1_axis)
		DISP "TPOS(Z5_1_axis) < SLLIMIT(Z5_1_axis)"
	END
RET

ON MFLAGS(Z5_1_axis).#HOME=1 & TPOS(Z5_1_axis) > SRLIMIT(Z5_1_axis) 
	IF(FDEF(Z5_1_axis).#SRL=1 & FMASK(Z5_1_axis).#SRL=1 & ^(GMTYPE(Z5_1_axis)=5))
		KILL Z5_1_axis,5015	!Software Right Limit
		TPOS(Z5_1_axis)=FPOS(Z5_1_axis)
		DISP "TPOS(Z5_1_axis) > SRLIMIT(Z5_1_axis)"
	END
RET


ON MFLAGS(Z5_1_axis).#HOME=0 & RVEL(Z5_1_axis) > XVEL(Z5_1_axis)*0.5 & ^MST(Z5_1_axis).#INPOS
	IMM VEL(Z5_1_axis) = XVEL(Z5_1_axis)*0.45 
RET

ON MFLAGS(Z5_1_axis).#HOME=0 & RVEL(Z5_1_axis) < -XVEL(Z5_1_axis)*0.5 & ^MST(Z5_1_axis).#INPOS
	IMM VEL(Z5_1_axis) = -XVEL(Z5_1_axis)*0.45 
RET

AUTOEXEC:
	Z5_1_IOIndex = 28
	MFLAGS(Z5_1_axis).#HOME=0
STOP

ON IN(Z5_1_IOIndex).0 = 1
	SAFINI(Z5_1_axis).#LL = 1
RET

ON IN(Z5_1_IOIndex).0 = 0
	SAFINI(Z5_1_axis).#LL = 0
RET

ON IN(Z5_1_IOIndex).1 = 1
	SAFINI(Z5_1_axis).#RL = 1
RET

ON IN(Z5_1_IOIndex).1 = 0
	SAFINI(Z5_1_axis).#RL = 0
RET

!ON MST(Z5_1_axis).#ENABLED & (IN(Z5_1_IOIndex).24 = 1 | IN(Z5_1_IOIndex).25 = 1)
!	KILL Z5_1_axis
!	TILL ^MST(Z5_1_axis).#MOVE,500 
!	DISABLE Z5_1_axis,5028		!Safe Torque Off
!	TILL ^MST(Z5_1_axis).#ENABLED
!RET	

ON IN(Z5_1_IOIndex).24 = 1 | IN(Z5_1_IOIndex).25 = 1
    DISP"Z5_1_Event Time : %d",TIME
 	DISP"Z5_1_CHECK SF1 Value : %d",IN(Z5_1_IOIndex).24
	DISP"Z5_1_CHECK SF2 Value : %d",IN(Z5_1_IOIndex).25
	WAIT 5
	DISP"Z5_1_CHECK FAULT Value : %d", SAFIN(Z5_1_axis).9
	DISP"Z5_1_CHECK E1 FAULT : %d",AxisErrorCode39
RET	

HomeFail:
DISP" E1 homing fail "
IF Z5_1_IsModeOfOperationInPDO = 1
	Z5_1_ModeOfOperation = 8 
	WAIT 500 
	ECUNMAPOUT (ECGETOFFSET("Mode of operation",Z5_1_EtherCATIndex))
ELSE
	COEWRITE/1 (Z5_1_EtherCATIndex,0x6060,0,8)						!go back to CSP mode 
END  
WAIT 500 
ECUNMAPIN (ECGETOFFSET("Statusword",Z5_1_EtherCATIndex))
ECUNMAPOUT (ECGETOFFSET("Controlword",Z5_1_EtherCATIndex))

STOP
#30
!PNAME=
!PDESC=
! Z5_2_axis Single-axis_Hiwin_Drive_Homing_Process_VER1.5
!!****** Setting Parameter ******!!
LOCAL REAL Z5_2_HmType,Z5_2_multi_indHm,Z5_2_multi_indVel
LOCAL REAL Z5_2_HmVel,Z5_2_IndVel,Z5_2_HmOffset	
LOCAL INT Z5_2_ErrCompensation,Z5_2_ErrCompensationSpacing,Z5_2_ErrCompIniPos
LOCAL INT ZONE0,Z5_2_ErrTableIndex
LOCAL INT Z5_2_HiwinDriveHome,Z5_2_EtherCATIndex,Z5_2_InternalHmType
LOCAL REAL Z5_2_ControlUnit
LOCAL INT Z5_2_IsModeOfOperationInPDO
LOCAL REAL Z5_2_HiwinDriveHmVel,Z5_2_HiwinDriveIndVel,Z5_2_HiwinDriveHmOffset,Z5_2_HiwinDriveHmAcc
!!################ Basic Settings ######################################################################################################
Z5_2_IOIndex = 29                           !2023.11.30
Z5_2_HmType = 0 								!the method of homing
           									!value 0 : Customized homing
           									!	   1 : find the left limit in negative direction,then find index in positive direction 
           									!      2 : find index in positive direction directly 
Z5_2_HmOffset = 0 								! Z5_2_HmOffset (unit)
Z5_2_HmVel = 10000								! the velocity for homing 	
Z5_2_IndVel = 50								! the velocity for finding index

Z5_2_multi_indHm=0								! multi index structure
											! value 0 : nomal Homing
											!	    1 : find the left limit in negative direction,then slowing leave the limit in positive direction,
											!			then slowing find the left limit in negative direction,then slowing find index in positive direction
Z5_2_multi_indVel = 100						! (Do not modify)homing velocity of multi index structure
!!*********************************** With Hiwin Drive homing support HmType 1&2************************************!!
Z5_2_IsModeOfOperationInPDO = 0					! Check #ETHERCAT if include Mode of operation slect 1 else select 0
Z5_2_HiwinDriveHome = 1						! 1 : With E1 internal homing ; 2 : With E1 Touch probe homing 
Z5_2_EtherCATIndex = 27							! EtherCAT nod index
Z5_2_ControlUnit = 0.01/8388608							! E1 Control unit
Z5_2_IOIndex = 29
!!**************** Configuration of 1D Error Compensation*****************************************************!!
Z5_2_ErrCompensation = 0  !1						! 0 : without compensation  ; 1 : turn on the compensation after homing completed 
Z5_2_ErrCompIniPos = 0							! the initial position of error compensation
Z5_2_ErrCompensationSpacing = 75000				! setting the spacing for error compensation 
!!**********************************************************************************************************!!
!!######################################################################################################################################## 

!!**************************************************************************************************************************************!!
!!************************************************************ Main program ************************************************************!!
FCLEAR Z5_2_axis
IF Z5_2_HmType=0													! Customized homing
	MFLAGS(Z5_2_axis).#HOME=0
	CALL Z5_2_HmType0	
ELSEIF Z5_2_HiwinDriveHome=1										! E1 internal
	MFLAGS(Z5_2_axis).#HOME=0	
	IF Z5_2_HmType=1
		Z5_2_InternalHmType = 1
	ELSEIF Z5_2_HmType=2
		Z5_2_InternalHmType = 34
	ELSE
		DISP"ERROR:The value of Z5_2_HmType is invalid!!"
		STOP
	END
	CALL Z5_2_HiwinDriveInternalHmType	
ELSEIF Z5_2_HiwinDriveHome=2										! Touch probe
		MFLAGS(Z5_2_axis).#HOME=0	
	IF Z5_2_HmType=1
		CALL Z5_2_HiwinDriveTouchProbeHmType1
	ELSEIF Z5_2_HmType=2
		CALL Z5_2_HiwinDriveTouchProbeHmType2
	ELSE
		DISP"ERROR:The value of Z5_2_HmType is invalid!!"
		STOP
	END
ELSE
	DISP"ERROR:The value of Z5_2_HmType or Z5_2_HiwinDriveHome is invalid!!"
	STOP
END

IF Z5_2_ErrCompensation = 1
	DISP "Enable the compensation mode."
	DISP "Execute the compensation prcoess......"
	CALL Z5_2_ErrorCompensation	
ELSE
	DISP "Disable error compensation."
	ERRORUNMAP Z5_2_axis, ZONE0
END 

IF (Z5_2_HmType>=0&Z5_2_HmType<=2)
	ENABLE Z5_2_axis
	TILL MST(Z5_2_axis).#ENABLED
	WAIT 500
	DISP"Go home......"	
	!PTP/EV Z5_2_axis,0,Z5_2_HmVel
	PTP/ERV Z5_2_axis,1000,Z5_2_HmVel	
	MFLAGS(Z5_2_axis).#HOME=1
END	
FDEF(Z5_2_axis).#LL = 1	 		
FDEF(Z5_2_axis).#SRL = 1	 		
FDEF(Z5_2_axis).#SLL = 1	 
DISP"Homing successful!!"	

STOP	

!!*************************************************************************************************************************************!!
!!************************************************************ Homing process	*******************************************************!!
!Z5_2_HmType0:
!	ENABLE Z5_2_axis
!	TILL MST(Z5_2_axis).#ENABLED
!	WAIT 500
!	DISP"Go home......"	
!	PTP/EV Z5_2_axis,0,Z5_2_HmVel	
!	MFLAGS(Z5_2_axis).#HOME=1
!RET
!STOP
!!*************************************************************************************************************************************!!
Z5_2_HmType0:
DISABLE Z5_2_axis		
TILL ^MST(Z5_2_axis).#ENABLED	
WAIT 500	
ERRORMAPOFF Z5_2_axis, -1											! Close all Y1_axis error compensation
!MFLAGS(Z5_2_axis).#GANTRY = 0	 									! turn off gantry mode (MFLAGS.25)	
FDEF(Z5_2_axis).#LL = 0	 							     			! motor is not disable when left limit signal rising.
FDEF(Z5_2_axis).#SRL = 0	 										! disable software right limit response
FDEF(Z5_2_axis).#SLL = 0	 										! disable software left limit response

ENABLE	Z5_2_axis	 
TILL MST(Z5_2_axis).#ENABLED	 
WAIT 500	
DISP"Start to find the left limit......"
JOG/V Z5_2_axis,-Z5_2_HmVel											! find the left limit in negative direction
TILL FAULT(Z5_2_axis).#LL 
HALT Z5_2_axis 
TILL ^MST(Z5_2_axis).#MOVE											! if reach left limit , stop motion
DISP"Already found the left limit!!"

DISP"Z5_2_axis Start to leave the left limte with IndVel in positive direction......"
JOG/V Z5_2_axis,Z5_2_IndVel											!leave the left limit in positive direction
TILL ^FAULT(Z5_2_axis).#LL 										    !if leave the left limit, stop motion
HALT Z5_2_axis		
TILL ^MST(Z5_2_axis).#MOVE 
DISP"Z5_2_axis already leave the left limit!!"

RET	
STOP

!------------------------------------------------------------------Z5_2_HiwinDriveTouchProbeHmType1--------------------------------------------------------------------------------------
Z5_2_HiwinDriveTouchProbeHmType1:

FCLEAR Z5_2_axis
DISABLE Z5_2_axis		
TILL ^MST(Z5_2_axis).#ENABLED	
WAIT 500	
MFLAGS(Z5_2_axis).#OPEN = 0								! Close loop control
ERRORMAPOFF Z5_2_axis, -1									! Close all axis error compensation
MFLAGS(Z5_2_axis).#GANTRY = 0								! turn off gantry mode (MFLAGS.25)	
FDEF(Z5_2_axis).#SRL = 0	 								! disable software right limit response
FDEF(Z5_2_axis).#SLL = 0	 								! disable software left limit response
FDEF(Z5_2_axis).#LL = 0	 										! motor is not disable when left limit signal rising.

ENABLE	Z5_2_axis	 
TILL MST(Z5_2_axis).#ENABLED	 
WAIT 500	
DISP"Start to find the left limit......"
JOG/V Z5_2_axis,-Z5_2_HmVel									! find the left limit in negative direction
TILL (COEREAD/4 (Z5_2_EtherCATIndex,0x60FD,0)& 1) = 1
HALT Z5_2_axis 
TILL ^MST(Z5_2_axis).#MOVE,1000							! if reach left limit , stop motion
DISP"Already found the left limit!!"

!!!!!!!!!!!!!!!!!!!!multi index Structure Homing Way!!!!!!!!!!!!!!!
IF(Z5_2_multi_indHm = 1)	
	JOG/V Z5_2_axis,Z5_2_multi_indVel							! slowing to leave the limit in negative direction
	TILL (COEREAD/4 (Z5_2_EtherCATIndex,0x60FD,0)& 1) = 0	! waiting to leave the limit
	HALT Z5_2_axis
	TILL ^MST(Z5_2_axis).#MOVE 
	Z5_2_IndVel = Z5_2_multi_indVel							! define slowing velocity to find index velocity
END
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
ECOUT(ECGETOFFSET("Touch probe function",Z5_2_EtherCATIndex),Z5_2_TouchProbFun)
WAIT 200
Z5_2_TouchProbFun = 0										!Reset Touch probe
WAIT 200
Z5_2_TouchProbFun = 17										! Start Touch probe
WAIT 200
DISP"Start to find the index in positive direction......"
JOG/V Z5_2_axis,Z5_2_IndVel									!find the index in positive direction
TILL (COEREAD/2 (Z5_2_EtherCATIndex,0x60B9,0) = 3)			!if reach index	, stop motion
HALT Z5_2_axis	
TILL ^MST(Z5_2_axis).#MOVE 
DISP"Already found the index!!"
SET FPOS(Z5_2_axis) = (COEREAD/4 (Z5_2_EtherCATIndex,0x6064,0) - COEREAD/4 (Z5_2_EtherCATIndex,0x60BA,0))*Z5_2_ControlUnit - Z5_2_HmOffset		!set index position as zero.
WAIT 500
ECUNMAPOUT (ECGETOFFSET("Touch probe function",Z5_2_EtherCATIndex))	
RET	
STOP
!------------------------------------------------------------------Z5_2_HiwinDriveTouchProbeHmType2--------------------------------------------------------------------------------------
Z5_2_HiwinDriveTouchProbeHmType2:

FCLEAR Z5_2_axis
DISABLE Z5_2_axis		
TILL ^MST(Z5_2_axis).#ENABLED	
WAIT 500	
MFLAGS(Z5_2_axis).#OPEN = 0						! Close loop control
ERRORMAPOFF Z5_2_axis, -1							! Close all axis error compensation
MFLAGS(Z5_2_axis).#GANTRY = 0	 					! turn off gantry mode (MFLAGS.25)	
FDEF(Z5_2_axis).#SRL = 0	 						! disable software right limit response
FDEF(Z5_2_axis).#SLL = 0	 						! disable software left limit response
FDEF(Z5_2_axis).#LL = 0	 										! motor is not disable when left limit signal rising.

ENABLE	Z5_2_axis	 
!!!!!!!!!!!!!!!!!!!!multi index Structure Homing Way!!!!!!!!!!!!!!!
IF(Z5_2_multi_indHm = 1)	
	Z5_2_IndVel = Z5_2_multi_indVel					! define slowing velocity to find index velocity
END
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
ECOUT(ECGETOFFSET("Touch probe function",Z5_2_EtherCATIndex),Z5_2_TouchProbFun)
WAIT 200
Z5_2_TouchProbFun = 0								!Reset Touch probe
WAIT 200
Z5_2_TouchProbFun = 17								! Start Touch probe
WAIT 200
DISP"Start to find the index in positive direction......"
JOG/V Z5_2_axis,Z5_2_IndVel							!find the index in positive direction
TILL (COEREAD/2 (Z5_2_EtherCATIndex,0x60B9,0) = 3)	!if reach index	, stop motion
HALT Z5_2_axis	
TILL ^MST(Z5_2_axis).#MOVE 
DISP"Already found the index!!"
SET FPOS(Z5_2_axis) = (COEREAD/4 (Z5_2_EtherCATIndex,0x6064,0) - COEREAD/4 (Z5_2_EtherCATIndex,0x60BA,0))*Z5_2_ControlUnit - Z5_2_HmOffset	!set index position as zero.
WAIT 500
ECUNMAPOUT (ECGETOFFSET("Touch probe function",Z5_2_EtherCATIndex))		
RET	
STOP
!------------------------------------------------------------------Z5_2_HiwinDriveInternalHmType--------------------------------------------------------------------------------------
Z5_2_HiwinDriveInternalHmType:

FCLEAR Z5_2_axis
FDEF(Z5_2_axis).#LL = 0	 										! motor is not disable when left limit signal rising.
FDEF(Z5_2_axis).#SRL = 0	 										! disable software right limit response
FDEF(Z5_2_axis).#SLL = 0	 										! disable software left limit response
Z5_2_HiwinDriveHmVel = Z5_2_HmVel/Z5_2_ControlUnit
Z5_2_HiwinDriveIndVel = Z5_2_IndVel/Z5_2_ControlUnit
Z5_2_HiwinDriveHmOffset = Z5_2_HmOffset/Z5_2_ControlUnit
Z5_2_HiwinDriveHmAcc = ACC(Z5_2_axis)/Z5_2_ControlUnit

ECIN( ECGETOFFSET("Statusword",Z5_2_EtherCATIndex),Z5_2_StatusWord)  
ECOUT(ECGETOFFSET("Controlword",Z5_2_EtherCATIndex),Z5_2_ControlWord)
IF Z5_2_IsModeOfOperationInPDO = 1
	ECOUT(ECGETOFFSET("Mode of operation",Z5_2_EtherCATIndex),Z5_2_ModeOfOperation)
	Z5_2_ModeOfOperation = 6
ELSE
	COEWRITE/1 (Z5_2_EtherCATIndex,0x6060,0,6) !6 is Homing mode  
END  


COEWRITE/1 (Z5_2_EtherCATIndex,0x6098,0,Z5_2_InternalHmType)	
COEWRITE/4 (Z5_2_EtherCATIndex,0x6099,1,Z5_2_HiwinDriveHmVel) 	
COEWRITE/4 (Z5_2_EtherCATIndex,0x6099,2,Z5_2_HiwinDriveIndVel)	
COEWRITE/4 (Z5_2_EtherCATIndex,0x609A,0,Z5_2_HiwinDriveHmAcc)	
COEWRITE/4 (Z5_2_EtherCATIndex,0x607C,0,Z5_2_HiwinDriveHmOffset) 	

Z5_2_ControlWord=6  
TILL Z5_2_StatusWord.0=1  
Z5_2_ControlWord=7  
TILL Z5_2_StatusWord.0=1 & Z5_2_StatusWord.1=1

WAIT 200 

Z5_2_ControlWord=15  
TILL Z5_2_StatusWord.0=1 & Z5_2_StatusWord.1=1 & Z5_2_StatusWord.2=1	!Enabled
!Start Homing Procedure - Bit 4  
Z5_2_ControlWord=31  											!Start Home
TILL Z5_2_StatusWord.12=1 & Z5_2_StatusWord.10=1 | Z5_2_StatusWord.13=1				!Home Finished

IF Z5_2_StatusWord.13=1
	CALL HomeFail
END

Z5_2_ControlWord=0  

WAIT 100

IF Z5_2_IsModeOfOperationInPDO = 1
	Z5_2_ModeOfOperation = 8 
	WAIT 500 
	ECUNMAPOUT (ECGETOFFSET("Mode of operation",Z5_2_EtherCATIndex))
ELSE
	COEWRITE/1 (Z5_2_EtherCATIndex,0x6060,0,8)						!go back to CSP mode 
END  
WAIT 500 
ECUNMAPIN (ECGETOFFSET("Statusword",Z5_2_EtherCATIndex))
ECUNMAPOUT (ECGETOFFSET("Controlword",Z5_2_EtherCATIndex))

WAIT 500 
DISABLE Z5_2_axis
TILL ^MST(Z5_2_axis).#ENABLED 

RET
STOP
!!*************************************************************************************************************************************!!
!!****************************************************** Error Compensation Process ***************************************************!!
Z5_2_ErrorCompensation:
!---------- Z5_2_axis Error Compensation Table ------------!
Z5_2_ErrTable(0)=	0	;
Z5_2_ErrTable(1)=	0	;
Z5_2_ErrTable(2)=	0	;
Z5_2_ErrTable(3)=	0	;
Z5_2_ErrTable(4)=	0	;
Z5_2_ErrTable(5)=	0	;
Z5_2_ErrTable(6)=	0	;
Z5_2_ErrTable(7)=	0	;
Z5_2_ErrTable(8)=	0	;
Z5_2_ErrTable(9)=	0	;
Z5_2_ErrTable(10)=	0	;


!-------------------------------------------------------!
Z5_2_ErrTableIndex = 0
WHILE Z5_2_ErrTableIndex < SIZEOF(Z5_2_ErrTable)
	Z5_2_ErrTable(Z5_2_ErrTableIndex) = -Z5_2_ErrTable(Z5_2_ErrTableIndex)
	Z5_2_ErrTableIndex = Z5_2_ErrTableIndex + 1
END
ERRORUNMAP Z5_2_axis, ZONE0
ERRORMAP1D Z5_2_axis, ZONE0, Z5_2_ErrCompIniPos, Z5_2_ErrCompensationSpacing, Z5_2_ErrTable
ERRORMAPON Z5_2_axis, ZONE0

WAIT 500	
DISP "Cmpensation Procces's completed!"

RET 
STOP
!!#############################################################################################################################

ON MFLAGS(Z5_2_axis).#HOME=1 & TPOS(Z5_2_axis) < SLLIMIT(Z5_2_axis) 
	IF( FDEF(Z5_2_axis).#SLL=1 & FMASK(Z5_2_axis).#SLL=1 & ^(GMTYPE(Z5_2_axis)=5))
		KILL Z5_2_axis,5016	!Software Left Limit
		TPOS(Z5_2_axis)=FPOS(Z5_2_axis)
		DISP "TPOS(Z5_2_axis) < SLLIMIT(Z5_2_axis)"
	END
RET

ON MFLAGS(Z5_2_axis).#HOME=1 & TPOS(Z5_2_axis) > SRLIMIT(Z5_2_axis) 
	IF(FDEF(Z5_2_axis).#SRL=1 & FMASK(Z5_2_axis).#SRL=1 & ^(GMTYPE(Z5_2_axis)=5))
		KILL Z5_2_axis,5015	!Software Right Limit
		TPOS(Z5_2_axis)=FPOS(Z5_2_axis)
		DISP "TPOS(Z5_2_axis) > SRLIMIT(Z5_2_axis)"
	END
RET


ON MFLAGS(Z5_2_axis).#HOME=0 & RVEL(Z5_2_axis) > XVEL(Z5_2_axis)*0.5 & ^MST(Z5_2_axis).#INPOS
	IMM VEL(Z5_2_axis) = XVEL(Z5_2_axis)*0.45 
RET

ON MFLAGS(Z5_2_axis).#HOME=0 & RVEL(Z5_2_axis) < -XVEL(Z5_2_axis)*0.5 & ^MST(Z5_2_axis).#INPOS
	IMM VEL(Z5_2_axis) = -XVEL(Z5_2_axis)*0.45 
RET

AUTOEXEC:
	Z5_2_IOIndex = 29
	MFLAGS(Z5_2_axis).#HOME=0
STOP

ON IN(Z5_2_IOIndex).0 = 1
	SAFINI(Z5_2_axis).#LL = 1
RET

ON IN(Z5_2_IOIndex).0 = 0
	SAFINI(Z5_2_axis).#LL = 0
RET

ON IN(Z5_2_IOIndex).1 = 1
	SAFINI(Z5_2_axis).#RL = 1
RET

ON IN(Z5_2_IOIndex).1 = 0
	SAFINI(Z5_2_axis).#RL = 0
RET

!ON MST(Z5_2_axis).#ENABLED & (IN(Z5_2_IOIndex).24 = 1 | IN(Z5_2_IOIndex).25 = 1)
!	KILL Z5_2_axis
!	TILL ^MST(Z5_2_axis).#MOVE,500 
!	DISABLE Z5_2_axis,5028		!Safe Torque Off
!	TILL ^MST(Z5_2_axis).#ENABLED
!RET	

ON IN(Z5_2_IOIndex).24 = 1 | IN(Z5_2_IOIndex).25 = 1
    DISP"Z5_2_Event Time : %d",TIME
 	DISP"Z5_2_CHECK SF1 Value : %d",IN(Z5_2_IOIndex).24
	DISP"Z5_2_CHECK SF2 Value : %d",IN(Z5_2_IOIndex).25
	WAIT 5
	DISP"Z5_2_CHECK FAULT Value : %d", SAFIN(Z5_2_axis).9
	DISP"Z5_2_CHECK E1 FAULT : %d",AxisErrorCode40
RET	

HomeFail:
DISP" E1 homing fail "
IF Z5_2_IsModeOfOperationInPDO = 1
	Z5_2_ModeOfOperation = 8 
	WAIT 500 
	ECUNMAPOUT (ECGETOFFSET("Mode of operation",Z5_2_EtherCATIndex))
ELSE
	COEWRITE/1 (Z5_2_EtherCATIndex,0x6060,0,8)						!go back to CSP mode 
END  
WAIT 500 
ECUNMAPIN (ECGETOFFSET("Statusword",Z5_2_EtherCATIndex))
ECUNMAPOUT (ECGETOFFSET("Controlword",Z5_2_EtherCATIndex))

STOP
#31
!PNAME=
!PDESC=
! Z6_axis Single-axis_Hiwin_Drive_Homing_Process_VER1.5
! abs
!!****** Setting Parameter ******!!
LOCAL REAL Z6_HmType,Z6_multi_indHm,Z6_multi_indVel
LOCAL REAL Z6_HmVel,Z6_IndVel,Z6_HmOffset	
LOCAL INT Z6_ErrCompensation,Z6_ErrCompensationSpacing,Z6_ErrCompIniPos
LOCAL INT ZONE0,Z6_ErrTableIndex
LOCAL INT Z6_HiwinDriveHome,Z6_EtherCATIndex,Z6_InternalHmType
LOCAL REAL Z6_ControlUnit
LOCAL INT Z6_IsModeOfOperationInPDO
LOCAL REAL Z6_HiwinDriveHmVel,Z6_HiwinDriveIndVel,Z6_HiwinDriveHmOffset,Z6_HiwinDriveHmAcc
!!################ Basic Settings ######################################################################################################
Z6_IOIndex = 30                             !2023.11.30 
Z6_HmType = 0 								!the method of homing
           									!value 0 : Customized homing
           									!	   1 : find the left limit in negative direction,then find index in positive direction 
           									!      2 : find index in positive direction directly 
Z6_HmOffset = 0 								! Z6_HmOffset (unit)
Z6_HmVel = 2000 !30000								! the velocity for homing 	
Z6_IndVel = 50  								! the velocity for finding index

Z6_multi_indHm=0								! multi index structure
											! value 0 : nomal Homing
											!	    1 : find the left limit in negative direction,then slowing leave the limit in positive direction,
											!			then slowing find the left limit in negative direction,then slowing find index in positive direction
Z6_multi_indVel = 100						! (Do not modify)homing velocity of multi index structure
!!*********************************** With Hiwin Drive homing support HmType 1&2************************************!!
Z6_IsModeOfOperationInPDO = 0					! Check #ETHERCAT if include Mode of operation slect 1 else select 0
Z6_HiwinDriveHome = 1						! 1 : With E1 internal homing ; 2 : With E1 Touch probe homing 
Z6_EtherCATIndex = 28							! EtherCAT nod index
Z6_ControlUnit = 0.01/167721.6							! E1 Control unit
Z6_IOIndex = 30
!!**************** Configuration of 1D Error Compensation*****************************************************!!
Z6_ErrCompensation = 0   !1						! 0 : without compensation  ; 1 : turn on the compensation after homing completed 
Z6_ErrCompIniPos = 0							! the initial position of error compensation
Z6_ErrCompensationSpacing = 75000				! setting the spacing for error compensation 
!!**********************************************************************************************************!!
!!######################################################################################################################################## 

!!**************************************************************************************************************************************!!
!!************************************************************ Main program ************************************************************!!
FCLEAR Z6_axis
IF Z6_HmType=0
	MFLAGS(Z6_axis).#HOME=0														! Customized homing
	CALL Z6_HmType0	
ELSEIF Z6_HiwinDriveHome=1										! E1 internal
	MFLAGS(Z6_axis).#HOME=0	
	IF Z6_HmType=1
		Z6_InternalHmType = 1
	ELSEIF Z6_HmType=2
		Z6_InternalHmType = 34
	ELSE
		DISP"ERROR:The value of Z6_HmType is invalid!!"
		STOP
	END
	CALL Z6_HiwinDriveInternalHmType	
ELSEIF Z6_HiwinDriveHome=2										! Touch probe
		MFLAGS(Z6_axis).#HOME=0	
	IF Z6_HmType=1
		CALL Z6_HiwinDriveTouchProbeHmType1
	ELSEIF Z6_HmType=2
		CALL Z6_HiwinDriveTouchProbeHmType2
	ELSE
		DISP"ERROR:The value of Z6_HmType is invalid!!"
		STOP
	END
ELSE
	DISP"ERROR:The value of Z6_HmType or Z6_HiwinDriveHome is invalid!!"
	STOP
END

IF Z6_ErrCompensation = 1
	DISP "Enable the compensation mode."
	DISP "Execute the compensation prcoess......"
	CALL Z6_ErrorCompensation	
ELSE
	DISP "Disable error compensation."
	ERRORUNMAP Z6_axis, ZONE0
END 

IF (Z6_HmType>=0&Z6_HmType<=2)
	ENABLE Z6_axis
	TILL MST(Z6_axis).#ENABLED
	WAIT 500
	DISP"Go home......"	
	!PTP/EV Z6_axis,0,Z6_HmVel	
	PTP/ERV Z6_axis,-1000,Z6_HmVel	
	MFLAGS(Z6_axis).#HOME=1
END	
FDEF(Z6_axis).#LL = 1	 
FDEF(Z6_axis).#RL = 1	!2023.12.05		
FDEF(Z6_axis).#SRL = 1	 		
FDEF(Z6_axis).#SLL = 1	 
DISP"Homing successful!!"	

STOP	

!!*************************************************************************************************************************************!!
!!************************************************************ Homing process	*******************************************************!!
!Z6_HmType0:
!	ENABLE Z6_axis
!	TILL MST(Z6_axis).#ENABLED
!	WAIT 500
!	DISP"Go home......"	
!	PTP/EV Z6_axis,0,Z6_HmVel	
!	MFLAGS(Z6_axis).#HOME=1
!RET
!STOP
!!*************************************************************************************************************************************!!
Z6_HmType0:
DISABLE Z6_axis		
TILL ^MST(Z6_axis).#ENABLED	
WAIT 500	
ERRORMAPOFF Z6_axis, -1											! Close all Y1_axis error compensation
!MFLAGS(Z6_axis).#GANTRY = 0	 									! turn off gantry mode (MFLAGS.25)	
!FDEF(Z6_axis).#LL = 0	 							     			! motor is not disable when left limit signal rising. !mark 2023.12.05
FDEF(Z6_axis).#RL = 0	 							     			! motor is not disable when left limit signal rising.   !add 2023.12.05
FDEF(Z6_axis).#SRL = 0	 										! disable software right limit response
FDEF(Z6_axis).#SLL = 0	 										! disable software left limit response

ENABLE	Z6_axis	 
TILL MST(Z6_axis).#ENABLED	 
WAIT 500	
DISP"Start to find the left limit......"
!JOG/V Z6_axis,-Z6_HmVel											! find the left limit in negative direction  !mark 2023.12.05
JOG/V Z6_axis,Z6_HmVel											    ! find the left limit in negative direction  !add 2023.12.05
!TILL FAULT(Z6_axis).#LL                                             !mark 2023.12.05
TILL FAULT(Z6_axis).#RL                                               !add 2023.12.05
HALT Z6_axis 
TILL ^MST(Z6_axis).#MOVE											! if reach left limit , stop motion
DISP"Already found the left limit!!"

DISP"Z6_axis Start to leave the left limte with IndVel in positive direction......"
!JOG/V Z6_axis,Z6_IndVel											!leave the left limit in positive direction  !mark 2023.12.05
JOG/V Z6_axis,-Z6_IndVel											  !leave the left limit in positive direction  !add 2023.12.05

!TILL ^FAULT(Z6_axis).#LL 										    !if leave the left limit, stop motion  !mark 2023.12.05
TILL ^FAULT(Z6_axis).#RL 										    !if leave the left limit, stop motion   !add 2023.12.05
HALT Z6_axis		
TILL ^MST(Z6_axis).#MOVE 
DISP"Z6_axis already leave the left limit!!"

RET	
STOP
!------------------------------------------------------------------Z6_HiwinDriveTouchProbeHmType1--------------------------------------------------------------------------------------
Z6_HiwinDriveTouchProbeHmType1:

FCLEAR Z6_axis
DISABLE Z6_axis		
TILL ^MST(Z6_axis).#ENABLED	
WAIT 500	
MFLAGS(Z6_axis).#OPEN = 0								! Close loop control
ERRORMAPOFF Z6_axis, -1									! Close all axis error compensation
MFLAGS(Z6_axis).#GANTRY = 0								! turn off gantry mode (MFLAGS.25)	
FDEF(Z6_axis).#SRL = 0	 								! disable software right limit response
FDEF(Z6_axis).#SLL = 0	 								! disable software left limit response
FDEF(Z6_axis).#LL = 0	 										! motor is not disable when left limit signal rising.

ENABLE	Z6_axis	 
TILL MST(Z6_axis).#ENABLED	 
WAIT 500	
DISP"Start to find the left limit......"
JOG/V Z6_axis,-Z6_HmVel									! find the left limit in negative direction
TILL (COEREAD/4 (Z6_EtherCATIndex,0x60FD,0)& 1) = 1
HALT Z6_axis 
TILL ^MST(Z6_axis).#MOVE,1000							! if reach left limit , stop motion
DISP"Already found the left limit!!"

!!!!!!!!!!!!!!!!!!!!multi index Structure Homing Way!!!!!!!!!!!!!!!
IF(Z6_multi_indHm = 1)	
	JOG/V Z6_axis,Z6_multi_indVel							! slowing to leave the limit in negative direction
	TILL (COEREAD/4 (Z6_EtherCATIndex,0x60FD,0)& 1) = 0	! waiting to leave the limit
	HALT Z6_axis
	TILL ^MST(Z6_axis).#MOVE 
	Z6_IndVel = Z6_multi_indVel							! define slowing velocity to find index velocity
END
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
ECOUT(ECGETOFFSET("Touch probe function",Z6_EtherCATIndex),Z6_TouchProbFun)
WAIT 200
Z6_TouchProbFun = 0										!Reset Touch probe
WAIT 200
Z6_TouchProbFun = 17										! Start Touch probe
WAIT 200
DISP"Start to find the index in positive direction......"
JOG/V Z6_axis,Z6_IndVel									!find the index in positive direction
TILL (COEREAD/2 (Z6_EtherCATIndex,0x60B9,0) = 3)			!if reach index	, stop motion
HALT Z6_axis	
TILL ^MST(Z6_axis).#MOVE 
DISP"Already found the index!!"
SET FPOS(Z6_axis) = (COEREAD/4 (Z6_EtherCATIndex,0x6064,0) - COEREAD/4 (Z6_EtherCATIndex,0x60BA,0))*Z6_ControlUnit - Z6_HmOffset		!set index position as zero.
WAIT 500
ECUNMAPOUT (ECGETOFFSET("Touch probe function",Z6_EtherCATIndex))	
RET	
STOP
!------------------------------------------------------------------Z6_HiwinDriveTouchProbeHmType2--------------------------------------------------------------------------------------
Z6_HiwinDriveTouchProbeHmType2:

FCLEAR Z6_axis
DISABLE Z6_axis		
TILL ^MST(Z6_axis).#ENABLED	
WAIT 500	
MFLAGS(Z6_axis).#OPEN = 0						! Close loop control
ERRORMAPOFF Z6_axis, -1							! Close all axis error compensation
MFLAGS(Z6_axis).#GANTRY = 0	 					! turn off gantry mode (MFLAGS.25)	
FDEF(Z6_axis).#SRL = 0	 						! disable software right limit response
FDEF(Z6_axis).#SLL = 0	 						! disable software left limit response
FDEF(Z6_axis).#LL = 0	 										! motor is not disable when left limit signal rising.

ENABLE	Z6_axis	 
!!!!!!!!!!!!!!!!!!!!multi index Structure Homing Way!!!!!!!!!!!!!!!
IF(Z6_multi_indHm = 1)	
	Z6_IndVel = Z6_multi_indVel					! define slowing velocity to find index velocity
END
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
ECOUT(ECGETOFFSET("Touch probe function",Z6_EtherCATIndex),Z6_TouchProbFun)
WAIT 200
Z6_TouchProbFun = 0								!Reset Touch probe
WAIT 200
Z6_TouchProbFun = 17								! Start Touch probe
WAIT 200
DISP"Start to find the index in positive direction......"
JOG/V Z6_axis,Z6_IndVel							!find the index in positive direction
TILL (COEREAD/2 (Z6_EtherCATIndex,0x60B9,0) = 3)	!if reach index	, stop motion
HALT Z6_axis	
TILL ^MST(Z6_axis).#MOVE 
DISP"Already found the index!!"
SET FPOS(Z6_axis) = (COEREAD/4 (Z6_EtherCATIndex,0x6064,0) - COEREAD/4 (Z6_EtherCATIndex,0x60BA,0))*Z6_ControlUnit - Z6_HmOffset	!set index position as zero.
WAIT 500
ECUNMAPOUT (ECGETOFFSET("Touch probe function",Z6_EtherCATIndex))		
RET	
STOP
!------------------------------------------------------------------Z6_HiwinDriveInternalHmType--------------------------------------------------------------------------------------
Z6_HiwinDriveInternalHmType:

FCLEAR Z6_axis
FDEF(Z6_axis).#LL = 0	 										! motor is not disable when left limit signal rising.
FDEF(Z6_axis).#SRL = 0	 										! disable software right limit response
FDEF(Z6_axis).#SLL = 0	 										! disable software left limit response
Z6_HiwinDriveHmVel = Z6_HmVel/Z6_ControlUnit
Z6_HiwinDriveIndVel = Z6_IndVel/Z6_ControlUnit
Z6_HiwinDriveHmOffset = Z6_HmOffset/Z6_ControlUnit
Z6_HiwinDriveHmAcc = ACC(Z6_axis)/Z6_ControlUnit

ECIN( ECGETOFFSET("Statusword",Z6_EtherCATIndex),Z6_StatusWord)  
ECOUT(ECGETOFFSET("Controlword",Z6_EtherCATIndex),Z6_ControlWord)
IF Z6_IsModeOfOperationInPDO = 1
	ECOUT(ECGETOFFSET("Mode of operation",Z6_EtherCATIndex),Z6_ModeOfOperation)
	Z6_ModeOfOperation = 6
ELSE
	COEWRITE/1 (Z6_EtherCATIndex,0x6060,0,6) !6 is Homing mode  
END  


COEWRITE/1 (Z6_EtherCATIndex,0x6098,0,Z6_InternalHmType)	
COEWRITE/4 (Z6_EtherCATIndex,0x6099,1,Z6_HiwinDriveHmVel) 	
COEWRITE/4 (Z6_EtherCATIndex,0x6099,2,Z6_HiwinDriveIndVel)	
COEWRITE/4 (Z6_EtherCATIndex,0x609A,0,Z6_HiwinDriveHmAcc)	
COEWRITE/4 (Z6_EtherCATIndex,0x607C,0,Z6_HiwinDriveHmOffset) 	

Z6_ControlWord=6  
TILL Z6_StatusWord.0=1  
Z6_ControlWord=7  
TILL Z6_StatusWord.0=1 & Z6_StatusWord.1=1

WAIT 200 

Z6_ControlWord=15  
TILL Z6_StatusWord.0=1 & Z6_StatusWord.1=1 & Z6_StatusWord.2=1	!Enabled
!Start Homing Procedure - Bit 4  
Z6_ControlWord=31  											!Start Home
TILL Z6_StatusWord.12=1 & Z6_StatusWord.10=1 | Z6_StatusWord.13=1				!Home Finished

IF Z6_StatusWord.13=1
	CALL HomeFail
END

Z6_ControlWord=0  

WAIT 100

IF Z6_IsModeOfOperationInPDO = 1
	Z6_ModeOfOperation = 8 
	WAIT 500 
	ECUNMAPOUT (ECGETOFFSET("Mode of operation",Z6_EtherCATIndex))
ELSE
	COEWRITE/1 (Z6_EtherCATIndex,0x6060,0,8)						!go back to CSP mode 
END  
WAIT 500 
ECUNMAPIN (ECGETOFFSET("Statusword",Z6_EtherCATIndex))
ECUNMAPOUT (ECGETOFFSET("Controlword",Z6_EtherCATIndex))

WAIT 500 
DISABLE Z6_axis
TILL ^MST(Z6_axis).#ENABLED 

RET
STOP
!!*************************************************************************************************************************************!!
!!****************************************************** Error Compensation Process ***************************************************!!
Z6_ErrorCompensation:
!---------- Z6_axis Error Compensation Table ------------!
Z6_ErrTable(0)=	0	;
Z6_ErrTable(1)=	0	;
Z6_ErrTable(2)=	0	;
Z6_ErrTable(3)=	0	;
Z6_ErrTable(4)=	0	;
Z6_ErrTable(5)=	0	;
Z6_ErrTable(6)=	0	;
Z6_ErrTable(7)=	0	;
Z6_ErrTable(8)=	0	;
Z6_ErrTable(9)=	0	;
Z6_ErrTable(10)=	0	;


!-------------------------------------------------------!
Z6_ErrTableIndex = 0
WHILE Z6_ErrTableIndex < SIZEOF(Z6_ErrTable)
	Z6_ErrTable(Z6_ErrTableIndex) = -Z6_ErrTable(Z6_ErrTableIndex)
	Z6_ErrTableIndex = Z6_ErrTableIndex + 1
END
ERRORUNMAP Z6_axis, ZONE0
ERRORMAP1D Z6_axis, ZONE0, Z6_ErrCompIniPos, Z6_ErrCompensationSpacing, Z6_ErrTable
ERRORMAPON Z6_axis, ZONE0

WAIT 500	
DISP "Cmpensation Procces's completed!"

RET 
STOP
!!#############################################################################################################################

ON MFLAGS(Z6_axis).#HOME=1 & TPOS(Z6_axis) < SLLIMIT(Z6_axis) 
	IF( FDEF(Z6_axis).#SLL=1 & FMASK(Z6_axis).#SLL=1 & ^(GMTYPE(Z6_axis)=5))
		KILL Z6_axis,5016	!Software Left Limit
		TPOS(Z6_axis)=FPOS(Z6_axis)
		DISP "TPOS(Z6_axis) < SLLIMIT(Z6_axis)"
	END
RET

ON MFLAGS(Z6_axis).#HOME=1 & TPOS(Z6_axis) > SRLIMIT(Z6_axis) 
	IF(FDEF(Z6_axis).#SRL=1 & FMASK(Z6_axis).#SRL=1 & ^(GMTYPE(Z6_axis)=5))
		KILL Z6_axis,5015	!Software Right Limit
		TPOS(Z6_axis)=FPOS(Z6_axis)
		DISP "TPOS(Z6_axis) > SRLIMIT(Z6_axis)"
	END
RET


ON MFLAGS(Z6_axis).#HOME=0 & RVEL(Z6_axis) > XVEL(Z6_axis)*0.5 & ^MST(Z6_axis).#INPOS
	IMM VEL(Z6_axis) = XVEL(Z6_axis)*0.45 
RET

ON MFLAGS(Z6_axis).#HOME=0 & RVEL(Z6_axis) < -XVEL(Z6_axis)*0.5 & ^MST(Z6_axis).#INPOS
	IMM VEL(Z6_axis) = -XVEL(Z6_axis)*0.45 
RET

AUTOEXEC:
	Z6_IOIndex = 30
	MFLAGS(Z6_axis).#HOME=0
STOP

ON IN(Z6_IOIndex).0 = 1
	SAFINI(Z6_axis).#LL = 1
RET

ON IN(Z6_IOIndex).0 = 0
	SAFINI(Z6_axis).#LL = 0
RET

ON IN(Z6_IOIndex).1 = 1
	SAFINI(Z6_axis).#RL = 1
RET

ON IN(Z6_IOIndex).1 = 0
	SAFINI(Z6_axis).#RL = 0
RET

!ON MST(Z6_axis).#ENABLED & (IN(Z6_IOIndex).24 = 1 | IN(Z6_IOIndex).25 = 1)
!	KILL Z6_axis
!	TILL ^MST(Z6_axis).#MOVE,500 
!	DISABLE Z6_axis,5028		!Safe Torque Off
!	TILL ^MST(Z6_axis).#ENABLED
!RET	

ON IN(Z6_IOIndex).24 = 1 | IN(Z6_IOIndex).25 = 1
    DISP"Z6_Event Time : %d",TIME
 	DISP"Z6_CHECK SF1 Value : %d",IN(Z6_IOIndex).24
	DISP"Z6_CHECK SF2 Value : %d",IN(Z6_IOIndex).25
	WAIT 5
	DISP"Z6_CHECK FAULT Value : %d", SAFIN(Z6_axis).9
	DISP"Z6_CHECK E1 FAULT : %d",AxisErrorCode41
RET	

HomeFail:
DISP" E1 homing fail "
IF Z6_IsModeOfOperationInPDO = 1
	Z6_ModeOfOperation = 8 
	WAIT 500 
	ECUNMAPOUT (ECGETOFFSET("Mode of operation",Z6_EtherCATIndex))
ELSE
	COEWRITE/1 (Z6_EtherCATIndex,0x6060,0,8)						!go back to CSP mode 
END  
WAIT 500 
ECUNMAPIN (ECGETOFFSET("Statusword",Z6_EtherCATIndex))
ECUNMAPOUT (ECGETOFFSET("Controlword",Z6_EtherCATIndex))

STOP
#33
!PNAME=
!PDESC=
!Ger ACS error
Disp "##########################################################"
Disp"ECERR: %d",ECERR 
Disp"ECALERR0: %d",ECALERR0

Disp"E_ERR0: %d",E_ERR0 
Disp"FAULT0: %d",FAULT0 
Disp"MERR0: %d",MERR0 
STOP
#38
!PNAME=
!PDESC=
! Z1_axis Get Home Offset
!ACS_Drive_Homing_Process_VER1.5
!!****** Setting Parameter ******!!
LOCAL REAL Z1_HmType,Z1_multi_indHm,Z1_multi_indVel
LOCAL REAL Z1_HmVel,Z1_IndVel,Z1_HmOffset	
LOCAL INT Z1_ErrCompensation,Z1_ErrCompensationSpacing,Z1_ErrCompIniPos
LOCAL INT Z1_CurrentCompensation,Z1_CurrentCompensationIndex,Z1_CurrentCompensationSettleTime
LOCAL REAL Z1_CurrentTableTemp(2)(11)
LOCAL REAL Z1_CurrentCompensationTravel,Z1_CurrentCompensationSpacing,Z1_CurrentCompensationSegment,Z1_CurrentCompensationIniPos
LOCAL INT ZONE0,Z1_ErrTableIndex
LOCAL REAL Z1_GantryHmM_SLPKP,Z1_GantryHmM_SLVKP,Z1_GantryHmM_SLVKI,Z1_GantryHmS_SLPKP,Z1_GantryHmS_SLVKP,Z1_GantryHmS_SLVKI
LOCAL REAL Z1_GantryProdM_SLPKP,Z1_GantryProdM_SLVKP,Z1_GantryProdM_SLVKI,Z1_GantryProdS_SLPKP,Z1_GantryProdS_SLVKP,Z1_GantryProdS_SLVKI
LOCAL REAL Z1_M_XCURI,Z1_M_XCURV,Z1_S_XCURI,Z1_S_XCURV
LOCAL INT Z1_IsUsingGantryHmGain,Z1_IsFlexibleGantry,Z1_IsGantryComove,Z1_EtherCATIndex,Z1_GantryHomeStep
LOCAL REAL Z1_Yawlock
LOCAL REAL Z1_CommutCurrent,Z1_Yaw_CommutCurrent
LOCAL REAL Z1_Offset,Z1_Yaw_Offset !2023.11.08
!!################ Basic Settings ######################################################################################################
Z1_HmType = 0 								!the method of homing
           									!value 0 : Customized homing											
											!	   3 : this type is for gantry mode , and the motion for homing is same as Z1_HmType=1.
											!	   4 : this type is for gantry mode , and the motion for homing is same as Z1_HmType=2.
Z1_HmOffset = 0 								! Z1_HmOffset (unit)
Z1_HmVel = 2000 !30000								! the velocity for homing 	
Z1_IndVel = 50  !10000 								! the velocity for finding index
Z1_multi_indHm=0							! multi index structure
											! value 0 : nomal Homing
											!	    1 : find the left limit in negative direction,then slowing leave the limit in positive direction,
											!			then slowing find the left limit in negative direction,then slowing find index in positive direction
Z1_multi_indVel = 100						! (Do not modify)homing velocity of multi index structure
Z1_CommutCurrent = 80						! Commutation excitation current.
Z1_Yaw_CommutCurrent = 80					! Yaw axis Commutation excitation current.
!!*********************************** Z1_axis Gantry mod ***************************************************!!
Z1_IsFlexibleGantry = 0 						! 0: Stiff Gantry ; 1: Flexible Gantry (Z1_IsGantryComove automatically set to 1 )
Z1_IsGantryComove = 0						! 0: Search limit and index by Z1_axis
											! 1: Search limit and index by Z1_axis and Z1_Yaw_axis comove
Z1_Yawlock = 0								! Z1_Yaw_axis follow position
Z1_M_XCURI = 45								! Z1_axis XCURI
Z1_M_XCURV = 90								! Z1_axis XCURV
Z1_S_XCURI = 10							! Z1_Yaw_axis XCURI
Z1_S_XCURV = 10								! Z1_Yaw_axis XCURV

Z1_IsUsingGantryHmGain = 1					! 0 : Homing and production using same gain 
											! 1 : Homing and production using different gain 
!------------------Homing and production gain set (Set by Z1_IsUsingGantryHmGain = 1)-----------------!
Z1_GantryHmM_SLPKP = 120						! Z1_axis homing gain
Z1_GantryHmM_SLVKP = 80		
Z1_GantryHmM_SLVKI = 120
Z1_GantryHmS_SLPKP = 120						! Z1_Yaw_axis homing gain
Z1_GantryHmS_SLVKP = 80
Z1_GantryHmS_SLVKI = 120
Z1_GantryProdM_SLPKP = 150						! Z1_axis production gain
Z1_GantryProdM_SLVKP = 200
Z1_GantryProdM_SLVKI = 100
Z1_GantryProdS_SLPKP = 70						! Z1_Yaw_axis production gain
Z1_GantryProdS_SLVKP = 60
Z1_GantryProdS_SLVKI = 80
!!**************** Configuration of 1D Error Compensation*****************************************************!!
Z1_ErrCompensation = 1						! 0 : without compensation  ; 1 : turn on the compensation after homing completed 
Z1_ErrCompIniPos = 0							! the initial position of error compensation
Z1_ErrCompensationSpacing = 15000				! setting the spacing for error compensation 
!!**************** Configuration of Current Compensation for gantry mode ***************************************!!
Z1_CurrentCompensation = 1					! Current Compensation
											! the value 0 : without current compensation.
											!           1 : Enable current compensation mode with exist current table. 
											!           2 : Execute the process of current table search after homing , and then 
											!               enable current compensation mode.
Z1_CurrentCompensationIniPos = 0				! compensation start postion
Z1_CurrentCompensationTravel = 150000			! the stroke (unit) of CurrentCompensation
Z1_CurrentCompensationSegment = 10			! the segment for current compensation.
Z1_CurrentCompensationSettleTime = 3000		! time requiered for Yaw axis to take satisfactory position
Z1_CurrentCompensationSpacing = Z1_CurrentCompensationTravel / Z1_CurrentCompensationSegment	 ! the spacing for current compensation (unit)
!!**********************************************************************************************************!!
!!######################################################################################################################################## 

!!**************************************************************************************************************************************!!
!!************************************************************ Main program ************************************************************!!

IF Z1_HmType=0													! Customized homing
	MFLAGS(Z1_axis).#HOME=0;	MFLAGS(Z1_Yaw_axis).#HOME=0
	CALL Z1_HmType0
ELSEIF Z1_HmType>=3 & Z1_HmType<=4 			! Gantry Homing	
	MFLAGS(Z1_axis).#HOME=0;	MFLAGS(Z1_Yaw_axis).#HOME=0
	IF Z1_HmType=3
		CALL Z1_HmType3
	ELSEIF Z1_HmType=4
		CALL Z1_HmType4
	END
ELSE
	DISP"ERROR:The value of Z1_HmType or Z1_HiwinDriveHome is invalid!!"
	STOP
END

!!IF (Z1_CurrentCompensation=1 & Z1_HmType>=3)
!!	DISP"Turn on the Current Compensation..."	
!!	CALL Z1_TurnOnCurrentCompensation	
!!ELSEIF (Z1_CurrentCompensation=2 &  Z1_HmType>=3)
!!	CALL Z1_CurrentCompensation	
!!ELSEIF (Z1_CurrentCompensation=0 &  Z1_HmType>=3)	
!!	ERRORUNMAP Z1_Yaw_axis, ZONE0
!!END
!!
!!IF Z1_ErrCompensation = 1
!!	DISP "Enable the compensation mode."
!!	DISP "Execute the compensation prcoess......"
!!	CALL Z1_ErrorCompensation	
!!ELSE
!!	DISP "Disable error compensation."
!!	ERRORUNMAP Z1_axis, ZONE0
!!END 
!!
!!ENABLE (Z1_axis)	
!!TILL MST(Z1_axis).#ENABLED & MST(Z1_Yaw_axis).#ENABLED
!!WAIT 500
!!DISP"Go home......"	
!!PTP/EV Z1_axis,0,Z1_HmVel		
!!PTP/EV Z1_Yaw_axis,0,Z1_HmVel !Yaw lock s
!!MFLAGS(Z1_axis).#HOME=1;	MFLAGS(Z1_Yaw_axis).#HOME=1	

FDEF(Z1_axis).#LL = 	1	;	FDEF(Z1_Yaw_axis).#LL =  1			! turn on the response of reaching left limit
FDEF(Z1_axis).#SRL = 1	;	FDEF(Z1_Yaw_axis).#SRL = 1	 		! enable software right limit response
FDEF(Z1_axis).#SLL = 1	;	FDEF(Z1_Yaw_axis).#SLL = 1	 		! enable software left limit response
DISP"Homing successful!!"	

STOP	

!!*************************************************************************************************************************************!!
!!************************************************************ Homing process	*******************************************************!!
Z1_HmType0:
Z1_GantryHomeStep = 0
IF Z1_IsFlexibleGantry = 1 
	Z1_IsGantryComove = 1										!Flexible gantry should comove
END

DISABLE (Z1_axis,Z1_Yaw_axis)	
TILL ^MST(Z1_axis).#ENABLED & ^MST(Z1_Yaw_axis).#ENABLED	
WAIT 500	
ERRORMAPOFF Z1_axis, -1	;	ERRORMAPOFF Z1_Yaw_axis, -1			! Close all Z1_axis & Z1_yaw_axis error compensation
MFLAGS(Z1_axis).#GANTRY = 0	;	MFLAGS(Z1_Yaw_axis).#GANTRY = 0	! turn off gantry mode (MFLAGS.25)
FDEF(Z1_axis).#SRL = 0	;	FDEF(Z1_Yaw_axis).#SRL = 0	 		! disable software right limit response
FDEF(Z1_axis).#SLL = 0	;	FDEF(Z1_Yaw_axis).#SLL = 0	 		! disable software left limit response

IF (^MFLAGS(Z1_axis).#BRUSHOK & MFLAGS(Z1_axis).#BRUSHL) 			! Confirm BRUSHOK
	ENABLE Z1_axis		
	TILL MST(Z1_axis).#ENABLED	
	COMMUT Z1_axis,Z1_CommutCurrent								! do commutation
	TILL MFLAGS(Z1_axis).#BRUSHOK								! Wait for the commutation to complete, BRUSHOK is 1
	DISABLE Z1_axis		
	TILL ^MST(Z1_axis).#ENABLED	
END	
IF (^MFLAGS(Z1_Yaw_axis).#BRUSHOK & MFLAGS(Z1_Yaw_axis).#BRUSHL)	! Confirm BRUSHOK
	ENABLE Z1_Yaw_axis		
	TILL MST(Z1_Yaw_axis).#ENABLED
	COMMUT Z1_Yaw_axis,Z1_Yaw_CommutCurrent							! do commutation
	TILL MFLAGS(Z1_Yaw_axis).#BRUSHOK							! Wait for the commutation to complete, BRUSHOK is 1
	DISABLE Z1_Yaw_axis		
	TILL ^MST(Z1_Yaw_axis).#ENABLED	
END	

DISABLE (Z1_axis,Z1_Yaw_axis)	
TILL ^MST(Z1_axis).#ENABLED & ^MST(Z1_Yaw_axis).#ENABLED	
WAIT 500

E_TYPE(Z1_axis)=13 ; 	E_TYPE(Z1_Yaw_axis)=13 ;!add 2023.11.08
E_AOFFS(Z1_axis) = 0 ; 	E_AOFFS(Z1_Yaw_axis) = 0 ; !add 2023.11.08

	
MFLAGS(Z1_axis).#OPEN =0 ;	MFLAGS(Z1_Yaw_axis).#OPEN =0	 		! close loop control
FDEF(Z1_axis).#LL = 	0	;	FDEF(Z1_Yaw_axis).#LL =  0			! motor is not disable when left limit signal rising.

IF Z1_IsUsingGantryHmGain=1
	CALL HmGain
END
								! Comove
ACC(Z1_Yaw_axis)=ACC(Z1_axis)									! Z1_axis & Z1_Yaw_axis should same motion profile
DEC(Z1_Yaw_axis)=DEC(Z1_axis)	
JERK(Z1_Yaw_axis)=JERK(Z1_axis)
XCURI(Z1_Yaw_axis)=XCURI(Z1_axis)	
XCURV(Z1_Yaw_axis)=XCURV(Z1_axis)	
SLPKP(Z1_Yaw_axis)=SLPKP(Z1_axis)
SLVKP(Z1_Yaw_axis)=SLVKP(Z1_axis)
SLVKI(Z1_Yaw_axis)=SLVKI(Z1_axis)
ENABLE (Z1_axis,Z1_Yaw_axis)
TILL MST(Z1_axis).#ENABLED & MST(Z1_Yaw_axis).#ENABLED	


!add 2023.11.08
DISP"Z1_axis Start to find the left limit......"
JOG/V Z1_axis,-Z1_HmVel	
TILL FAULT(Z1_axis).#LL 
HALT Z1_axis 
TILL ^MST(Z1_axis).#MOVE											! if reach left limit , stop motion
DISP"Z1_axis Already found the left limit!!"
JOG/V Z1_axis,Z1_IndVel											!leave the left limit in positive direction
TILL ^FAULT(Z1_axis).#LL 										    !if leave the left limit, stop motion
HALT Z1_axis		
TILL ^MST(Z1_axis).#MOVE 

PTP/ERV Z1_axis,1000,Z1_HmVel
TILL ^MST(Z1_axis).#MOVE 	
DISP"Z1_axis already leave the left limit!!"


!add 2023.11.08
!Z1_Yaw_axis
DISP"Z1_Yaw_axis Start to find the left limit......"
JOG/V Z1_Yaw_axis,-Z1_HmVel	
TILL FAULT(Z1_Yaw_axis).#LL 
HALT Z1_Yaw_axis 
TILL ^MST(Z1_Yaw_axis).#MOVE											! if reach left limit , stop motion
DISP"Z1_Yaw_axis Already found the left limit!!"
JOG/V Z1_Yaw_axis,Z1_IndVel											!leave the left limit in positive direction
TILL ^FAULT(X3_Yaw_axis).#LL 										    !if leave the left limit, stop motion
HALT Z1_Yaw_axis		
TILL ^MST(Z1_Yaw_axis).#MOVE 

PTP/ERV Z1_Yaw_axis,1000,Z1_HmVel
TILL ^MST(Z1_Yaw_axis).#MOVE 	
DISP"Z1_Yaw_axis already leave the left limit!!"
Disp"Z1_axis offset %d:  ", FPOS(Z1_axis)
Disp"Z1_Yaw_axis offset %d:  ", FPOS(Z1_Yaw_axis)

Z1_Offset =FPOS(Z1_axis)
Z1_Yaw_Offset =FPOS(Z1_Yaw_axis)
DISABLE (Z1_axis,Z1_Yaw_axis)	
TILL ^MST(Z1_axis).#ENABLED & ^MST(Z1_Yaw_axis).#ENABLED	
E_AOFFS(Z1_axis) = Z1_Offset ; 	E_AOFFS(Z1_Yaw_axis) = Z1_Yaw_Offset ; !add 2023.11.08

!!
!!PTP/VW Z1_axis, 0, Z1_HmVel ;
!!PTP/VW Z1_Yaw_axis,0, Z1_HmVel ;
!!GO (Z1_axis,Z1_Yaw_axis)										! Z1_axis & Z1_Yaw_axis move same time
!!TILL ((APOS(Z1_axis) = TPOS(Z1_axis)) & (APOS(Z1_Yaw_axis) = TPOS(Z1_Yaw_axis)) & ^MST(Z1_axis).#MOVE & ^MST(Z1_Yaw_axis).#MOVE ), 10000 ;


WAIT 50 ;

IF ^MST(Z1_axis).#MOVE & ^MST(Z1_Yaw_axis).#MOVE
	! Deactivate closed-loop and till Zb_axis_CLFlags turn off.
	WAIT 50 ;
ELSE
	DISP " move to initial position timeout." ;
	STOP(7)
END	

	
!!DISP"Already found the index!!"	
!!
!!SET FPOS(Z1_axis)=FPOS(Z1_axis)-IND(Z1_axis)-Z1_HmOffset	
!!SET FPOS(Z1_Yaw_axis)=FPOS(Z1_Yaw_axis)-IND(Z1_Yaw_axis) - Z1_HmOffset	+ Z1_Yawlock
!!DISABLE (Z1_axis,Z1_Yaw_axis)	
!!TILL ^MST(Z1_axis).#ENABLED & ^MST(Z1_Yaw_axis).#ENABLED
!!MFLAGS(Z1_axis).#GANTRY = 1	;	MFLAGS(Z1_Yaw_axis).#GANTRY = 1	! turn on gantry mode
!!XCURI(Z1_axis) = Z1_M_XCURI	;	XCURI(Z1_Yaw_axis) = Z1_S_XCURI
!!XCURV(Z1_axis) = Z1_M_XCURV	;	XCURV(Z1_Yaw_axis) = Z1_S_XCURV
!!IF Z1_IsUsingGantryHmGain=1
!!	CALL ProdGain
!!END

!Customized
RET
STOP
!------------------------------------------------------------------Z1_HmType3--------------------------------------------------------------------------------------
Z1_HmType3:

RET	
STOP
!------------------------------------------------------------------Z1_HmType4--------------------------------------------------------------------------------------
Z1_HmType4:


RET	
STOP
!!****************************************************** Error Compensation Process ***************************************************!!
Z1_ErrorCompensation:
!---------- Z1_axis Error Compensation Table ------------!
Z1_ErrTable(0) =  0	;     
Z1_ErrTable(1) =  -1.1	;
Z1_ErrTable(2) =  -2.9	;
Z1_ErrTable(3) = -1.4	;
Z1_ErrTable(4) =  1.0	;
Z1_ErrTable(5) =  0.5	;
Z1_ErrTable(6) = -0.6	;
Z1_ErrTable(7) =  1.4	;
Z1_ErrTable(8) =  5.5	;
Z1_ErrTable(9) =  6.9	;
Z1_ErrTable(10) = 7.1	;

!-------------------------------------------------------!
Z1_ErrTableIndex = 0
WHILE Z1_ErrTableIndex < SIZEOF(Z1_ErrTable)
	Z1_ErrTable(Z1_ErrTableIndex) = -Z1_ErrTable(Z1_ErrTableIndex)
	Z1_ErrTableIndex = Z1_ErrTableIndex + 1
END
ERRORUNMAP Z1_axis, ZONE0
ERRORMAP1D Z1_axis, ZONE0, Z1_ErrCompIniPos, Z1_ErrCompensationSpacing, Z1_ErrTable
ERRORMAPON Z1_axis, ZONE0

WAIT 500	
DISP "Cmpensation Procces's completed!"

RET 
STOP

!!*************************************************************************************************************************************!!
!!********************************************************* Current Compensation ******************************************************!!
Z1_CurrentCompensation:
ENABLE Z1_axis
TILL MST(Z1_axis).#ENABLED & MST(Z1_Yaw_axis).#ENABLED 
PTP/EV Z1_axis,Z1_CurrentCompensationIniPos,Z1_HmVel
DISABLE Z1_axis
TILL ^MST(Z1_axis).#ENABLED & ^MST(Z1_Yaw_axis).#ENABLED 
MFLAGS(Z1_Yaw_axis).#OPEN = 1		
ENABLE Z1_axis
TILL MST(Z1_axis).#ENABLED & MST(Z1_Yaw_axis).#ENABLED 

PTP/EV Z1_axis,Z1_CurrentCompensationIniPos,Z1_HmVel
WAIT Z1_CurrentCompensationSettleTime
Z1_CurrentCompensationIndex = 0
!Move positive
DISP"Y error table search sequence in positive direction......"
WHILE Z1_CurrentCompensationIndex <= Z1_CurrentCompensationSegment
	DISP"Y FPOS=%f , Y Yaw Offset = %f ",FPOS(Z1_axis),FPOS(Z1_Yaw_axis)
	Z1_CurrentTableTemp(0)(Z1_CurrentCompensationIndex) = FPOS(Z1_Yaw_axis)
	IF Z1_CurrentCompensationIndex < Z1_CurrentCompensationSegment
		PTP/ERV Z1_axis,Z1_CurrentCompensationSpacing,Z1_HmVel		
		WAIT Z1_CurrentCompensationSettleTime
	END
	Z1_CurrentCompensationIndex = Z1_CurrentCompensationIndex + 1	
END

PTP/EV Z1_axis,Z1_CurrentCompensationIniPos + Z1_CurrentCompensationTravel,Z1_HmVel
WAIT Z1_CurrentCompensationSettleTime
Z1_CurrentCompensationIndex = Z1_CurrentCompensationSegment
!Move negative unfinished
DISP"Y error table search sequence in negative direction......"
WHILE Z1_CurrentCompensationIndex >= 0
	DISP"Y FPOS=%f , Y Yaw Offset = %f ",FPOS(Z1_axis),FPOS(Z1_Yaw_axis)
	Z1_CurrentTableTemp(1)(Z1_CurrentCompensationIndex) = FPOS(Z1_Yaw_axis)
	IF Z1_CurrentCompensationIndex > 0
		PTP/ERV Z1_axis,-Z1_CurrentCompensationSpacing,Z1_HmVel		
		WAIT Z1_CurrentCompensationSettleTime
	END
	Z1_CurrentCompensationIndex = Z1_CurrentCompensationIndex - 1	
END

Z1_CurrentCompensationIndex = 0
WHILE Z1_CurrentCompensationIndex <= Z1_CurrentCompensationSegment
	Z1_CurrentTable(Z1_CurrentCompensationIndex)	=	(Z1_CurrentTableTemp(0)(Z1_CurrentCompensationIndex) + Z1_CurrentTableTemp(1)(Z1_CurrentCompensationIndex))/2
	Z1_CurrentCompensationIndex = Z1_CurrentCompensationIndex + 1
END

WRITE Z1_CurrentTable,Z1_CurrentTable
WAIT 1500	
PTP/EV Z1_axis,Z1_CurrentCompensationIniPos,Z1_HmVel
WAIT 500	

Z1_TurnOnCurrentCompensation:
DISABLE Z1_axis
TILL ^MST(Z1_axis).#ENABLED & ^MST(Z1_Yaw_axis).#ENABLED
MFLAGS(Z1_Yaw_axis).#OPEN = 0
ENABLE (Z1_axis,Z1_Yaw_axis)
TILL MST(Z1_axis).#ENABLED & MST(Z1_Yaw_axis).#ENABLED
READ Z1_CurrentTable,Z1_CurrentTable
ERRORUNMAP Z1_Yaw_axis, ZONE0
ERRORMAP1D Z1_Yaw_axis, ZONE0, Z1_CurrentCompensationIniPos, Z1_CurrentCompensationSpacing, Z1_CurrentTable
ERRORMAPON Z1_Yaw_axis, ZONE0
DISP"Current compensaton completed!"
RET 
STOP
!!*************************************************************************************************************************************!!
!**************************************Gains for homing********************************************!
HmGain:

SLPKP(Z1_axis)= Z1_GantryHmM_SLPKP	
SLVKP(Z1_axis)= Z1_GantryHmM_SLVKP	
SLVKI(Z1_axis)= Z1_GantryHmM_SLVKI	

SLPKP(Z1_Yaw_axis)= Z1_GantryHmS_SLPKP	
SLVKP(Z1_Yaw_axis)= Z1_GantryHmS_SLVKP	
SLVKI(Z1_Yaw_axis)= Z1_GantryHmS_SLVKI	


RET	
STOP
!**************************************Gains for production*****************************************!
ProdGain:

SLPKP(Z1_axis)= Z1_GantryProdM_SLPKP	
SLVKP(Z1_axis)= Z1_GantryProdM_SLVKP	
SLVKI(Z1_axis)= Z1_GantryProdM_SLVKI	

SLPKP(Z1_Yaw_axis)= Z1_GantryProdS_SLPKP	
SLVKP(Z1_Yaw_axis)= Z1_GantryProdS_SLVKP	
SLVKI(Z1_Yaw_axis)= Z1_GantryProdS_SLVKI	

RET
STOP
!!*************************************************************************************************************************************!!


!!#############################################################################################################################

ON Z1_GantryHomeStep = 1 & Z1_IsFlexibleGantry = 1 & FAULT(Z1_axis).#LL
	HALT Z1_axis
RET

ON Z1_GantryHomeStep = 1 & Z1_IsFlexibleGantry = 1 & FAULT(Z1_Yaw_axis).#LL
	HALT Z1_Yaw_axis
RET

ON Z1_GantryHomeStep = 2 & Z1_IsFlexibleGantry = 1 & ^FAULT(Z1_axis).#LL
	HALT Z1_axis
RET

ON Z1_GantryHomeStep = 2 & Z1_IsFlexibleGantry = 1 & ^FAULT(Z1_Yaw_axis).#LL
	HALT Z1_Yaw_axis
RET


ON MFLAGS(Z1_axis).#HOME=1 & MFLAGS(Z1_Yaw_axis).#HOME=1 & TPOS(Z1_axis) < SLLIMIT(Z1_axis) 
	IF( FDEF(Z1_axis).#SLL=1 & FMASK(Z1_axis).#SLL=1 & ^(GMTYPE(Z1_axis)=5))
		KILL Z1_axis,5016	!Software Left Limit
		TPOS(Z1_axis)=FPOS(Z1_axis)
		DISP "TPOS(Z1_axis) < SLLIMIT(Z1_axis)"
	END
RET

ON MFLAGS(Z1_axis).#HOME=1 & MFLAGS(Z1_Yaw_axis).#HOME=1 & TPOS(Z1_axis) > SRLIMIT(Z1_axis) 
	IF(FDEF(Z1_axis).#SRL=1 & FMASK(Z1_axis).#SRL=1 & ^(GMTYPE(Z1_axis)=5))
		KILL Z1_axis,5015	!Software Right Limit
		TPOS(Z1_axis)=FPOS(Z1_axis)
		DISP "TPOS(Z1_axis) > SRLIMIT(Z1_axis)"
	END
RET

ON MFLAGS(Z1_axis).#HOME=1 & MFLAGS(Z1_Yaw_axis).#HOME=1 & TPOS(Z1_Yaw_axis) < SLLIMIT(Z1_Yaw_axis) 
	IF( FDEF(Z1_Yaw_axis).#SLL=1 & FMASK(Z1_Yaw_axis).#SLL=1 & ^(GMTYPE(Z1_Yaw_axis)=5))
		KILL Z1_Yaw_axis,5016	!Software Left Limit
		TPOS(Z1_Yaw_axis)=FPOS(Z1_Yaw_axis)
		DISP "TPOS(Z1_Yaw_axis) < SLLIMIT(Z1_Yaw_axis)"
	END
RET

ON MFLAGS(Z1_axis).#HOME=1 & MFLAGS(Z1_Yaw_axis).#HOME=1 & TPOS(Z1_Yaw_axis) > SRLIMIT(Z1_Yaw_axis) 
	IF(FDEF(Z1_Yaw_axis).#SRL=1 & FMASK(Z1_Yaw_axis).#SRL=1 & ^(GMTYPE(Z1_Yaw_axis)=5))
		KILL Z1_Yaw_axis,5015	!Software Right Limit
		TPOS(Z1_Yaw_axis)=FPOS(Z1_Yaw_axis)
		DISP "TPOS(Z1_Yaw_axis) > SRLIMIT(Z1_Yaw_axis)"
	END
RET



ON MFLAGS(Z1_axis).#HOME=0 & MFLAGS(Z1_Yaw_axis).#HOME=0 & RVEL(Z1_axis) > XVEL(Z1_axis)*0.5 & ^MST(Z1_axis).#INPOS
	IMM VEL(Z1_axis) = XVEL(Z1_axis)*0.45 
RET

ON MFLAGS(Z1_axis).#HOME=0 & MFLAGS(Z1_Yaw_axis).#HOME=0 & RVEL(Z1_axis) < -XVEL(Z1_axis)*0.5 & ^MST(Z1_axis).#INPOS
	IMM VEL(Z1_axis) = -XVEL(Z1_axis)*0.45 
RET

ON MFLAGS(Z1_axis).#HOME=0 & MFLAGS(Z1_Yaw_axis).#HOME=0 & RVEL(Z1_Yaw_axis) > XVEL(Z1_Yaw_axis)*0.5 & ^MST(Z1_Yaw_axis).#INPOS
	IMM VEL(Z1_Yaw_axis) = XVEL(Z1_Yaw_axis)*0.45 
RET

ON MFLAGS(Z1_axis).#HOME=0 & MFLAGS(Z1_Yaw_axis).#HOME=0 & RVEL(Z1_Yaw_axis) < -XVEL(Z1_Yaw_axis)*0.5 & ^MST(Z1_Yaw_axis).#INPOS
	IMM VEL(Z1_Yaw_axis) = -XVEL(Z1_Yaw_axis)*0.45 
RET

AUTOEXEC:
	!Z1_init_pos = 75050					Z1_Yaw_init_pos = 75210
	!MFLAGS(Z1_axis).#HOME=0;	 		MFLAGS(Z1_Yaw_axis).#HOME=0
	!MFLAGS(Z1_axis).#GANTRY=0 ; 		MFLAGS(Z1_Yaw_axis).#GANTRY=0
	!E_TYPE(Z1_axis)=13 ; 				E_TYPE(Z1_Yaw_axis)=13 ;
	!E_AOFFS(Z1_axis) = Z1_init_pos ; 	E_AOFFS(Z1_Yaw_axis) = Z1_Yaw_init_pos ;  
	
STOP
#39
!PNAME=
!PDESC=
! X3_axis Get Home Offset
!Gantry-axis_ACS_Drive_Homing_Process_VER1.5
!!****** Setting Parameter ******!!
LOCAL REAL X3_HmType,X3_multi_indHm,X3_multi_indVel
LOCAL REAL X3_HmVel,X3_IndVel,X3_HmOffset	
LOCAL INT X3_ErrCompensation,X3_ErrCompensationSpacing,X3_ErrCompIniPos
LOCAL INT X3_CurrentCompensation,X3_CurrentCompensationIndex,X3_CurrentCompensationSettleTime
LOCAL REAL X3_CurrentTableTemp(2)(21)
LOCAL REAL X3_CurrentCompensationTravel,X3_CurrentCompensationSpacing,X3_CurrentCompensationSegment,X3_CurrentCompensationIniPos
LOCAL INT ZONE0,X3_ErrTableIndex
LOCAL REAL X3_GantryHmM_SLPKP,X3_GantryHmM_SLVKP,X3_GantryHmM_SLVKI,X3_GantryHmS_SLPKP,X3_GantryHmS_SLVKP,X3_GantryHmS_SLVKI
LOCAL REAL X3_GantryProdM_SLPKP,X3_GantryProdM_SLVKP,X3_GantryProdM_SLVKI,X3_GantryProdS_SLPKP,X3_GantryProdS_SLVKP,X3_GantryProdS_SLVKI
LOCAL REAL X3_M_XCURI,X3_M_XCURV,X3_S_XCURI,X3_S_XCURV
LOCAL INT X3_IsUsingGantryHmGain,X3_IsFlexibleGantry,X3_IsGantryComove,X3_EtherCATIndex,X3_GantryHomeStep
LOCAL REAL X3_Yawlock
LOCAL REAL X3_CommutCurrent,X3_Yaw_CommutCurrent
LOCAL REAL X3_Offset,X3_Yaw_Offset !2023.11.08
!!################ Basic Settings ######################################################################################################
X3_HmType = 0 								!the method of homing
           									!value 0 : Customized homing											
											!	   3 : this type is for gantry mode , and the motion for homing is same as X3_HmType=1.
											!	   4 : this type is for gantry mode , and the motion for homing is same as X3_HmType=2.
X3_HmOffset = 0 								! X3_HmOffset (unit)
X3_HmVel = 2000 !100000								! the velocity for homing 	
X3_IndVel = 50  !10000 								! the velocity for finding index
X3_multi_indHm=0							! multi index structure
											! value 0 : nomal Homing
											!	    1 : find the left limit in negative direction,then slowing leave the limit in positive direction,
											!			then slowing find the left limit in negative direction,then slowing find index in positive direction
X3_multi_indVel = 100						! (Do not modify)homing velocity of multi index structure
X3_CommutCurrent = 80						! Commutation excitation current.
X3_Yaw_CommutCurrent = 80					! Yaw axis Commutation excitation current.
!!*********************************** X3_axis Gantry mod ***************************************************!!
X3_IsFlexibleGantry = 1 						! 0: Stiff Gantry ; 1: Flexible Gantry (X3_IsGantryComove automatically set to 1 )
X3_IsGantryComove = 0						! 0: Search limit and index by X3_axis
											! 1: Search limit and index by X3_axis and X3_Yaw_axis comove
X3_Yawlock =0						! X3_Yaw_axis follow position
X3_M_XCURI = 45								! X3_axis XCURI
X3_M_XCURV = 85								! X3_axis XCURV
X3_S_XCURI = 15							! X3_Yaw_axis XCURI
X3_S_XCURV = 15								! X3_Yaw_axis XCURV

X3_IsUsingGantryHmGain = 1					! 0 : Homing and production using same gain 
											! 1 : Homing and production using different gain 
!------------------Homing and production gain set (Set by X3_IsUsingGantryHmGain = 1)-----------------!
X3_GantryHmM_SLPKP = 100						! X3_axis homing gain
X3_GantryHmM_SLVKP = 250		
X3_GantryHmM_SLVKI = 200
X3_GantryHmS_SLPKP = 100						! X3_Yaw_axis homing gain
X3_GantryHmS_SLVKP = 250
X3_GantryHmS_SLVKI = 200
X3_GantryProdM_SLPKP = 70						! X3_axis production gain
X3_GantryProdM_SLVKP = 300
X3_GantryProdM_SLVKI = 150
X3_GantryProdS_SLPKP = 80						! X3_Yaw_axis production gain
X3_GantryProdS_SLVKP = 120
X3_GantryProdS_SLVKI = 220
!!**************** Configuration of 1D Error Compensation*****************************************************!!
X3_ErrCompensation = 1						! 0 : without compensation  ; 1 : turn on the compensation after homing completed 
X3_ErrCompIniPos = 0							! the initial position of error compensation
X3_ErrCompensationSpacing = 75000				! setting the spacing for error compensation 
!!**************** Configuration of Current Compensation for gantry mode ***************************************!!
X3_CurrentCompensation = 1					! Current Compensation
											! the value 0 : without current compensation.
											!           1 : Enable current compensation mode with exist current table. 
											!           2 : Execute the process of current table search after homing , and then 
											!               enable current compensation mode.
X3_CurrentCompensationIniPos = 0				! compensation start postion
X3_CurrentCompensationTravel = 1500000			! the stroke (unit) of CurrentCompensation
X3_CurrentCompensationSegment = 20			! the segment for current compensation.
X3_CurrentCompensationSettleTime = 3000		! time requiered for Yaw axis to take satisfactory position
X3_CurrentCompensationSpacing = X3_CurrentCompensationTravel / X3_CurrentCompensationSegment	 ! the spacing for current compensation (unit)
!!**********************************************************************************************************!!
!!######################################################################################################################################## 

!!**************************************************************************************************************************************!!
!!************************************************************ Main program ************************************************************!!

IF X3_HmType=0	
	MFLAGS(X3_axis).#HOME=0;	MFLAGS(X3_Yaw_axis).#HOME=0												! Customized homing
	CALL X3_HmType0
ELSEIF X3_HmType>=3 & X3_HmType<=4 			! Gantry Homing	
	MFLAGS(X3_axis).#HOME=0;	MFLAGS(X3_Yaw_axis).#HOME=0
	IF X3_HmType=3
		CALL X3_HmType3
	ELSEIF X3_HmType=4
		CALL X3_HmType4
	END
ELSE
	DISP"ERROR:The value of X3_HmType or X3_HiwinDriveHome is invalid!!"
	STOP
END

!!IF (X3_CurrentCompensation=1)
!!	DISP"Turn on the Current Compensation..."	
!!	CALL X3_TurnOnCurrentCompensation	
!!ELSEIF (X3_CurrentCompensation=2)
!!	CALL X3_CurrentCompensation	
!!ELSEIF (X3_CurrentCompensation=0)	
!!	ERRORUNMAP X3_Yaw_axis, ZONE0
!!END
!
!!IF X3_ErrCompensation = 1
!!	DISP "Enable the compensation mode."
!!	DISP "Execute the compensation prcoess......"
!!	CALL X3_ErrorCompensation	
!!ELSE
!!	DISP "Disable error compensation."
!!	ERRORUNMAP X3_axis, ZONE0
!!END 
!
!!ENABLE (X3_axis)	
!!TILL MST(X3_axis).#ENABLED & MST(X3_Yaw_axis).#ENABLED
!!WAIT 500
!!DISP"Go home......"	
!!PTP/EV X3_axis,0,X3_HmVel		                   !2023.11.08
!!PTP/EV X3_Yaw_axis,0,X3_HmVel !Yaw lock s           !2023.11.08
!!MFLAGS(X3_axis).#HOME=1;	MFLAGS(X3_Yaw_axis).#HOME=1	

FDEF(X3_axis).#LL = 	1	;	FDEF(X3_Yaw_axis).#LL =  1			! turn on the response of reaching left limit
FDEF(X3_axis).#SRL = 1	;	FDEF(X3_Yaw_axis).#SRL = 1	 		! enable software right limit response
FDEF(X3_axis).#SLL = 1	;	FDEF(X3_Yaw_axis).#SLL = 1	 		! enable software left limit response
DISP"X3_axis Homing successful!!"	

STOP	

!!*************************************************************************************************************************************!!
!!************************************************************ Homing process	*******************************************************!!
X3_HmType0:
X3_GantryHomeStep = 0
IF X3_IsFlexibleGantry = 1 
	X3_IsGantryComove = 1										!Flexible gantry should comove
END

DISABLE (X3_axis,X3_Yaw_axis)	
TILL ^MST(X3_axis).#ENABLED & ^MST(X3_Yaw_axis).#ENABLED	
WAIT 500	
ERRORMAPOFF X3_axis, -1	;	ERRORMAPOFF X3_Yaw_axis, -1			! Close all X3_axis & X3_yaw_axis error compensation
MFLAGS(X3_axis).#GANTRY = 0	;	MFLAGS(X3_Yaw_axis).#GANTRY = 0	! turn off gantry mode (MFLAGS.25)
FDEF(X3_axis).#SRL = 0	;	FDEF(X3_Yaw_axis).#SRL = 0	 		! disable software right limit response
FDEF(X3_axis).#SLL = 0	;	FDEF(X3_Yaw_axis).#SLL = 0	 		! disable software left limit response

IF (^MFLAGS(X3_axis).#BRUSHOK & MFLAGS(X3_axis).#BRUSHL) 			! Confirm BRUSHOK
	ENABLE X3_axis		
	TILL MST(X3_axis).#ENABLED	
	COMMUT X3_axis,X3_CommutCurrent								! do commutation
	TILL MFLAGS(X3_axis).#BRUSHOK								! Wait for the commutation to complete, BRUSHOK is 1
	DISABLE X3_axis		
	TILL ^MST(X3_axis).#ENABLED	
END	
IF (^MFLAGS(X3_Yaw_axis).#BRUSHOK & MFLAGS(X3_Yaw_axis).#BRUSHL)	! Confirm BRUSHOK
	ENABLE X3_Yaw_axis		
	TILL MST(X3_Yaw_axis).#ENABLED
	COMMUT X3_Yaw_axis,X3_Yaw_CommutCurrent							! do commutation
	TILL MFLAGS(X3_Yaw_axis).#BRUSHOK							! Wait for the commutation to complete, BRUSHOK is 1
	DISABLE X3_Yaw_axis		
	TILL ^MST(X3_Yaw_axis).#ENABLED	
END	

DISABLE (X3_axis,X3_Yaw_axis)	
TILL ^MST(X3_axis).#ENABLED & ^MST(X3_Yaw_axis).#ENABLED	
WAIT 500	

E_TYPE(X3_axis)=13 ; 	E_TYPE(X3_Yaw_axis)=13 ;!add 2023.11.08
E_AOFFS(X3_axis) = 0 ; 	E_AOFFS(X3_Yaw_axis) = 0 ; !add 2023.11.08

MFLAGS(X3_axis).#OPEN =0 ;	MFLAGS(X3_Yaw_axis).#OPEN =0	 		! close loop control
FDEF(X3_axis).#LL = 	0	;	FDEF(X3_Yaw_axis).#LL =  0			! motor is not disable when left limit signal rising.

IF X3_IsUsingGantryHmGain=1
	CALL HmGain
END
								! Comove
ACC(X3_Yaw_axis)=ACC(X3_axis)									! X3_axis & X3_Yaw_axis should same motion profile
DEC(X3_Yaw_axis)=DEC(X3_axis)	
JERK(X3_Yaw_axis)=JERK(X3_axis)
XCURI(X3_Yaw_axis)=XCURI(X3_axis)	
XCURV(X3_Yaw_axis)=XCURV(X3_axis)	
SLPKP(X3_Yaw_axis)=SLPKP(X3_axis)
SLVKP(X3_Yaw_axis)=SLVKP(X3_axis)
SLVKI(X3_Yaw_axis)=SLVKI(X3_axis)
XCURI(X3_Yaw_axis)=XCURI(X3_axis)
XCURV(X3_Yaw_axis)=XCURV(X3_axis)
ENABLE (X3_axis,X3_Yaw_axis)
TILL MST(X3_axis).#ENABLED & MST(X3_Yaw_axis).#ENABLED	

!add 2023.11.08
DISP"X3_axis Start to find the left limit......"
JOG/V X3_axis,-X3_HmVel	
TILL FAULT(X3_axis).#LL 
HALT X3_axis 
TILL ^MST(X3_axis).#MOVE											! if reach left limit , stop motion
DISP"X3_axis Already found the left limit!!"
JOG/V X3_axis,X3_IndVel											!leave the left limit in positive direction
TILL ^FAULT(X3_axis).#LL 										    !if leave the left limit, stop motion
HALT X3_axis		
TILL ^MST(X3_axis).#MOVE 

PTP/ERV X3_axis,1000,X3_HmVel
TILL ^MST(X3_axis).#MOVE 	
DISP"X3_axis already leave the left limit!!"


!add 2023.11.08
!X3_Yaw_axis
DISP"X3_Yaw_axis Start to find the left limit......"
JOG/V X3_Yaw_axis,-X3_HmVel	
TILL FAULT(X3_Yaw_axis).#LL 
HALT X3_Yaw_axis 
TILL ^MST(X3_Yaw_axis).#MOVE											! if reach left limit , stop motion
DISP"X3_Yaw_axis Already found the left limit!!"
JOG/V X3_Yaw_axis,X3_IndVel											!leave the left limit in positive direction
TILL ^FAULT(X3_Yaw_axis).#LL 										    !if leave the left limit, stop motion
HALT X3_Yaw_axis		
TILL ^MST(X3_Yaw_axis).#MOVE 

PTP/ERV X3_Yaw_axis,1000,X3_HmVel
TILL ^MST(X3_Yaw_axis).#MOVE 	
DISP"X3_Yaw_axis already leave the left limit!!"
Disp"X3_axis offset  %d:  ", FPOS(X3_axis)
Disp"X3_Yaw_axis offset  %d:  ", FPOS(X3_Yaw_axis)
X3_Offset =FPOS(X3_axis)
X3_Yaw_Offset =FPOS(X3_Yaw_axis)


DISABLE (X3_axis,X3_Yaw_axis)	
TILL ^MST(X3_axis).#ENABLED & ^MST(X3_Yaw_axis).#ENABLED	
E_AOFFS(X3_axis) = X3_Offset ; 	E_AOFFS(X3_Yaw_axis) = X3_Yaw_Offset ; !add 2023.11.08

!!PTP/VW X3_axis, 0, X3_HmVel ;       !2023.11.08
!!PTP/VW X3_Yaw_axis,X3_Yawlock, X3_HmVel ;!2023.11.08
!!GO (X3_axis,X3_Yaw_axis)					!2023.11.08					! X3_axis & X3_Yaw_axis move same time
!!TILL ((APOS(X3_axis) = TPOS(X3_axis)) & (APOS(X3_Yaw_axis) = TPOS(X3_Yaw_axis)) & ^MST(X3_axis).#MOVE & ^MST(X3_Yaw_axis).#MOVE ), 20000 ;!2023.11.08


WAIT 50 ;

IF ^MST(X3_axis).#MOVE & ^MST(X3_Yaw_axis).#MOVE
	! Deactivate closed-loop and till Zb_axis_CLFlags turn off.
	WAIT 50 ;
ELSE
	HALT(X3_axis,X3_Yaw_axis)
	DISP " move to initial position timeout." ;
	STOP(6)
END	

	
!!DISP"Already found the index!!"	!2023.11.08	
!
!!DISABLE (X3_axis,X3_Yaw_axis)	!2023.11.08	
!!TILL ^MST(X3_axis).#ENABLED & ^MST(X3_Yaw_axis).#ENABLED!2023.11.08	
!!wait 3000
!
!!MFLAGS(X3_axis).#GANTRY = 1	;	MFLAGS(X3_Yaw_axis).#GANTRY = 1	! turn on gantry mode!2023.11.08	
!!XCURI(X3_axis) = X3_M_XCURI	;	XCURI(X3_Yaw_axis) = X3_S_XCURI !2023.11.08	
!!XCURV(X3_axis) = X3_M_XCURV	;	XCURV(X3_Yaw_axis) = X3_S_XCURV !2023.11.08	
!!IF X3_IsUsingGantryHmGain=1!2023.11.08	
!!	CALL ProdGain !2023.11.08	
!!END!2023.11.08	
!
!!Customized !2023.11.08	
RET
STOP
!------------------------------------------------------------------X3_HmType3--------------------------------------------------------------------------------------
X3_HmType3:

RET	
STOP
!------------------------------------------------------------------X3_HmType4--------------------------------------------------------------------------------------
X3_HmType4:


RET	
STOP
!!****************************************************** Error Compensation Process ***************************************************!!
X3_ErrorCompensation:
!---------- X3_axis Error Compensation Table ------------!
X3_ErrTable(0)=	0	;
X3_ErrTable(1)=	0.1	;
X3_ErrTable(2)=	2.8	;
X3_ErrTable(3)=	5.8	;
X3_ErrTable(4)=	6.5	;
X3_ErrTable(5)=	7.7	;
X3_ErrTable(6)=	10.8	;
X3_ErrTable(7)=	14.4	;
X3_ErrTable(8)=	17.2	;
X3_ErrTable(9)=	20.3	;
X3_ErrTable(10)=	25.2	;
X3_ErrTable(11)=	27.2	;
X3_ErrTable(12)=	29.4	;
X3_ErrTable(13)=	28.6	;
X3_ErrTable(14)=	28.6	;
X3_ErrTable(15)=	29.7	;
X3_ErrTable(16)=	30.9	;
X3_ErrTable(17)=	31.7	;
X3_ErrTable(18)=	34.1	;
X3_ErrTable(19)=	35.4	;
X3_ErrTable(20)=	36.4	;

!-------------------------------------------------------!
X3_ErrTableIndex = 0
WHILE X3_ErrTableIndex < SIZEOF(X3_ErrTable)
	X3_ErrTable(X3_ErrTableIndex) = -X3_ErrTable(X3_ErrTableIndex)
	X3_ErrTableIndex = X3_ErrTableIndex + 1
END
ERRORUNMAP X3_axis, ZONE0
ERRORMAP1D X3_axis, ZONE0, X3_ErrCompIniPos, X3_ErrCompensationSpacing, X3_ErrTable
ERRORMAPON X3_axis, ZONE0

WAIT 500	
DISP "Cmpensation Procces's completed!"

RET 
STOP

!!*************************************************************************************************************************************!!
!!********************************************************* Current Compensation ******************************************************!!
X3_CurrentCompensation:
ENABLE X3_axis
TILL MST(X3_axis).#ENABLED & MST(X3_Yaw_axis).#ENABLED 
PTP/EV X3_axis,X3_CurrentCompensationIniPos,X3_HmVel
DISABLE X3_axis
TILL ^MST(X3_axis).#ENABLED & ^MST(X3_Yaw_axis).#ENABLED 
!MFLAGS(X3_Yaw_axis).#OPEN = 1		
SLPKP(X3_Yaw_axis)=0;
ENABLE X3_axis
TILL MST(X3_axis).#ENABLED & MST(X3_Yaw_axis).#ENABLED 

PTP/EV X3_axis,X3_CurrentCompensationIniPos,X3_HmVel
WAIT X3_CurrentCompensationSettleTime
X3_CurrentCompensationIndex = 0

!Move positive
DISP"Y error table search sequence in positive direction......"
WHILE X3_CurrentCompensationIndex <= X3_CurrentCompensationSegment
	DISP"Y FPOS=%f , Y Yaw Offset = %f ",FPOS(X3_axis),FPOS(X3_Yaw_axis)
	X3_CurrentTableTemp(0)(X3_CurrentCompensationIndex) = FPOS(X3_Yaw_axis)
	IF X3_CurrentCompensationIndex < X3_CurrentCompensationSegment
		PTP/ERV X3_axis,X3_CurrentCompensationSpacing,X3_HmVel		
		WAIT X3_CurrentCompensationSettleTime
	END
	X3_CurrentCompensationIndex = X3_CurrentCompensationIndex + 1	
END

PTP/EV X3_axis,X3_CurrentCompensationIniPos + X3_CurrentCompensationTravel,X3_HmVel
WAIT X3_CurrentCompensationSettleTime
X3_CurrentCompensationIndex = X3_CurrentCompensationSegment
!Move negative unfinished
DISP"Y error table search sequence in negative direction......"
WHILE X3_CurrentCompensationIndex >= 0
	DISP"Y FPOS=%f , Y Yaw Offset = %f ",FPOS(X3_axis),FPOS(X3_Yaw_axis)
	X3_CurrentTableTemp(1)(X3_CurrentCompensationIndex) = FPOS(X3_Yaw_axis)
	IF X3_CurrentCompensationIndex > 0
		PTP/ERV X3_axis,-X3_CurrentCompensationSpacing,X3_HmVel		
		WAIT X3_CurrentCompensationSettleTime
	END
	X3_CurrentCompensationIndex = X3_CurrentCompensationIndex - 1	
END

X3_CurrentCompensationIndex = 0
WHILE X3_CurrentCompensationIndex <= X3_CurrentCompensationSegment
	X3_CurrentTable(X3_CurrentCompensationIndex)	=	(X3_CurrentTableTemp(0)(X3_CurrentCompensationIndex) + X3_CurrentTableTemp(1)(X3_CurrentCompensationIndex))/2
	X3_CurrentCompensationIndex = X3_CurrentCompensationIndex + 1
END

WRITE X3_CurrentTable,X3_CurrentTable
WAIT 1500	
PTP/EV X3_axis,X3_CurrentCompensationIniPos,X3_HmVel
WAIT 500	

X3_TurnOnCurrentCompensation:
DISABLE X3_axis
TILL ^MST(X3_axis).#ENABLED & ^MST(X3_Yaw_axis).#ENABLED
MFLAGS(X3_Yaw_axis).#OPEN = 0
ENABLE (X3_axis,X3_Yaw_axis)
TILL MST(X3_axis).#ENABLED & MST(X3_Yaw_axis).#ENABLED
READ X3_CurrentTable,X3_CurrentTable
ERRORUNMAP X3_Yaw_axis, ZONE0
ERRORMAP1D X3_Yaw_axis, ZONE0, X3_CurrentCompensationIniPos, X3_CurrentCompensationSpacing, X3_CurrentTable
ERRORMAPON X3_Yaw_axis, ZONE0
DISP"Current compensaton completed!"
RET 
STOP
!!*************************************************************************************************************************************!!
!**************************************Gains for homing********************************************!
HmGain:

SLPKP(X3_axis)= X3_GantryHmM_SLPKP	
SLVKP(X3_axis)= X3_GantryHmM_SLVKP	
SLVKI(X3_axis)= X3_GantryHmM_SLVKI	

SLPKP(X3_Yaw_axis)= X3_GantryHmS_SLPKP	
SLVKP(X3_Yaw_axis)= X3_GantryHmS_SLVKP	
SLVKI(X3_Yaw_axis)= X3_GantryHmS_SLVKI	


RET	
STOP
!**************************************Gains for production*****************************************!
ProdGain:

SLPKP(X3_axis)= X3_GantryProdM_SLPKP	
SLVKP(X3_axis)= X3_GantryProdM_SLVKP	
SLVKI(X3_axis)= X3_GantryProdM_SLVKI	

SLPKP(X3_Yaw_axis)= X3_GantryProdS_SLPKP	
SLVKP(X3_Yaw_axis)= X3_GantryProdS_SLVKP	
SLVKI(X3_Yaw_axis)= X3_GantryProdS_SLVKI	

RET
STOP
!!*************************************************************************************************************************************!!


!!#############################################################################################################################

ON X3_GantryHomeStep = 1 & X3_IsFlexibleGantry = 1 & FAULT(X3_axis).#LL
	HALT X3_axis
RET

ON X3_GantryHomeStep = 1 & X3_IsFlexibleGantry = 1 & FAULT(X3_Yaw_axis).#LL
	HALT X3_Yaw_axis
RET

ON X3_GantryHomeStep = 2 & X3_IsFlexibleGantry = 1 & ^FAULT(X3_axis).#LL
	HALT X3_axis
RET

ON X3_GantryHomeStep = 2 & X3_IsFlexibleGantry = 1 & ^FAULT(X3_Yaw_axis).#LL
	HALT X3_Yaw_axis
RET


ON MFLAGS(X3_axis).#HOME=1 & MFLAGS(X3_Yaw_axis).#HOME=1 & TPOS(X3_axis) < SLLIMIT(X3_axis) 
	IF( FDEF(X3_axis).#SLL=1 & FMASK(X3_axis).#SLL=1 & ^(GMTYPE(X3_axis)=5))
		KILL X3_axis,5016	!Software Left Limit
		TPOS(X3_axis)=FPOS(X3_axis)
		DISP "TPOS(X3_axis) < SLLIMIT(X3_axis)"
	END
RET

ON MFLAGS(X3_axis).#HOME=1 & MFLAGS(X3_Yaw_axis).#HOME=1 & TPOS(X3_axis) > SRLIMIT(X3_axis) 
	IF(FDEF(X3_axis).#SRL=1 & FMASK(X3_axis).#SRL=1 & ^(GMTYPE(X3_axis)=5))
		KILL X3_axis,5015	!Software Right Limit
		TPOS(X3_axis)=FPOS(X3_axis)
		DISP "TPOS(X3_axis) > SRLIMIT(X3_axis)"
	END
RET

ON MFLAGS(X3_axis).#HOME=1 & MFLAGS(X3_Yaw_axis).#HOME=1 & TPOS(X3_Yaw_axis) < SLLIMIT(X3_Yaw_axis) 
	IF( FDEF(X3_Yaw_axis).#SLL=1 & FMASK(X3_Yaw_axis).#SLL=1 & ^(GMTYPE(X3_Yaw_axis)=5))
		KILL X3_Yaw_axis,5016	!Software Left Limit
		TPOS(X3_Yaw_axis)=FPOS(X3_Yaw_axis)
		DISP "TPOS(X3_Yaw_axis) < SLLIMIT(X3_Yaw_axis)"
	END
RET

ON MFLAGS(X3_axis).#HOME=1 & MFLAGS(X3_Yaw_axis).#HOME=1 & TPOS(X3_Yaw_axis) > SRLIMIT(X3_Yaw_axis) 
	IF(FDEF(X3_Yaw_axis).#SRL=1 & FMASK(X3_Yaw_axis).#SRL=1 & ^(GMTYPE(X3_Yaw_axis)=5))
		KILL X3_Yaw_axis,5015	!Software Right Limit
		TPOS(X3_Yaw_axis)=FPOS(X3_Yaw_axis)
		DISP "TPOS(X3_Yaw_axis) > SRLIMIT(X3_Yaw_axis)"
	END
RET



ON MFLAGS(X3_axis).#HOME=0 & MFLAGS(X3_Yaw_axis).#HOME=0 & RVEL(X3_axis) > XVEL(X3_axis)*0.5 & ^MST(X3_axis).#INPOS
	IMM VEL(X3_axis) = XVEL(X3_axis)*0.45 
RET

ON MFLAGS(X3_axis).#HOME=0 & MFLAGS(X3_Yaw_axis).#HOME=0 & RVEL(X3_axis) < -XVEL(X3_axis)*0.5 & ^MST(X3_axis).#INPOS
	IMM VEL(X3_axis) = -XVEL(X3_axis)*0.45 
RET

ON MFLAGS(X3_axis).#HOME=0 & MFLAGS(X3_Yaw_axis).#HOME=0 & RVEL(X3_Yaw_axis) > XVEL(X3_Yaw_axis)*0.5 & ^MST(X3_Yaw_axis).#INPOS
	IMM VEL(X3_Yaw_axis) = XVEL(X3_Yaw_axis)*0.45 
RET

ON MFLAGS(X3_axis).#HOME=0 & MFLAGS(X3_Yaw_axis).#HOME=0 & RVEL(X3_Yaw_axis) < -XVEL(X3_Yaw_axis)*0.5 & ^MST(X3_Yaw_axis).#INPOS
	IMM VEL(X3_Yaw_axis) = -XVEL(X3_Yaw_axis)*0.45 
RET

AUTOEXEC:
	!X3_init_pos = -1550617		X3_Yaw_init_pos = -1550680
	!MFLAGS(X3_axis).#HOME=0;	 		MFLAGS(X3_Yaw_axis).#HOME=0
	!MFLAGS(X3_axis).#GANTRY=0 ; 		MFLAGS(X3_Yaw_axis).#GANTRY=0
	!E_TYPE(X3_axis)=13 ; 				E_TYPE(X3_Yaw_axis)=13 ;
	!E_AOFFS(X3_axis) = X3_init_pos ; 	E_AOFFS(X3_Yaw_axis) = X3_Yaw_init_pos ;  	
STOP

#41
!PNAME=
!PDESC=
!TEST PEG_I
!#############################################################################################
LOCAL int PEG0_Engine=0, PEG1_Engine=1, PEG2_Engine=2, PEG16_Engine=16 ! PEG Engines
LOCAL int Moving_Axis0=0! Motor Axis (Moving Axis)
LOCAL real pulse_width=1.7 ! Width of pulse (ms)
LOCAL real first_point=0 ! First point for the PEG generation (mm)
LOCAL real interval=10000! The distance between PEG events (mm)
LOCAL real last_point=30000 ! Last point for PEG generation (mm)
!    0      10000     20000     30000
!    /|\     /|\       /|\       /|\
!##################### Go to initial position #######################################################
ENABLE (Moving_Axis0)
TILL MST(Moving_Axis0).#ENABLED 
VEL(Moving_Axis0)=50000
PTP/E Moving_Axis0,first_point-3000! Go to initial position

!##################### Triggers: Assign encoders to PEG engines #####################################
ASSIGNPEG  0,0b100                  !CMXA ASSIGNPEG
ASSIGNPEG 16,0b000                  !UDI ASSIGNPEG

!##################### Assign PEG engines to physical outputs ########################################
ASSIGNPOUTS  0, 0, 0b000                    !CMXA_PEG0_PULSE output is routed to CMXA J26/1, J26/14
ASSIGNPOUTS  0, 1, 0b000                    !CMXA_PEG1_PULSE output routed to CMXA J26/6, J26/19
ASSIGNPOUTS  0, 5, 0b110                    !CMXA_PEG2_PULSE output routed to CMXA J26/2, J26/15
ASSIGNPOUTS 16, 0, 0b000                    !UDI_PEG0_PULSE output routed to  UDI J8/5, J8/14

!################# Activate incremental PEG ##################
SET_PEG:
PEG_I/i PEG0_Engine,pulse_width,first_point,interval,last_point
PEG_I/i  PEG1_Engine,pulse_width,first_point,interval,last_point
PEG_I/i PEG2_Engine,pulse_width,first_point,interval,last_point
PEG_I/i PEG16_Engine,pulse_width,first_point,interval,last_point

!################# Wait until PEG engine is ready before executing motion##############################
TILL AST(PEG0_Engine).#PEGREADY
TILL AST(PEG1_Engine).#PEGREADY
TILL AST(PEG2_Engine).#PEGREADY
TILL AST(PEG16_Engine).#PEGREADY

!################## Start motion #######################################################################


PTP/E Moving_Axis0,last_point+3000 ! Move the motors to activate the PEG pulses
STOPPEG PEG0_Engine ! Prevent PEG pulses firing on the 'way back'
STOPPEG PEG1_Engine ! Prevent PEG pulses firing on the 'way back'
STOPPEG PEG2_Engine ! Prevent PEG pulses firing on the 'way back'
STOPPEG PEG16_Engine ! Prevent PEG pulses firing on the 'way back'

PTP/E Moving_Axis0,first_point-3000! Go to initial position
!GOTO SET_PEG
STOP

STOP
#42
!PNAME=
!PDESC=
!TEST AI/O
!
!
!
INT TEST_OUT=5
INT TEST_IN=13

WHILE(1)

AOUT(TEST_OUT)=10
WAIT(1000)
Disp"AOUT%d: %f",TEST_OUT,AOUT(TEST_OUT)
Disp"AIN%d: %f",TEST_IN,AIN(TEST_IN)
AOUT(TEST_OUT)=20
WAIT(1000)
Disp"AOUT%d: %f",TEST_OUT,AOUT(TEST_OUT)
Disp"AIN%d: %f",TEST_IN,AIN(TEST_IN)
AOUT(TEST_OUT)=-55
WAIT(1000)
Disp"AOUT%d: %f",TEST_OUT,AOUT(TEST_OUT)
Disp"AIN%d: %f",TEST_IN,AIN(TEST_IN)
AOUT(TEST_OUT)=-100
WAIT(1000)
Disp"AOUT%d: %f",TEST_OUT,AOUT(TEST_OUT)
Disp"AIN%d: %f",TEST_IN,AIN(TEST_IN)
WAIT(1000)
END

STOP
#43
!PNAME=
!PDESC=
! Random PEG Example! Product: CMhp
!=================================================================
! Variable declaration and definition
global int PEG0_Engine=0 ! PEG Engines
global int Moving_Axis0=0 ! Motor Axis (Moving Axis)
global real pulse_width=0.6 ! Width of pulse (ms)
global real POS_ARRAY(5) ! Random event positions array (mm)
global int STATE_ARRAY(5) ! 4-bit state array
POS_ARRAY(0)=1
POS_ARRAY(1)=1.02
POS_ARRAY(2)=1.08
POS_ARRAY(3)=1.10
POS_ARRAY(4)=1.13
STATE_ARRAY(0)=0b1001
STATE_ARRAY(1)=0b0010
STATE_ARRAY(2)=0b0101
STATE_ARRAY(3)=0b1100
STATE_ARRAY(4)=0b0000


!##################### Triggers: Assign encoders to PEG engines #####################################
ASSIGNPEG  0,0b100                  !CMXA ASSIGNPEG
ASSIGNPEG 16,0b000                  !UDI ASSIGNPEG

!##################### Assign PEG engines to physical outputs ########################################
ASSIGNPOUTS  0, 0, 0b000                    !CMXA_PEG0_PULSE output is routed to CMXA J26/1, J26/14
ASSIGNPOUTS  0, 1, 0b000                    !CMXA_PEG1_PULSE output routed to CMXA J26/6, J26/19
ASSIGNPOUTS  0, 5, 0b110                    !CMXA_PEG2_PULSE output routed to CMXA J26/2, J26/15
ASSIGNPOUTS 16, 0, 0b000                    !UDI_PEG0_PULSE output routed to  UDI J8/5, J8/14



ENABLE Moving_Axis0
PTP/E Moving_Axis0,(POS_ARRAY(0)-1)
! Motion and PEG activation
SET_PEG:
PEG_R PEG0_Engine,pulse_width,0x4444,0,4,POS_ARRAY,STATE_ARRAY ! Activate random PEG for PEG0_Engine
TILL AST(PEG0_Engine).#PEGREADY ! Wait until PEG is ready before executing motion
PTP/EV Moving_Axis0,(POS_ARRAY(4)+1),200 ! Move the motor to activate the PEG pulses
STOPPEG PEG0_Engine ! Prevent PEG pulses firing on the 'way back'
PTP/E Moving_Axis0,(POS_ARRAY(0)-1) ! Go to initial position
GOTO SET_PEG
STOP
#45
!PNAME=
!PDESC=
! linear segment to a segmented motion(X Axis and Z Axis)
!###############################################################################################BCB Call
GLOBAL REAL M_Axis_PointTable(100)
GLOBAL REAL Current_Axis_PointTable(100)
GLOBAL REAL Current_Velocity(100)
GLOBAL REAL M_AXIS_PEG(100)
GLOBAL INT  PointCount

!################################################################################################PEG
GLOBAL INT StateArray(100)
GLOBAL INT CurrentCount
LOCAL INT  Line_Axis(2)

!################################################################################################
LOCAL INT PEG0_Engine=0, PEG1_Engine=1, PEG2_Engine=2, PEG16_Engine=16 ! PEG Engines
LOCAL REAL Pulse_Width = 1.7 ! Width of pulse (ms) max:1.7mm
LOCAL REAL First_Point = 0 ! First point for the PEG generation (mm)
LOCAL REAL Interval   = 0! The distance between PEG events (mm)
LOCAL REAL Last_Point = 0 ! Last point for PEG generation (mm)
!##################################################################################################


!#####################M_AXIS_PEG1-4#   ############################################################
GLOBAL REAL  M_AXIS_PEG_1(100)
GLOBAL REAL  M_AXIS_PEG_2(100)
GLOBAL REAL  M_AXIS_PEG_3(100)
GLOBAL REAL  M_AXIS_PEG_4(100)
LOCAL REAL   X_POS = 0
LOCAL REAL   Y_POS = 0
LOCAL INT    iIndex=0
LOCAL INT    iOffSet = 0
!PEG_R
LOCAL INT M_AXIS_PEG_1_Index = 0
LOCAL INT M_AXIS_PEG_2_Index = 0
LOCAL INT M_AXIS_PEG_3_Index = 0
LOCAL INT M_AXIS_PEG_4_Index = 0
!####################################################################################################

!##################### Triggers: Assign encoders to PEG engines #####################################
ASSIGNPEG  0,0b100                  !CMXA ASSIGNPEG
ASSIGNPEG 16,0b000                  !UDI ASSIGNPEG
!####################################################################################################
!
!##################### Assign PEG engines to physical outputs ########################################
ASSIGNPOUTS  0, 0, 0b000                    !CMXA_PEG0_PULSE output is routed to CMXA J26/1, J26/14
ASSIGNPOUTS  0, 1, 0b000                    !CMXA_PEG1_PULSE output routed to CMXA J26/6, J26/19
ASSIGNPOUTS  0, 5, 0b110                    !CMXA_PEG2_PULSE output routed to CMXA J26/2, J26/15
ASSIGNPOUTS 16, 0, 0b000                    !UDI_PEG0_PULSE output routed to  UDI J8/5, J8/14
!####################################################################################################
!

!
!##################### user define
LOCAL INT   MoveType = 2 !
LOCAL INT   PEG_MODE = 1!For MoveType = 0 !!! 0:PEG_I  1:PEG_R
!#####################

Test:
!################# Activate incremental PEG ########################################################
STOPPEG PEG0_Engine    ! Prevent PEG pulses firing on the 'way back'
STOPPEG PEG1_Engine    ! Prevent PEG pulses firing on the 'way back'
STOPPEG PEG2_Engine    ! Prevent PEG pulses firing on the 'way back'
STOPPEG PEG16_Engine   ! Prevent PEG pulses firing on the 'way back'
!####################################################################################################

Line_Axis(0) = X1_axis
Line_Axis(1) = Y1_axis 

CurrentCount =0
!###################################################################################################################################### 0
IF MoveType=0	!For ..Ttest

		!################## Test Start motion #######################################################################
	    PTP/E Line_Axis(0),0
	    PTP/E Line_Axis(1),0!+1000
		TILL ^MST( Line_Axis(0)).#MOVE
	    TILL ^MST( Line_Axis(1)).#MOVE
		
		M_Axis_PointTable(0) =100000
		M_Axis_PointTable(1) =200000
		M_Axis_PointTable(2) =300000
		M_Axis_PointTable(3) =400000
		M_Axis_PointTable(4) =400000
!		ACC(X1_axis) = 100000
!		DEC(X1_axis) = 100000
!		ACC(Y1_axis) = 1000000
!		DEC(Y1_axis) = 1000000
        iIndex =0
		LOOP 100
		   M_AXIS_PEG_1(iIndex) = M_Axis_PointTable(iIndex)
		   M_AXIS_PEG_2(iIndex) = M_Axis_PointTable(iIndex)
		   M_AXIS_PEG_3(iIndex) = M_Axis_PointTable(iIndex)
		   M_AXIS_PEG_4(iIndex) = M_Axis_PointTable(iIndex)
		   M_AXIS_PEG(iIndex )  = M_Axis_PointTable(iIndex)
		   iIndex = iIndex +1
		END
		
		Current_Axis_PointTable(0) = 320
		Current_Axis_PointTable(1) = 320
		Current_Axis_PointTable(2) = 320
		Current_Axis_PointTable(3) = 320
		Current_Axis_PointTable(4) = 320
		
		Current_Velocity(0)= 10000
		Current_Velocity(1)= 10000
		Current_Velocity(2)= 10000
		Current_Velocity(3)= 10000
		Current_Velocity(4)= 10000
		
		StateArray(0) =0b000
		StateArray(1) =0b000
		StateArray(2) =0b000
		StateArray(3) =0b000
		
		ENABLE (X1_axis ,Y1_axis)
		TILL MST(X1_axis).#ENABLED 
		TILL MST(Y1_axis).#ENABLED 
		PointCount =2
		 
		
		First_Point = M_Axis_PointTable(0)
	    Last_Point  = M_Axis_PointTable(1)	 
		Interval = M_Axis_PointTable(1) - M_Axis_PointTable(0)
		iOffSet =10000	
		if(First_Point>Last_Point)
	   		M_Axis_PointTable(0)= M_Axis_PointTable(0) +iOffSet
			M_Axis_PointTable(PointCount-1)= M_Axis_PointTable(PointCount-1) -iOffSet
	
		ELSE
	  		M_Axis_PointTable(0)= M_Axis_PointTable(0) -iOffSet
	   		M_Axis_PointTable(PointCount-1)= M_Axis_PointTable(PointCount-1) +iOffSet
	
		END	
	
	    IF PEG_MODE = 0	 
	    	!PEG_I
			PEG_I/i  PEG0_Engine , Pulse_Width , First_Point , Interval , Last_Point
			PEG_I/i  PEG1_Engine , Pulse_Width , First_Point , Interval , Last_Point
			PEG_I/i  PEG2_Engine , Pulse_Width , First_Point , Interval , Last_Point
			PEG_I/i  PEG16_Engine, Pulse_Width , First_Point , Interval , Last_Point
	    ELSE
	
	
			!###################################################################################################
	    	!=============PEG_R_Calc===========================================================!!
	    	!!Poss_array=user_pos*0.5+EOFFS(y1)*0.5+EOFFS(y2)*0.25.
	
!!	    	WHILE M_AXIS_PEG_1_Index < SIZEOF(M_AXIS_PEG_1)
!!		    	M_AXIS_PEG_1(M_AXIS_PEG_1_Index) = 2 * (M_AXIS_PEG_1(M_AXIS_PEG_1_Index)- 0.5 * EOFFS (X1_axis) -0.25 * EOFFS (X1_Yaw_axis))
!!				M_AXIS_PEG_1_Index = M_AXIS_PEG_1_Index + 1
!!			END
!!	
!!	
!!			WHILE M_AXIS_PEG_2_Index < SIZEOF(M_AXIS_PEG_2)
!!				M_AXIS_PEG_2(M_AXIS_PEG_2_Index) = 2 * (M_AXIS_PEG_2(M_AXIS_PEG_2_Index)- 0.5 * EOFFS (X1_axis) -0.25 * EOFFS (X1_Yaw_axis))
!!				M_AXIS_PEG_2_Index = M_AXIS_PEG_2_Index + 1
!!			END
!!	
!!    
!!			WHILE M_AXIS_PEG_3_Index < SIZEOF(M_AXIS_PEG_3)
!!				M_AXIS_PEG_3(M_AXIS_PEG_3_Index) = 2 * (M_AXIS_PEG_3(M_AXIS_PEG_3_Index)- 0.5 * EOFFS (X1_axis) -0.25 * EOFFS (X1_Yaw_axis))
!!				M_AXIS_PEG_3_Index = M_AXIS_PEG_3_Index + 1
!!			END
	 
 
		!###################################################################################################
		!PEG_R
    		PEG_R/i PEG0_Engine  , Pulse_Width , 0x4444, 0 , PointCount-1 , M_AXIS_PEG_1 , StateArray
			PEG_R/i PEG1_Engine  , Pulse_Width , 0x4444, 0 , PointCount-1 , M_AXIS_PEG_2 , StateArray
			PEG_R/i PEG2_Engine  , Pulse_Width , 0x4444, 0 , PointCount-1 , M_AXIS_PEG_3 , StateArray
			PEG_R/i PEG16_Engine , Pulse_Width , 0x4444, 0 , PointCount-1 , M_AXIS_PEG_4 , StateArray	
		!####################################################################################################
		
!!!!! test			
!!!!!			TILL AST(PEG0_Engine).#PEGREADY
!!!!!			TILL AST(PEG1_Engine).#PEGREADY
!!!!!			TILL AST(PEG2_Engine).#PEGREADY
!!!!!			TILL AST(PEG16_Engine).#PEGREADY
!!!!!			PTP/E Line_Axis(0),M_Axis_PointTable(PointCount-1)
!!!!!			TILL ^MST(Line_Axis(0)).#MOVE
!!!!!			call Test 
!!!!!			STOP

    END			
	!################## Tes end motion #######################################################################
	
!###################################################################################################################################### 1
ELSEIF MoveType= 1 !pro run
    !##########################  PEG_I/i
	   ! PTP/E Line_Axis(0),0
	   ! PTP/E Line_Axis(1),0!+1000
	iIndex =0
	LOOP 100
	   M_AXIS_PEG_1(iIndex) = M_AXIS_PEG(iIndex)
	   M_AXIS_PEG_2(iIndex) = M_AXIS_PEG(iIndex)
	   M_AXIS_PEG_3(iIndex) = M_AXIS_PEG(iIndex)
	   M_AXIS_PEG_4(iIndex) = M_AXIS_PEG(iIndex)
	   iIndex = iIndex +1
	END
		
    First_Point = M_AXIS_PEG(0);
    Last_Point  = M_AXIS_PEG(PointCount-1);	
	Interval    = M_AXIS_PEG(PointCount-1) - M_AXIS_PEG(0)
	
	if(First_Point>Last_Point)
	    if(M_AXIS_PEG(0) = M_Axis_PointTable(0))
	    	M_Axis_PointTable(0)= M_Axis_PointTable(0) +iOffSet
		END
		if(M_AXIS_PEG(PointCount-1) = M_Axis_PointTable(PointCount-1))
			M_Axis_PointTable(PointCount-1)= M_Axis_PointTable(PointCount-1) -iOffSet
		END
	
	ELSE
	   if(M_AXIS_PEG(0) = M_Axis_PointTable(0))
	   		M_Axis_PointTable(0)= M_Axis_PointTable(0) -iOffSet
	   END
	   if(M_AXIS_PEG(PointCount-1) = M_Axis_PointTable(PointCount-1))
	       M_Axis_PointTable(PointCount-1)= M_Axis_PointTable(PointCount-1) +iOffSet  !2000
	  END
	
	END	
	!PEG_I
	PEG_I/i  PEG0_Engine , Pulse_Width , First_Point ,Interval , Last_Point
	PEG_I/i  PEG1_Engine , Pulse_Width , First_Point ,Interval , Last_Point
	PEG_I/i  PEG2_Engine , Pulse_Width , First_Point ,Interval , Last_Point
	PEG_I/i  PEG16_Engine, Pulse_Width , First_Point ,Interval , Last_Point
    DISP "First_Point:         %d  Last_Point:          %d",First_Point,Last_Point
	DISP "M_Axis_PointTable(0):%d  M_Axis_PointTable(1):%d",M_Axis_PointTable(0),M_Axis_PointTable(1)

!###################################################################################################################################### 2
ELSEIF MoveType= 2
  	!############################################  PEG_R/i
    iIndex =0
	LOOP 100
	   M_AXIS_PEG_1(iIndex) = M_AXIS_PEG(iIndex)
	   M_AXIS_PEG_2(iIndex) = M_AXIS_PEG(iIndex)
	   M_AXIS_PEG_3(iIndex) = M_AXIS_PEG(iIndex)
	   M_AXIS_PEG_4(iIndex) = M_AXIS_PEG(iIndex)
	   StateArray(iIndex) =0b000
	   iIndex = iIndex +1
	END
	
	
	if(First_Point>Last_Point)
	    if(M_AXIS_PEG(0) = M_Axis_PointTable(0))
	    	M_Axis_PointTable(0)= M_Axis_PointTable(0) + iOffSet
		END
		if(M_AXIS_PEG(PointCount-1) = M_Axis_PointTable(PointCount-1))
			M_Axis_PointTable(PointCount-1)= M_Axis_PointTable(PointCount-1) - iOffSet
		END
	
	ELSE
	   if(M_AXIS_PEG(0) = M_Axis_PointTable(0))
	   		M_Axis_PointTable(0)= M_Axis_PointTable(0) - iOffSet
	   END
	   if(M_AXIS_PEG(PointCount-1) = M_Axis_PointTable(PointCount-1))
	       M_Axis_PointTable(PointCount-1)= M_Axis_PointTable(PointCount-1) + iOffSet
	   END
	END	
	
	
	!###################################################################################################
	!=============PEG_R_Calc===========================================================!!
	!!Poss_array=user_pos*0.5+EOFFS(y1)*0.5+EOFFS(y2)*0.25.
	
!!!!	WHILE M_AXIS_PEG_1_Index < SIZEOF(M_AXIS_PEG_1)
!!!!		M_AXIS_PEG_1(M_AXIS_PEG_1_Index) = 2 * (M_AXIS_PEG_1(M_AXIS_PEG_1_Index)- 0.5 * EOFFS (X1_axis) -0.25 * EOFFS (X1_Yaw_axis))
!!!!		M_AXIS_PEG_1_Index = M_AXIS_PEG_1_Index + 1
!!!!	END
!!!!	
!!!!	
!!!!	WHILE M_AXIS_PEG_2_Index < SIZEOF(M_AXIS_PEG_2)
!!!!		M_AXIS_PEG_2(M_AXIS_PEG_2_Index) = 2 * (M_AXIS_PEG_2(M_AXIS_PEG_2_Index)- 0.5 * EOFFS (X1_axis) -0.25 * EOFFS (X1_Yaw_axis))
!!!!		M_AXIS_PEG_2_Index = M_AXIS_PEG_2_Index + 1
!!!!	END
!!!!	
!!!!    
!!!!	WHILE M_AXIS_PEG_3_Index < SIZEOF(M_AXIS_PEG_3)
!!!!		M_AXIS_PEG_3(M_AXIS_PEG_3_Index) = 2 * (M_AXIS_PEG_3(M_AXIS_PEG_3_Index)- 0.5 * EOFFS (X1_axis) -0.25 * EOFFS (X1_Yaw_axis))
!!!!		M_AXIS_PEG_3_Index = M_AXIS_PEG_3_Index + 1
!!!!	END
	 
 
	!###################################################################################################

	
	!###################################################################################################
	!PEG_R
    		PEG_R/i PEG0_Engine  , Pulse_Width , 0x4444, 0 , PointCount-1 , M_AXIS_PEG_1 , StateArray
			PEG_R/i PEG1_Engine  , Pulse_Width , 0x4444, 0 , PointCount-1 , M_AXIS_PEG_2 , StateArray
			PEG_R/i PEG2_Engine  , Pulse_Width , 0x4444, 0 , PointCount-1 , M_AXIS_PEG_3 , StateArray
			PEG_R/i PEG16_Engine , Pulse_Width , 0x4444, 0 , PointCount-1 , M_AXIS_PEG_4 , StateArray	
	!####################################################################################################
	if(ABS(M_AXIS_PEG(0)- M_AXIS_PEG_1(0))>500)
	   !STOP
	END
	
	

END
!####################################################################################################


 
!################# Wait until PEG engine is ready before executing motion##############################
TILL AST(PEG0_Engine).#PEGREADY
TILL AST(PEG1_Engine).#PEGREADY
TILL AST(PEG2_Engine).#PEGREADY
TILL AST(PEG16_Engine).#PEGREADY

X_POS = FPOS(Line_Axis(0))
Y_POS = FPOS(Line_Axis(1))
!#####################################################################################################
IF ^MST(X1_axis).#ENABLED  | ^MST(X1_Yaw_axis).#ENABLED  | ^MST(Y1_axis).#ENABLED 
    STOP
ELSE
    MSEG/v Line_Axis, X_POS,Y_POS
   
         CurrentCount=0
        LOOP PointCount
            LINE Line_Axis,M_Axis_PointTable(CurrentCount),Current_Axis_PointTable(CurrentCount),Current_Velocity(CurrentCount)
            CurrentCount=CurrentCount+1
        END
    ENDS Line_Axis

	
	TILL ^MST(X1_axis).#MOVE
	TILL ^MST(Y1_axis).#MOVE
!!!!call Test 
    STOP
END
!#####################################################################################################
STOP



#46
!PNAME=
!PDESC=
!!GLOBAL Errorcode
AUTOEXEC:
LOCAL INT T1_EtherCATIndex = 1
LOCAL INT X2_1_EtherCATIndex = 4	
LOCAL INT X2_2_EtherCATIndex = 5	
LOCAL INT X2_3_EtherCATIndex = 6	
LOCAL INT X2_4_EtherCATIndex = 7	
LOCAL INT Z2_1_EtherCATIndex = 8	
LOCAL INT Z2_2_EtherCATIndex = 9
LOCAL INT Z2_3_EtherCATIndex = 10	
LOCAL INT Z2_4_EtherCATIndex = 11		
LOCAL INT T2_1_EtherCATIndex = 12
LOCAL INT T2_2_EtherCATIndex = 13
LOCAL INT T2_3_EtherCATIndex = 14
LOCAL INT T2_4_EtherCATIndex = 15

LOCAL INT Y3_1_EtherCATIndex = 18
LOCAL INT Y3_2_EtherCATIndex = 19	
LOCAL INT Z3_EtherCATIndex   = 20	
LOCAL INT Z4_EtherCATIndex   = 21	
LOCAL INT Y4_1_EtherCATIndex = 22		
LOCAL INT Y4_2_EtherCATIndex = 23	
LOCAL INT X4_1_EtherCATIndex = 24	
LOCAL INT X4_2_EtherCATIndex = 25	
LOCAL INT Z5_1_EtherCATIndex = 26	
LOCAL INT Z5_2_EtherCATIndex = 27		
LOCAL INT Z6_EtherCATIndex   = 28	
!!

ECIN( ECGETOFFSET("Error code",T1_EtherCATIndex),   AxisErrorCode8) 

ECIN( ECGETOFFSET("Error code",X2_1_EtherCATIndex), AxisErrorCode19) 

ECIN( ECGETOFFSET("Error code",X2_2_EtherCATIndex), AxisErrorCode20) 
ECIN( ECGETOFFSET("Error code",X2_3_EtherCATIndex), AxisErrorCode21) 
ECIN( ECGETOFFSET("Error code",X2_4_EtherCATIndex), AxisErrorCode22) 

ECIN( ECGETOFFSET("Error code",Z2_1_EtherCATIndex), AxisErrorCode23) 
ECIN( ECGETOFFSET("Error code",Z2_2_EtherCATIndex), AxisErrorCode24) 
ECIN( ECGETOFFSET("Error code",Z2_3_EtherCATIndex), AxisErrorCode25) 
ECIN( ECGETOFFSET("Error code",Z2_4_EtherCATIndex), AxisErrorCode26) 

ECIN( ECGETOFFSET("Error code",T2_1_EtherCATIndex), AxisErrorCode27) 

ECIN( ECGETOFFSET("Error code",T2_2_EtherCATIndex), AxisErrorCode28) 
ECIN( ECGETOFFSET("Error code",T2_3_EtherCATIndex), AxisErrorCode29) 
ECIN( ECGETOFFSET("Error code",T2_4_EtherCATIndex), AxisErrorCode30) 

ECIN( ECGETOFFSET("Error code",Y3_1_EtherCATIndex), AxisErrorCode31) 
ECIN( ECGETOFFSET("Error code",Y3_2_EtherCATIndex), AxisErrorCode32) 

ECIN( ECGETOFFSET("Error code",Z3_EtherCATIndex), AxisErrorCode33) 
ECIN( ECGETOFFSET("Error code",Z4_EtherCATIndex), AxisErrorCode34) 

ECIN( ECGETOFFSET("Error code",Y4_1_EtherCATIndex), AxisErrorCode35) 
ECIN( ECGETOFFSET("Error code",Y4_2_EtherCATIndex), AxisErrorCode36) 
ECIN( ECGETOFFSET("Error code",X4_1_EtherCATIndex), AxisErrorCode37) 
ECIN( ECGETOFFSET("Error code",X4_2_EtherCATIndex), AxisErrorCode38) 
ECIN( ECGETOFFSET("Error code",Z5_1_EtherCATIndex), AxisErrorCode39) 
ECIN( ECGETOFFSET("Error code",Z5_2_EtherCATIndex), AxisErrorCode40) 

ECIN( ECGETOFFSET("Error code",Z6_EtherCATIndex), AxisErrorCode41) 

!! inp windows !!2023.11.10
TARGRAD0=30
TARGRAD1=30
TARGRAD2=30
!TARGRAD3=30
TARGRAD4=30
TARGRAD5=30
TARGRAD6=30
TARGRAD7=30
TARGRAD8=30
TARGRAD9=30

TARGRAD10=30
TARGRAD11=30
TARGRAD12=30
TARGRAD13=30
TARGRAD14=30
TARGRAD15=30
!TARGRAD16=30
!TARGRAD17=30
TARGRAD18=30
TARGRAD19=30

TARGRAD20=30
TARGRAD21=30
TARGRAD22=30
TARGRAD23=30
TARGRAD24=30
TARGRAD25=30
TARGRAD26=30
TARGRAD27=30
TARGRAD28=30
TARGRAD29=30

TARGRAD30=30
TARGRAD31=30
TARGRAD32=30
TARGRAD33=30
TARGRAD34=30
TARGRAD35=30
TARGRAD36=30
TARGRAD37=30
TARGRAD38=30
TARGRAD39=30

TARGRAD40=30
TARGRAD41=30
 
STOP
#47
!PNAME=
!PDESC=
! SDO get drive warm code

GLOBAL INT WARNING,EtherCATIndex

EtherCATIndex=12

WARNING=COEREAD/4 (EtherCATIndex,0x4096,0)
DISP "WARANING %x",WARNING

STOP
#50
!PNAME=
!PDESC=
!The Program is for measuring accuracy by laser.
! Revision	Description										             Author			Date
! 1.0 ---- *Initial release-------------------------------------------------------------2016.06.03
! 1.1 ---- *remove D-buffer & Change Axis name(X_axis to Laser_axis)-----HUAI-CENG -----2022.07.02
!***********************************************
LASER_TEST:

GLOBAL INT  Laser_axis 
LOCAL REAL  Pitch,Delay
LOCAL REAL Offset
LOCAL REAL Travel_Range
LOCAL INT     Time
LOCAL REAL     Step 
GLOBAL REAL Target 

!##### The parameters about prcocess of measurement #####!
Laser_axis = 31; 							!axis number in acs
Time = 1 ; 								!the number of cycles (repeat times)
Travel_Range =	1500000;						!the stroke in accuracy measurement (mm)
Pitch = 75000; 							!the length of each step in accuracy measurement (mm)
Offset = 1000 ; 							!the initial offset before testing
Step = ( Travel_Range / Pitch ) ; 		!total number of steps in full stroke
Delay =1500 ; 							!wating time between each step.(ms)
!########################################################!

LOOP Time 
     
    PTP/RV ( Laser_axis ), -Offset, 100000 ; 
    TILL MST ( Laser_axis ).#INPOS ;!OUT0.0 = 1 ;
     WAIT Delay ;!OUT0.0 = 0 ;

     PTP/RV ( Laser_axis ), Offset, 100000 ; 
     TILL MST ( Laser_axis ).#INPOS ; WAIT Delay  ; OUT0.0=1;
     WAIT Delay ;OUT0.0=0 ;

     Target = Pitch ; 
     LOOP Step 
          PTP/RV ( Laser_axis ), Pitch, 100000 ;
          TILL MST ( Laser_axis ).#INPOS ; WAIT Delay ; OUT0.0=1
          WAIT Delay ; OUT0.0=0 ;

     END
          
     PTP/RV ( Laser_axis ), Offset, 100000 ; 
     TILL MST (Laser_axis ).#INPOS ;!OUT0.0=1 
     WAIT Delay ; !OUT0.0=0  

     PTP/RV ( Laser_axis ), -Offset, 100000 ; 
     TILL MST ( Laser_axis ).#INPOS ;WAIT Delay  ; OUT0.0=1 
     WAIT Delay ; OUT0.0=0 ;


     LOOP Step 
          PTP/RV (Laser_axis ), -Pitch, 100000 ;
          TILL MST ( Laser_axis ).#INPOS ;WAIT Delay ; OUT0.0=1 
          WAIT Delay; OUT0.0=0

     END

END
STOP






#59
!PNAME=
!PDESC=
!!! EtherCAT Frame Diagnostics
int nSlaves
int register(8)
int i

nSlaves = ecgetslaves()
disp "|-----------------------------------------------------------------------------|"
disp "|          | 0x300 | 0x302 |  0x308   |  0x309   |  0x30C   |0x30D|0x310|0x311|"
disp "|          -------------------------------------------------------------------|"
disp "|          |Invalid|Invalid| Invalid  | Invalid  |Processing| PDI |Link |Link |"
disp "|          | Frame | Frame |Prv.Marked|Prv.Marked|   Unit   |Error|Lost |Lost |"
disp "|          |  IN   |  OUT  | Frame IN |Frame OUT |  Error   |     | IN  | OUT |"
disp "|-----------------------------------------------------------------------------|"

i = 0
LOOP nSlaves

	ECCLRREG(i, -1) 
	wait 5
	BLOCK
		register(0) = ecgetreg(i, 0x300)
		register(1) = ecgetreg(i, 0x302)
		register(2) = ecgetreg(i, 0x308)
		register(3) = ecgetreg(i, 0x309)
		register(4) = ecgetreg(i, 0x30C)
		register(5) = ecgetreg(i, 0x30D)
		register(6) = ecgetreg(i, 0x310)
		register(7) = ecgetreg(i, 0x311)
	END
	

	disp "| Slave %2d | %5d | %5d | %8d | %8d | %8d | %3d | %3d | %3d |", i, register(0), register(1), register(2), register(3), register(4), register(5), register(6), register(7)
	disp "|-----------------------------------------------------------------------------|"
	
	i = i + 1

END


STOP 
#A
!PNAME=
!PDESC=
!!!AXIS_NUM
axisdef X1_axis=0,		X1_Yaw_axis=2,    Y1_axis=1,    	Y2_1_axis=4,		Y2_1_Yaw_axis=5,	Y2_2_axis=6,	   Y2_2_Yaw_axis=7 
axisdef Y2_3_axis=8,	Y2_3_Yaw_axis=9,  Y2_4_axis=10,  	Y2_4_Yaw_axis=11,  	X3_axis=12,			X3_Yaw_axis=13,    Z1_axis=14,   	Z1_Yaw_axis=15
axisdef T1_axis=18,		X2_1_axis=19,     X2_2_axis=20, 	X2_3_axis=21,		X2_4_axis=22,   	Z2_1_axis=23,	   Z2_2_axis=24, 	Z2_3_axis=25,       Z2_4_axis=26
axisdef T2_1_axis=27,   T2_2_axis =28,    T2_3_axis = 29, 	T2_4_axis = 30, 	Y3_1_axis=31,		Y3_2_axis=32, 	   Z3_axis=33,   	Z4_axis=34 		
axisdef Y4_1_axis=35,	Y4_2_axis=36,     X4_1_axis=37, 	X4_2_axis=38,       Z5_1_axis=39,	    Z5_2_axis=40,	   Z6_axis=41

!!!CoE
GLOBAL INT T1_TouchProbFun,		T1_StatusWord,		T1_ControlWord,		T1_ModeOfOperation,        T1_IOIndex
GLOBAL INT Z2_1_TouchProbFun,	Z2_1_StatusWord,	Z2_1_ControlWord,	Z2_1_ModeOfOperation,      Z2_1_IOIndex
GLOBAL INT Z2_2_TouchProbFun,	Z2_2_StatusWord,	Z2_2_ControlWord,	Z2_2_ModeOfOperation,      Z2_2_IOIndex
GLOBAL INT Z2_3_TouchProbFun,	Z2_3_StatusWord,	Z2_3_ControlWord,	Z2_3_ModeOfOperation,      Z2_3_IOIndex
GLOBAL INT Z2_4_TouchProbFun,	Z2_4_StatusWord,	Z2_4_ControlWord,	Z2_4_ModeOfOperation,      Z2_4_IOIndex
GLOBAL INT X2_1_TouchProbFun,	X2_1_StatusWord,	X2_1_ControlWord,	X2_1_ModeOfOperation,      X2_1_IOIndex
GLOBAL INT X2_2_TouchProbFun,	X2_2_StatusWord,	X2_2_ControlWord,	X2_2_ModeOfOperation,      X2_2_IOIndex
GLOBAL INT X2_3_TouchProbFun,	X2_3_StatusWord,	X2_3_ControlWord,	X2_3_ModeOfOperation,      X2_3_IOIndex
GLOBAL INT X2_4_TouchProbFun,	X2_4_StatusWord,	X2_4_ControlWord,	X2_4_ModeOfOperation,      X2_4_IOIndex
GLOBAL INT T2_1_TouchProbFun,	T2_1_StatusWord,	T2_1_ControlWord,	T2_1_ModeOfOperation,      T2_1_IOIndex
GLOBAL INT T2_2_TouchProbFun,	T2_2_StatusWord,	T2_2_ControlWord,	T2_2_ModeOfOperation,      T2_2_IOIndex
GLOBAL INT T2_3_TouchProbFun,	T2_3_StatusWord,	T2_3_ControlWord,	T2_3_ModeOfOperation,      T2_3_IOIndex
GLOBAL INT T2_4_TouchProbFun,	T2_4_StatusWord,	T2_4_ControlWord,	T2_4_ModeOfOperation,      T2_4_IOIndex
GLOBAL INT Y3_1_TouchProbFun,	Y3_1_StatusWord,	Y3_1_ControlWord,	Y3_1_ModeOfOperation,      Y3_1_IOIndex
GLOBAL INT Y3_2_TouchProbFun,	Y3_2_StatusWord,	Y3_2_ControlWord,	Y3_2_ModeOfOperation,      Y3_2_IOIndex
GLOBAL INT Z3_TouchProbFun,		Z3_StatusWord,		Z3_ControlWord,		Z3_ModeOfOperation,        Z3_IOIndex
GLOBAL INT Z4_TouchProbFun,		Z4_StatusWord,		Z4_ControlWord,		Z4_ModeOfOperation,        Z4_IOIndex
GLOBAL INT Y4_1_TouchProbFun,	Y4_1_StatusWord,	Y4_1_ControlWord,	Y4_1_ModeOfOperation,      Y4_1_IOIndex
GLOBAL INT Y4_2_TouchProbFun,	Y4_2_StatusWord,	Y4_2_ControlWord,	Y4_2_ModeOfOperation,      Y4_2_IOIndex
GLOBAL INT X4_1_TouchProbFun,	X4_1_StatusWord,	X4_1_ControlWord,	X4_1_ModeOfOperation,      X4_1_IOIndex
GLOBAL INT X4_2_TouchProbFun,	X4_2_StatusWord,	X4_2_ControlWord,	X4_2_ModeOfOperation,      X4_2_IOIndex
GLOBAL INT Z5_1_TouchProbFun,	Z5_1_StatusWord,	Z5_1_ControlWord,	Z5_1_ModeOfOperation,      Z5_1_IOIndex
GLOBAL INT Z5_2_TouchProbFun,	Z5_2_StatusWord,	Z5_2_ControlWord,	Z5_2_ModeOfOperation,      Z5_2_IOIndex
GLOBAL INT Z6_TouchProbFun,		Z6_StatusWord,		Z6_ControlWord,		Z6_ModeOfOperation,        Z6_IOIndex





!!!ErrTable
GLOBAL REAL STATIC X1_ErrTable(31),X1_CurrentTable(31),Y1_ErrTable(11),Y2_1_ErrTable(21),Y2_1_CurrentTable(21),Y2_2_ErrTable(21),Y2_2_CurrentTable(21)
GLOBAL REAL STATIC Y2_3_ErrTable(21),Y2_3_CurrentTable(21),Y2_4_ErrTable(21),Y2_4_CurrentTable(21),X3_ErrTable(21),X3_CurrentTable(21),Z1_ErrTable(11),Z1_CurrentTable(11)
GLOBAL REAL STATIC T1_ErrTable(11) 
GLOBAL REAL STATIC X4_1_ErrTable(11),X4_2_ErrTable(11),Z5_1_ErrTable(11),Z5_2_ErrTable(11),Z6_ErrTable(11)
GLOBAL REAL STATIC Z2_1_ErrTable(11),Z2_2_ErrTable(11),Z2_3_ErrTable(11),Z2_4_ErrTable(11)
GLOBAL REAL STATIC X2_1_ErrTable(11),X2_2_ErrTable(11),X2_3_ErrTable(11),X2_4_ErrTable(11)
GLOBAL REAL STATIC T2_1_ErrTable(11),T2_2_ErrTable(11),T2_3_ErrTable(11),T2_4_ErrTable(11)
GLOBAL REAL STATIC Y3_1_ErrTable(21),Y3_2_ErrTable(21),Z3_ErrTable(11),Z4_ErrTable(11)
GLOBAL REAL STATIC Y4_1_ErrTable(11),Y4_2_ErrTable(11)

GLOBAL REAL X3_init_pos,X3_Yaw_init_pos
GLOBAL REAL Z1_init_pos,Z1_Yaw_init_pos

!=======ERROR CODE==========!
GLOBAL INT AxisErrorCode0   ,AxisErrorCode1   ,AxisErrorCode2    ,AxisErrorCode3   ,AxisErrorCode4   ,AxisErrorCode5   ,AxisErrorCode6   ,AxisErrorCode7    ,AxisErrorCode8   ,AxisErrorCode9
GLOBAL INT AxisErrorCode10  ,AxisErrorCode11  ,AxisErrorCode12   ,AxisErrorCode13  ,AxisErrorCode14  ,AxisErrorCode15  ,AxisErrorCode16  ,AxisErrorCode17   ,AxisErrorCode18  ,AxisErrorCode19
GLOBAL INT AxisErrorCode20  ,AxisErrorCode21  ,AxisErrorCode22   ,AxisErrorCode23  ,AxisErrorCode24  ,AxisErrorCode25  ,AxisErrorCode26  ,AxisErrorCode27   ,AxisErrorCode28  ,AxisErrorCode29
GLOBAL INT AxisErrorCode30  ,AxisErrorCode31  ,AxisErrorCode32   ,AxisErrorCode33  ,AxisErrorCode34  ,AxisErrorCode35  ,AxisErrorCode36  ,AxisErrorCode37   ,AxisErrorCode38  ,AxisErrorCode39
GLOBAL INT AxisErrorCode40  ,AxisErrorCode41  ,AxisErrorCode42   ,AxisErrorCode43  ,AxisErrorCode44  ,AxisErrorCode45  ,AxisErrorCode46  ,AxisErrorCode47   ,AxisErrorCode48  ,AxisErrorCode49

global int I(100),I0,I1,I2,I3,I4,I5,I6,I7,I8,I9,I90,I91,I92,I93,I94,I95,I96,I97,I98,I99
global real V(100),V0,V1,V2,V3,V4,V5,V6,V7,V8,V9,V90,V91,V92,V93,V94,V95,V96,V97,V98,V99

